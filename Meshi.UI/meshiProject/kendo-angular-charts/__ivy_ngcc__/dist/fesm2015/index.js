/**-----------------------------------------------------------------------------------------
* Copyright © 2021 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { __decorate, __metadata, __param } from 'tslib';
import { EventEmitter, Input, Output, Injectable, NgZone, Directive, Optional, TemplateRef, SimpleChange, ContentChild, Component, ChangeDetectionStrategy, ElementRef, ViewChild, ViewChildren, QueryList, isDevMode, ContentChildren, ChangeDetectorRef, Renderer2, Inject, LOCALE_ID, InjectionToken, NgModule } from '@angular/core';
import { BehaviorSubject, Subject, combineLatest } from 'rxjs';
import { auditTime, tap } from 'rxjs/operators';
import { validatePackage } from '@progress/kendo-licensing';
import { chartBaseTheme, InstanceObserver, DateCategoryAxis, DateValueAxis, DomEventsBuilder, Chart, StockChart, Sparkline } from '@progress/kendo-charts';
import { isDocumentAvailable, ResizeSensorModule } from '@progress/kendo-angular-common';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@progress/kendo-angular-popup';
import * as ɵngcc2 from '@progress/kendo-angular-l10n';
import * as ɵngcc3 from '@angular/common';
import * as ɵngcc4 from '@progress/kendo-angular-intl';
import * as ɵngcc5 from '@progress/kendo-angular-common';

const _c0 = ["content"];
function TooltipPopupComponent_ng_template_0_1_ng_template_0_Template(rf, ctx) { }
function TooltipPopupComponent_ng_template_0_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TooltipPopupComponent_ng_template_0_1_ng_template_0_Template, 0, 0, "ng-template", 5);
} if (rf & 2) {
    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r4.seriesTooltipTemplateRef)("ngTemplateOutletContext", ctx_r4.seriesTooltipContext);
} }
function TooltipPopupComponent_ng_template_0_2_ng_template_0_Template(rf, ctx) { }
function TooltipPopupComponent_ng_template_0_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵtemplate(0, TooltipPopupComponent_ng_template_0_2_ng_template_0_Template, 0, 0, "ng-template", 5);
} if (rf & 2) {
    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r5.seriesSharedTooltipTemplateRef)("ngTemplateOutletContext", ctx_r5.seriesSharedTooltipContext);
} }
function TooltipPopupComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 3);
    ɵngcc0.ɵɵtemplate(1, TooltipPopupComponent_ng_template_0_1_Template, 1, 2, undefined, 4);
    ɵngcc0.ɵɵtemplate(2, TooltipPopupComponent_ng_template_0_2_Template, 1, 2, undefined, 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r1.popupClasses)("ngStyle", ctx_r1.style);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", !ctx_r1.shared);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r1.shared);
} }
function TooltipPopupComponent_ng_template_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "span", 6);
} if (rf & 2) {
    const formattedValue_r8 = ctx.formattedValue;
    ɵngcc0.ɵɵproperty("innerHTML", formattedValue_r8, ɵngcc0.ɵɵsanitizeHtml);
} }
function TooltipPopupComponent_ng_template_3_tr_4_td_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td");
    ɵngcc0.ɵɵelement(1, "span", 8);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const point_r15 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵstyleProp("background-color", point_r15.series.color);
} }
function TooltipPopupComponent_ng_template_3_tr_4_td_2_ng_container_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementContainerEnd();
} if (rf & 2) {
    const point_r15 = ɵngcc0.ɵɵnextContext(2).$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(point_r15.series.name);
} }
function TooltipPopupComponent_ng_template_3_tr_4_td_2_ng_container_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementContainerStart(0);
    ɵngcc0.ɵɵtext(1, "\u00A0");
    ɵngcc0.ɵɵelementContainerEnd();
} }
function TooltipPopupComponent_ng_template_3_tr_4_td_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "td");
    ɵngcc0.ɵɵtemplate(1, TooltipPopupComponent_ng_template_3_tr_4_td_2_ng_container_1_Template, 2, 1, "ng-container", 4);
    ɵngcc0.ɵɵtemplate(2, TooltipPopupComponent_ng_template_3_tr_4_td_2_ng_container_2_Template, 2, 0, "ng-container", 4);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const point_r15 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", point_r15.series.name !== undefined);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", point_r15.series.name === undefined);
} }
function TooltipPopupComponent_ng_template_3_tr_4_ng_template_4_Template(rf, ctx) { }
function TooltipPopupComponent_ng_template_3_tr_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "tr");
    ɵngcc0.ɵɵtemplate(1, TooltipPopupComponent_ng_template_3_tr_4_td_1_Template, 2, 2, "td", 4);
    ɵngcc0.ɵɵtemplate(2, TooltipPopupComponent_ng_template_3_tr_4_td_2_Template, 3, 2, "td", 4);
    ɵngcc0.ɵɵelementStart(3, "td");
    ɵngcc0.ɵɵtemplate(4, TooltipPopupComponent_ng_template_3_tr_4_ng_template_4_Template, 0, 0, "ng-template", 5);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const point_r15 = ctx.$implicit;
    const ctx_r24 = ɵngcc0.ɵɵnextContext();
    const colorMarker_r12 = ctx_r24.colorMarker;
    const nameColumn_r13 = ctx_r24.nameColumn;
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", colorMarker_r12);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", nameColumn_r13);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", point_r15.template)("ngTemplateOutletContext", point_r15);
} }
function TooltipPopupComponent_ng_template_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "table");
    ɵngcc0.ɵɵelementStart(1, "tr");
    ɵngcc0.ɵɵelementStart(2, "th");
    ɵngcc0.ɵɵtext(3);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(4, TooltipPopupComponent_ng_template_3_tr_4_Template, 5, 4, "tr", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const points_r9 = ctx.points;
    const categoryText_r10 = ctx.categoryText;
    const colspan_r11 = ctx.colspan;
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵattribute("colspan", colspan_r11);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", categoryText_r10, " ");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngForOf", points_r9);
} }
function CrosshairTooltipComponent_ng_template_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngStyle", ctx_r1.style);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r1.value, " ");
} }
function CrosshairTooltipsContainerComponent_kendo_chart_crosshair_tooltip_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "kendo-chart-crosshair-tooltip", 1);
} if (rf & 2) {
    const key_r1 = ctx.$implicit;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("key", key_r1)("popupSettings", ctx_r0.popupSettings);
} }
const _c1 = ["surface"];
function ChartComponent_div_5_ng_template_1_Template(rf, ctx) { }
function ChartComponent_div_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 6);
    ɵngcc0.ɵɵtemplate(1, ChartComponent_div_5_ng_template_1_Template, 0, 0, "ng-template", 7);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r1 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngStyle", ctx_r1.donutCenterStyle);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngTemplateOutlet", ctx_r1.donutCenterTemplate.templateRef);
} }
export { ResizeSensorComponent } from '@progress/kendo-angular-common';
import { PopupService, POPUP_CONTAINER, PopupModule } from '@progress/kendo-angular-popup';
export { PopupComponent } from '@progress/kendo-angular-popup';
import { LocalizationService, L10N_PREFIX } from '@progress/kendo-angular-l10n';
import { IntlService } from '@progress/kendo-angular-intl';
import { exportImage, exportSVG } from '@progress/kendo-drawing';
import { CommonModule } from '@angular/common';

/**
 * @hidden
 */
const packageMetadata = {
    name: '@progress/kendo-angular-charts',
    productName: 'Kendo UI for Angular',
    productCodes: ['KENDOUIANGULAR', 'KENDOUICOMPLETE'],
    publishDate: 1638166273,
    version: '',
    licensingDocsUrl: 'https://www.telerik.com/kendo-angular-ui/my-license/?utm_medium=product&utm_source=kendoangular&utm_campaign=kendo-ui-angular-purchase-license-keys-warning'
};

/**
 * @hidden
 */
class ChartComponentGenerated {
    constructor(configurationService) {
        this.configurationService = configurationService;
        /**
         * Fires when the user clicks an axis label ([see example]({% slug overview_chart_charts %}#toc-events)).
         */
        this.axisLabelClick = new EventEmitter();
        /**
         * Fires as long as the user is dragging the Chart with the mouse or through swipe gestures.
         */
        this.drag = new EventEmitter();
        /**
         * Fires when the user stops dragging the Chart.
         */
        this.dragEnd = new EventEmitter();
        /**
         * Fires when the user starts dragging the Chart.
         */
        this.dragStart = new EventEmitter();
        /**
         * Fires when the user hovers over a legend item ([see example]({% slug overview_chart_charts %}#toc-events)).
         */
        this.legendItemHover = new EventEmitter();
        /**
         * Fires when the cursor leaves a legend item.
         */
        this.legendItemLeave = new EventEmitter();
        /**
         * Fires when the user clicks a note.
         */
        this.noteClick = new EventEmitter();
        /**
         * Fires when the user hovers over a note.
         */
        this.noteHover = new EventEmitter();
        /**
         * Fires when the cursor leaves a note.
         */
        this.noteLeave = new EventEmitter();
        /**
         * Fires when a pane is rendered because the Chart:
         * * Is rendered.
         * * Performs panning or zooming.
         * * Is exported with different options.
         * The event is used to render custom visuals in the panes.
         */
        this.paneRender = new EventEmitter();
        /**
         * Fires when the user clicks the plot area ([see example]({% slug overview_chart_charts %}#toc-events)).
         * The `click` event is triggered by the `tap` and `contextmenu` events.
         * To distinguish between the original events, inspect the `e.originalEvent.type` field.
         */
        this.plotAreaClick = new EventEmitter();
        /**
         * Fires when the user hovers the plot area ([see example]({% slug overview_chart_charts %}#toc-events)).
         */
        this.plotAreaHover = new EventEmitter();
        /**
         * Fires when the cursor leaves the plot area.
         */
        this.plotAreaLeave = new EventEmitter();
        /**
         * Fires when the Chart is ready to render on screen ([see example]({% slug overview_chart_charts %}#toc-events)).
         * For example, you can use it to remove loading indicators.
         * Any changes made to the options are ignored.
         */
        this.render = new EventEmitter();
        /**
         * Fires when the user modifies the selection.
         *
         * The range units are:
         * - Generic axis&mdash;Category index (0-based).
         * - Date axis&mdash;Date instance.
         */
        this.select = new EventEmitter();
        /**
         * Fires when the user completes the modification of the selection.
         *
         * The range units are:
         * - Generic axis&mdash;Category index (0-based).
         * - Date axis&mdash;Date instance.
         */
        this.selectEnd = new EventEmitter();
        /**
         * Fires when the user starts modifying the axis selection.
         *
         * The range units are:
         * - Generic axis&mdash;Category index (0-based).
         * - Date axis&mdash;Date instance.
         */
        this.selectStart = new EventEmitter();
        /**
         * Fires when the user clicks the Chart series.
         *
         * The `click` event will be triggered by the `tap` and `contextmenu` events ([see example]({% slug overview_chart_charts %}#toc-events)).
         * To distinguish between the original events, inspect the `e.originalEvent.type` field.
         */
        this.seriesClick = new EventEmitter();
        /**
         * Fires when the user hovers the Chart series ([see example]({% slug overview_chart_charts %}#toc-events)).
         */
        this.seriesHover = new EventEmitter();
        /**
         * Fires when the cursor enters a series.
         */
        this.seriesOver = new EventEmitter();
        /**
         * Fires when the cursor leaves a series.
         */
        this.seriesLeave = new EventEmitter();
        /**
         * Fires as long as the user is zooming the Chart by using the mousewheel operation.
         */
        this.zoom = new EventEmitter();
        /**
         * Fires when the user stops zooming the Chart.
         */
        this.zoomEnd = new EventEmitter();
        /**
         * Fires when the user uses the mousewheel to zoom the Chart.
         */
        this.zoomStart = new EventEmitter();
    }
}
ChartComponentGenerated.ɵfac = function ChartComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
ChartComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ChartComponentGenerated, inputs: { pannable: "pannable", renderAs: "renderAs", seriesColors: "seriesColors", title: "title", transitions: "transitions", zoomable: "zoomable", axisDefaults: "axisDefaults", categoryAxis: "categoryAxis", chartArea: "chartArea", legend: "legend", panes: "panes", paneDefaults: "paneDefaults", plotArea: "plotArea", series: "series", seriesDefaults: "seriesDefaults", tooltip: "tooltip", valueAxis: "valueAxis", xAxis: "xAxis", yAxis: "yAxis" }, outputs: { axisLabelClick: "axisLabelClick", drag: "drag", dragEnd: "dragEnd", dragStart: "dragStart", legendItemHover: "legendItemHover", legendItemLeave: "legendItemLeave", noteClick: "noteClick", noteHover: "noteHover", noteLeave: "noteLeave", paneRender: "paneRender", plotAreaClick: "plotAreaClick", plotAreaHover: "plotAreaHover", plotAreaLeave: "plotAreaLeave", render: "render", select: "select", selectEnd: "selectEnd", selectStart: "selectStart", seriesClick: "seriesClick", seriesHover: "seriesHover", seriesOver: "seriesOver", seriesLeave: "seriesLeave", zoom: "zoom", zoomEnd: "zoomEnd", zoomStart: "zoomStart" } });
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartComponentGenerated.prototype, "pannable", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ChartComponentGenerated.prototype, "renderAs", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], ChartComponentGenerated.prototype, "seriesColors", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartComponentGenerated.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ChartComponentGenerated.prototype, "transitions", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartComponentGenerated.prototype, "zoomable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartComponentGenerated.prototype, "axisDefaults", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartComponentGenerated.prototype, "categoryAxis", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartComponentGenerated.prototype, "chartArea", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartComponentGenerated.prototype, "legend", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], ChartComponentGenerated.prototype, "panes", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartComponentGenerated.prototype, "paneDefaults", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartComponentGenerated.prototype, "plotArea", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], ChartComponentGenerated.prototype, "series", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartComponentGenerated.prototype, "seriesDefaults", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartComponentGenerated.prototype, "tooltip", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartComponentGenerated.prototype, "valueAxis", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartComponentGenerated.prototype, "xAxis", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartComponentGenerated.prototype, "yAxis", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "axisLabelClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "drag", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "dragEnd", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "dragStart", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "legendItemHover", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "legendItemLeave", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "noteClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "noteHover", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "noteLeave", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "paneRender", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "plotAreaClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "plotAreaHover", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "plotAreaLeave", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "render", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "select", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "selectEnd", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "selectStart", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "seriesClick", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "seriesHover", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "seriesOver", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "seriesLeave", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "zoom", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "zoomEnd", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponentGenerated.prototype, "zoomStart", void 0);

/**
 * @hidden
 */
const THROTTLE_MS = 1000 / 60;
/**
 * @hidden
 */
class Change {
    constructor(key, value) {
        this.key = key;
        this.value = value;
    }
}
/**
 * @hidden
 */
let ConfigurationService = class ConfigurationService {
    constructor(ngZone) {
        this.ngZone = ngZone;
        this.store = {};
        this.source = new BehaviorSubject({});
        this.initSource();
    }
    initSource() {
        this.onFastChange$ = this.source.asObservable();
        this.onChange$ = this.onFastChange$.pipe(auditTime(THROTTLE_MS));
    }
    push(store) {
        this.store = store;
        this.next();
    }
    notify(change) {
        this.set(change.key, change.value);
        this.next();
    }
    set(field, value) {
        let store = this.store;
        const parts = field.split('.');
        let key = parts.shift();
        while (parts.length > 0) {
            store = store[key] = store[key] || {};
            key = parts.shift();
        }
        store[key] = value;
    }
    next() {
        this.ngZone.runOutsideAngular(() => {
            this.source.next(this.store);
        });
    }
};
ConfigurationService.ɵfac = function ConfigurationService_Factory(t) { return new (t || ConfigurationService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
ConfigurationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ConfigurationService, factory: function (t) { return ConfigurationService.ɵfac(t); } });
ConfigurationService = __decorate([ __metadata("design:paramtypes", [NgZone])
], ConfigurationService);

/**
 * @hidden
 */
class BaseEvent {
    /**
     * @hidden
     */
    constructor(sender) {
        this.sender = sender;
    }
}

/**
 * @hidden
 */
class PreventableEvent extends BaseEvent {
    constructor() {
        super(...arguments);
        this.prevented = false;
    }
    /**
     * Prevents the default action for a specified event.
     * In this way, the source component suppresses
     * the built-in behavior that follows the event.
     */
    preventDefault() {
        this.prevented = true;
    }
    /**
     * Returns `true` if the event was prevented
     * by any of its subscribers.
     *
     * @returns `true` if the default action was prevented.
     * Otherwise, returns `false`.
     */
    isDefaultPrevented() {
        return this.prevented;
    }
}

/**
 * @hidden
 */
class LegendEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.series = e.series;
        this.seriesIndex = e.seriesIndex;
        this.pointIndex = e.pointIndex;
        this.text = e.text;
    }
}

/**
 * Arguments for the `legendItemClick` event.
 */
class LegendItemClickEvent extends LegendEvent {
    /**
     * If called, the series visibility is not toggled as a result of clicking the legend item.
     */
    preventDefault() {
        super.preventDefault();
    }
}

/**
 * Arguments for the `axisLabelClick` event.
 */
class AxisLabelClickEvent extends BaseEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.axis = e.axis;
        this.dataItem = e.dataItem;
        this.index = e.index;
        this.text = e.text;
        this.value = e.value;
    }
}

/**
 * Arguments for the `drag` event.
 */
class DragEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.axisRanges = e.axisRanges;
        this.originalEvent = e.originalEvent;
    }
}

/**
 * Arguments for the `dragEnd` event.
 */
class DragEndEvent extends BaseEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.axisRanges = e.axisRanges;
        this.originalEvent = e.originalEvent;
    }
}

/**
 * Arguments for the `dragStart` event.
 */
class DragStartEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.axisRanges = e.axisRanges;
        this.originalEvent = e.originalEvent;
    }
}

/**
 * Arguments for the `legendItemHover` event.
 */
class LegendItemHoverEvent extends LegendEvent {
    /**
     * If called, the series highlight is not shown as a result of hovering over the legend item.
     */
    preventDefault() {
        super.preventDefault();
    }
}

/* tslint:disable:no-empty */
/**
 * Arguments for the `legendItemLeave` event.
 */
class LegendItemLeaveEvent extends LegendEvent {
    /**
     * @hidden
     */
    preventDefault() {
    }
    /**
     * @hidden
     */
    isDefaultPrevented() {
        return false;
    }
}

/**
 * @hidden
 */
class NoteEvent extends BaseEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.category = e.category;
        this.dataItem = e.dataItem;
        this.series = e.series;
        this.value = e.value;
        this.visual = e.visual;
    }
}

/**
 * Arguments for the `noteClick` event.
 */
class NoteClickEvent extends NoteEvent {
}

/**
 * Arguments for the `noteHover` event.
 */
class NoteHoverEvent extends NoteEvent {
}

/**
 * Arguments for the `noteLeave` event.
 */
class NoteLeaveEvent extends NoteEvent {
}

/**
 * Arguments for the `paneRender` event.
 */
class PaneRenderEvent extends BaseEvent {
    /**
     * @hidden
     */
    constructor(args, sender) {
        super(sender);
        Object.assign(this, args);
    }
}

/**
 * Arguments for the `plotAreaClick` event.
 */
class PlotAreaClickEvent extends BaseEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.category = e.category;
        this.originalEvent = e.originalEvent;
        this.value = e.value;
        this.x = e.x;
        this.y = e.y;
    }
}

/**
 * Arguments for the `plotAreaHover` event.
 */
class PlotAreaHoverEvent extends BaseEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.category = e.category;
        this.originalEvent = e.originalEvent;
        this.value = e.value;
        this.x = e.x;
        this.y = e.y;
    }
}

class PlotAreaLeaveEvent extends BaseEvent {
}

/**
 * Arguments for the `render` event.
 */
class RenderEvent extends BaseEvent {
    /**
     * @hidden
     */
    constructor(_e, sender) {
        super(sender);
    }
}

/**
 * Arguments for the `select` event.
 */
class SelectEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.axis = e.axis;
        this.from = e.from;
        this.to = e.to;
    }
}

/**
 * Arguments for the `selectEnd` event.
 */
class SelectEndEvent extends BaseEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.axis = e.axis;
        this.from = e.from;
        this.to = e.to;
    }
}

/**
 * Arguments for the `selectStart` event.
 */
class SelectStartEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.axis = e.axis;
        this.from = e.from;
        this.to = e.to;
    }
}

/**
 * Arguments for the `seriesClick` event.
 */
class SeriesClickEvent extends BaseEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.category = e.category;
        this.dataItem = e.dataItem;
        this.originalEvent = e.originalEvent;
        this.percentage = e.percentage;
        this.point = e.point;
        this.series = e.series;
        this.stackValue = e.stackValue;
        this.value = e.value;
    }
}

/**
 * @hidden
 */
class SeriesEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.category = e.category;
        this.dataItem = e.dataItem;
        this.originalEvent = e.originalEvent;
        this.percentage = e.percentage;
        this.point = e.point;
        this.series = e.series;
        this.stackValue = e.stackValue;
        this.value = e.value;
    }
}

/**
 * Arguments for the `seriesHover` event.
 */
class SeriesHoverEvent extends SeriesEvent {
}

/**
 * Arguments for the `seriesOver` event.
 */
class SeriesOverEvent extends SeriesEvent {
}

/**
 * Arguments for the `seriesLeave` event.
 */
class SeriesLeaveEvent extends SeriesEvent {
}

/**
 * Arguments for the `zoom` event.
 */
class ZoomEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.axisRanges = e.axisRanges;
        this.delta = e.delta;
        this.originalEvent = e.originalEvent;
    }
}

/**
 * Arguments for the `zoomEnd` event.
 */
class ZoomEndEvent extends BaseEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.axisRanges = e.axisRanges;
        this.originalEvent = e.originalEvent;
    }
}

/**
 * Arguments for the `zoomStart` event.
 */
class ZoomStartEvent extends PreventableEvent {
    /**
     * @hidden
     */
    constructor(e, sender) {
        super(sender);
        this.axisRanges = e.axisRanges;
        this.originalEvent = e.originalEvent;
    }
}

const EVENT_MAP = {
    axisLabelClick: AxisLabelClickEvent,
    drag: DragEvent,
    dragEnd: DragEndEvent,
    dragStart: DragStartEvent,
    legendItemHover: LegendItemHoverEvent,
    legendItemLeave: LegendItemLeaveEvent,
    noteClick: NoteClickEvent,
    noteHover: NoteHoverEvent,
    noteLeave: NoteLeaveEvent,
    paneRender: PaneRenderEvent,
    plotAreaClick: PlotAreaClickEvent,
    plotAreaHover: PlotAreaHoverEvent,
    plotAreaLeave: PlotAreaLeaveEvent,
    render: RenderEvent,
    select: SelectEvent,
    selectEnd: SelectEndEvent,
    selectStart: SelectStartEvent,
    seriesClick: SeriesClickEvent,
    seriesHover: SeriesHoverEvent,
    seriesOver: SeriesOverEvent,
    seriesLeave: SeriesLeaveEvent,
    zoom: ZoomEvent,
    zoomEnd: ZoomEndEvent,
    zoomStart: ZoomStartEvent
};
/**
 * @hidden
 */
class InstanceEventService {
    create(name, args, sender) {
        if (EVENT_MAP[name]) {
            return new EVENT_MAP[name](args, sender);
        }
    }
}
InstanceEventService.ɵfac = function InstanceEventService_Factory(t) { return new (t || InstanceEventService)(); };
InstanceEventService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: InstanceEventService, factory: InstanceEventService.ɵfac });

/**
 * A directive which selects a [template]({{ site.data.urls.angular['templatesyntax'] }})
 * within the `<kendo-chart>` component for the
 * [Donut center template]({% slug donut_seriestypes_charts %}).
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-chart style="height: 450px;">
 *       <ng-template kendoChartDonutCenterTemplate>
 *         <h3>22.5%</h3>
 *         of which renewables
 *       </ng-template>
 *       <kendo-chart-series>
 *         <kendo-chart-series-item
 *             type="donut" [data]="data"
 *             categoryField="kind" field="share">
 *         </kendo-chart-series-item>
 *       </kendo-chart-series>
 *       <kendo-chart-legend [visible]="false"></kendo-chart-legend>
 *     </kendo-chart>
 *   `
 * })
 * export class AppComponent {
 *   public data: any[] = [{
 *     kind: 'Hydroelectric', share: 0.175
 *   }, {
 *     kind: 'Nuclear', share: 0.238
 *   }, {
 *     kind: 'Coal', share: 0.118
 *   }, {
 *     kind: 'Solar', share: 0.052
 *   }, {
 *     kind: 'Wind', share: 0.225
 *   }, {
 *     kind: 'Other', share: 0.192
 *   }];
 * }
 *
 * ```
 */
let DonutCenterTemplateDirective = class DonutCenterTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
DonutCenterTemplateDirective.ɵfac = function DonutCenterTemplateDirective_Factory(t) { return new (t || DonutCenterTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
DonutCenterTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: DonutCenterTemplateDirective, selectors: [["", "kendoChartDonutCenterTemplate", ""]] });
DonutCenterTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], DonutCenterTemplateDirective);

/**
 * @hidden
 */
class ItemChange {
    constructor(sender, options) {
        this.sender = sender;
        this.options = options;
    }
}
/**
 * @hidden
 */
let CollectionService = class CollectionService {
    constructor() {
        this.source = new Subject();
        this.onItemChange$ = this.source.asObservable();
    }
    notify(change) {
        this.source.next(change);
    }
};
CollectionService.ɵfac = function CollectionService_Factory(t) { return new (t || CollectionService)(); };
CollectionService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: CollectionService, factory: function (t) { return CollectionService.ɵfac(t); } });
CollectionService = __decorate([ __metadata("design:paramtypes", [])
], CollectionService);

/**
 * @hidden
 */
function copyChanges(changes, options) {
    for (const propertyName in changes) {
        if (!changes.hasOwnProperty(propertyName)) {
            continue;
        }
        const value = changes[propertyName].currentValue;
        if (value === undefined) {
            delete options[propertyName];
        }
        else {
            options[propertyName] = value;
        }
    }
}

/**
 * @hidden
 */
function toSimpleChanges(changes) {
    const result = {};
    for (const propertyName in changes) {
        if (!changes.hasOwnProperty(propertyName)) {
            continue;
        }
        result[propertyName] = new SimpleChange(null, changes[propertyName], false);
    }
    return result;
}

/**
 * @hidden
 */
class CollectionItemComponent {
    constructor(configurationService, collectionService) {
        this.configurationService = configurationService;
        this.collectionService = collectionService;
        this.options = {};
        this.subscription = configurationService.onFastChange$.subscribe(store => {
            this.options = store;
            this.notify();
        });
    }
    ngOnChanges(changes) {
        const store = this.configurationService.store;
        copyChanges(changes, store);
        this.configurationService.push(store);
    }
    /**
     * Updates the component fields with the specified values and refreshes the Chart.
     *
     * Use this method when the configuration values cannot be set through the template.
     *
     * @example
     * ```ts-no-run
     * item.notifyChanges({ visible: true });
     * ```
     *
     * @param changes An object containing the updated input fields.
     */
    notifyChanges(changes) {
        this.ngOnChanges(toSimpleChanges(changes));
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    notify() {
        if (!this.collectionService) {
            return;
        }
        this.collectionService.notify(new ItemChange(this, this.options));
    }
}
CollectionItemComponent.ɵfac = function CollectionItemComponent_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
CollectionItemComponent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CollectionItemComponent, features: [ɵngcc0.ɵɵNgOnChangesFeature] });

/**
 * @hidden
 */
class SeriesItemComponentGenerated extends CollectionItemComponent {
    constructor(configurationService, collectionService) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
}
SeriesItemComponentGenerated.ɵfac = function SeriesItemComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SeriesItemComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SeriesItemComponentGenerated, inputs: { aggregate: "aggregate", autoFit: "autoFit", axis: "axis", border: "border", categoryAxis: "categoryAxis", categoryField: "categoryField", closeField: "closeField", color: "color", colorField: "colorField", connectors: "connectors", currentField: "currentField", dashType: "dashType", data: "data", downColor: "downColor", downColorField: "downColorField", dynamicHeight: "dynamicHeight", dynamicSlope: "dynamicSlope", errorHighField: "errorHighField", errorLowField: "errorLowField", explodeField: "explodeField", field: "field", fromField: "fromField", gap: "gap", highField: "highField", holeSize: "holeSize", line: "line", lowField: "lowField", lowerField: "lowerField", margin: "margin", maxSize: "maxSize", mean: "mean", meanField: "meanField", median: "median", medianField: "medianField", minSize: "minSize", missingValues: "missingValues", name: "name", neckRatio: "neckRatio", negativeColor: "negativeColor", negativeValues: "negativeValues", noteTextField: "noteTextField", opacity: "opacity", openField: "openField", outliersField: "outliersField", overlay: "overlay", padding: "padding", q1Field: "q1Field", q3Field: "q3Field", segmentSpacing: "segmentSpacing", size: "size", sizeField: "sizeField", spacing: "spacing", stack: "stack", startAngle: "startAngle", style: "style", summaryField: "summaryField", target: "target", toField: "toField", type: "type", upperField: "upperField", visible: "visible", visibleInLegend: "visibleInLegend", visibleInLegendField: "visibleInLegendField", visual: "visual", width: "width", whiskers: "whiskers", xAxis: "xAxis", xErrorHighField: "xErrorHighField", xErrorLowField: "xErrorLowField", xField: "xField", yAxis: "yAxis", yErrorHighField: "yErrorHighField", yErrorLowField: "yErrorLowField", yField: "yField", zIndex: "zIndex", errorBars: "errorBars", extremes: "extremes", highlight: "highlight", labels: "labels", markers: "markers", notes: "notes", outliers: "outliers", tooltip: "tooltip" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesItemComponentGenerated.prototype, "aggregate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SeriesItemComponentGenerated.prototype, "autoFit", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "axis", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesItemComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "categoryAxis", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "categoryField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "closeField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesItemComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "colorField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesItemComponentGenerated.prototype, "connectors", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "currentField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "dashType", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], SeriesItemComponentGenerated.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "downColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "downColorField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SeriesItemComponentGenerated.prototype, "dynamicHeight", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SeriesItemComponentGenerated.prototype, "dynamicSlope", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "errorHighField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "errorLowField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "explodeField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "field", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "fromField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesItemComponentGenerated.prototype, "gap", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "highField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesItemComponentGenerated.prototype, "holeSize", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesItemComponentGenerated.prototype, "line", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "lowField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "lowerField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesItemComponentGenerated.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesItemComponentGenerated.prototype, "maxSize", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesItemComponentGenerated.prototype, "mean", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "meanField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesItemComponentGenerated.prototype, "median", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "medianField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesItemComponentGenerated.prototype, "minSize", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "missingValues", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "name", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesItemComponentGenerated.prototype, "neckRatio", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "negativeColor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesItemComponentGenerated.prototype, "negativeValues", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "noteTextField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesItemComponentGenerated.prototype, "opacity", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "openField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "outliersField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesItemComponentGenerated.prototype, "overlay", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesItemComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "q1Field", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "q3Field", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesItemComponentGenerated.prototype, "segmentSpacing", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesItemComponentGenerated.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "sizeField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesItemComponentGenerated.prototype, "spacing", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesItemComponentGenerated.prototype, "stack", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesItemComponentGenerated.prototype, "startAngle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "style", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "summaryField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesItemComponentGenerated.prototype, "target", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "toField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "upperField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SeriesItemComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SeriesItemComponentGenerated.prototype, "visibleInLegend", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "visibleInLegendField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], SeriesItemComponentGenerated.prototype, "visual", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesItemComponentGenerated.prototype, "width", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesItemComponentGenerated.prototype, "whiskers", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "xAxis", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "xErrorHighField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "xErrorLowField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "xField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "yAxis", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "yErrorHighField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "yErrorLowField", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesItemComponentGenerated.prototype, "yField", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesItemComponentGenerated.prototype, "zIndex", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesItemComponentGenerated.prototype, "errorBars", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesItemComponentGenerated.prototype, "extremes", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesItemComponentGenerated.prototype, "highlight", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesItemComponentGenerated.prototype, "labels", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesItemComponentGenerated.prototype, "markers", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesItemComponentGenerated.prototype, "notes", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesItemComponentGenerated.prototype, "outliers", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesItemComponentGenerated.prototype, "tooltip", void 0);

/**
 * @hidden
 */
class SettingsComponent {
    constructor(configKey, configurationService) {
        this.configKey = configKey;
        this.configurationService = configurationService;
        this.store = {};
        if (configKey === undefined) {
            throw new Error('Configuration key not set');
        }
    }
    ngOnDestroy() {
        this.store = undefined;
        this.notify();
    }
    ngOnChanges(changes) {
        copyChanges(changes, this.store);
        this.notify();
    }
    /**
     * Updates the component fields with the specified values and refreshes the Chart.
     *
     * Use this method when the configuration values cannot be set through the template.
     *
     * @example
     * ```ts-no-run
     * item.notifyChanges({ visible: true });
     * ```
     *
     * @param changes An object containing the updated input fields.
     */
    notifyChanges(changes) {
        this.ngOnChanges(toSimpleChanges(changes));
    }
    markAsVisible() {
        this.store.visible = true;
        this.notify();
    }
    notify() {
        this.configurationService.notify(new Change(this.configKey, this.store));
    }
}
SettingsComponent.ɵfac = function SettingsComponent_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SettingsComponent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SettingsComponent, features: [ɵngcc0.ɵɵNgOnChangesFeature] });

/**
 * @hidden
 */
class SeriesTooltipComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('tooltip', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesTooltipComponentGenerated.ɵfac = function SeriesTooltipComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SeriesTooltipComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SeriesTooltipComponentGenerated, inputs: { background: "background", border: "border", color: "color", font: "font", format: "format", padding: "padding", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesTooltipComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesTooltipComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesTooltipComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesTooltipComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesTooltipComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesTooltipComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SeriesTooltipComponentGenerated.prototype, "visible", void 0);

/**
 * The configuration options of the Chart series tooltip
 * ([see example]({% slug tooltips_chart_charts %})).
 */
let SeriesTooltipComponent = class SeriesTooltipComponent extends SeriesTooltipComponentGenerated {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
    get seriesTooltipTemplateRef() {
        return this.seriesTooltipTemplate;
    }
};
SeriesTooltipComponent.ɵfac = function SeriesTooltipComponent_Factory(t) { return new (t || SeriesTooltipComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
SeriesTooltipComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesTooltipComponent, selectors: [["kendo-chart-series-item-tooltip"]], contentQueries: function SeriesTooltipComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, TemplateRef, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SeriesTooltipComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
__decorate([
    ContentChild(TemplateRef, { static: false }),
    __metadata("design:type", TemplateRef)
], SeriesTooltipComponent.prototype, "seriesTooltipTemplate", void 0);
SeriesTooltipComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], SeriesTooltipComponent);

const toggle = (flag) => flag === undefined ? false : !flag;
/**
 * The configuration component for a series item.
 */
let SeriesItemComponent = class SeriesItemComponent extends SeriesItemComponentGenerated {
    constructor(configurationService, collectionService) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
    /**
     * Toggles the series visibility and updates the parent Chart
     * without animated transitions.
     */
    toggleVisibility() {
        this.options.visible = toggle(this.options.visible);
        this.notify();
    }
    /**
     * Toggles the visibility of a point with the given index.
     * Applicable for the Pie, Donut, and Funnel series.
     *
     * @param pointIndex - The zero-based index of the point to toggle.
     */
    togglePointVisibility(pointIndex) {
        const pv = this.options.pointVisibility = this.options.pointVisibility || {};
        pv[pointIndex] = toggle(pv[pointIndex]);
        this.notify();
    }
    get seriesTooltipTemplateRef() {
        if (this.seriesTooltip) {
            return this.seriesTooltip.seriesTooltipTemplateRef;
        }
    }
};
SeriesItemComponent.ɵfac = function SeriesItemComponent_Factory(t) { return new (t || SeriesItemComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionService)); };
SeriesItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesItemComponent, selectors: [["kendo-chart-series-item"]], contentQueries: function SeriesItemComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, SeriesTooltipComponent, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.seriesTooltip = _t.first);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([ConfigurationService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SeriesItemComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
__decorate([
    ContentChild(SeriesTooltipComponent, { static: false }),
    __metadata("design:type", SeriesTooltipComponent)
], SeriesItemComponent.prototype, "seriesTooltip", void 0);
SeriesItemComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        CollectionService])
], SeriesItemComponent);

/**
 * Fallback theme in case the Theme Service fails
 * to read the variables from the main theme.
 *
 * @hidden
 */
const chartDefaultTheme = () => Object.assign({}, chartBaseTheme(), {
    axisDefaults: {
        crosshair: {
            color: 'rgba(0, 0, 0, 0.5)'
        },
        labels: {
            color: 'rgb(101, 101, 101)',
            font: '12px serif'
        },
        line: {
            color: 'rgba(0, 0, 0, 0.08)'
        },
        majorGridLines: {
            color: 'rgba(0, 0, 0, 0.08)'
        },
        minorGridLines: {
            color: 'rgba(0, 0, 0, 0.04)'
        },
        notes: {
            icon: {
                background: 'rgba(0, 0, 0, 0.5)',
                border: {
                    color: 'rgba(0, 0, 0, 0.5)'
                }
            },
            line: {
                color: 'rgba(0, 0, 0, 0.5)'
            },
            label: {
                font: '14px serif'
            }
        },
        title: {
            color: 'rgb(101, 101, 101)',
            font: '14px serif'
        }
    },
    chartArea: {
        background: 'rgb(255, 255, 255)'
    },
    legend: {
        inactiveItems: {
            labels: {
                color: 'rgba(102, 102, 102, 0.5)'
            },
            markers: {
                color: 'rgba(102, 102, 102, 0.5)'
            }
        },
        labels: {
            color: 'rgb(101, 101, 101)',
            font: '14px serif'
        }
    },
    seriesDefaults: {
        boxPlot: {
            downColor: 'rgba(0, 0, 0, 0.08)',
            mean: {
                color: 'rgb(246, 246, 246)'
            },
            median: {
                color: 'rgb(246, 246, 246)'
            },
            whiskers: {
                color: 'rgb(255, 99, 88)'
            }
        },
        bullet: {
            target: {
                color: 'rgb(101, 101, 101)'
            }
        },
        candlestick: {
            downColor: 'rgb(101, 101, 101)',
            line: {
                color: 'rgb(101, 101, 101)'
            }
        },
        errorBars: {
            color: 'rgba(0, 0, 0, 0.5)'
        },
        horizontalWaterfall: {
            line: {
                color: 'rgba(0, 0, 0, 0.08)'
            }
        },
        icon: {
            border: {
                color: 'rgba(0, 0, 0, 0.08)'
            }
        },
        labels: {
            background: 'rgb(255, 255, 255)',
            color: 'rgb(101, 101, 101)',
            opacity: 0.8,
            font: '12px serif'
        },
        notes: {
            icon: {
                background: 'rgba(0, 0, 0, 0.5)',
                border: {
                    color: 'rgba(0, 0, 0, 0.5)'
                }
            },
            line: {
                color: 'rgba(0, 0, 0, 0.5)'
            },
            label: {
                font: '14px serif'
            }
        },
        overlay: {
            gradient: "none"
        },
        verticalBoxPlot: {
            downColor: 'rgba(0, 0, 0, 0.08)',
            mean: {
                color: 'rgb(246, 246, 246)'
            },
            median: {
                color: 'rgb(246, 246, 246)'
            },
            whiskers: {
                color: 'rgb(255, 99, 88)'
            }
        },
        verticalBullet: {
            target: {
                color: 'rgb(101, 101, 101)'
            }
        },
        waterfall: {
            line: {
                color: 'rgba(0, 0, 0, 0.08)'
            }
        },
        area: {
            opacity: 0.8
        }
    },
    title: {
        color: 'rgb(101, 101, 101)',
        font: '16px serif'
    },
    seriesColors: [
        'rgb(255, 99, 88)',
        'rgb(255, 210, 70)',
        'rgb(120, 210, 55)',
        'rgb(40, 180, 200)',
        'rgb(45, 115, 245)',
        'rgb(170, 70, 190)'
    ]
});

const font = (style) => `${style.fontWeight} ${style.fontSize} ${style.fontFamily}`;
const computedBackgroundColor = (element) => window.getComputedStyle(element).backgroundColor;
const letterPos = (letter) => letter.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);
const seriesPos = (name) => {
    const alpha = name.match(/series-([a-z])$/);
    if (alpha !== null) {
        return letterPos(alpha[1]);
    }
    const num = name.split('--series-')[1];
    return parseInt(num, 10) - 1;
};
const SERIES_COLORS = 30;
const seriesTemplate = () => {
    let template = `
      <div class="k-var--series-a"></div>
      <div class="k-var--series-b"></div>
      <div class="k-var--series-c"></div>
      <div class="k-var--series-d"></div>
      <div class="k-var--series-e"></div>
      <div class="k-var--series-f"></div>
  `;
    for (let i = 0; i < SERIES_COLORS; i++) {
        template += `
      <div class="k-var--series-${i + 1}"></div>`;
    }
    return template;
};
const template = () => `
    <div class="k-var--accent"></div>
    <div class="k-var--accent-contrast"></div>
    <div class="k-var--base"></div>
    <div class="k-var--background"></div>

    <div class="k-var--normal-background"></div>
    <div class="k-var--normal-text-color"></div>
    <div class="k-var--hover-background"></div>
    <div class="k-var--hover-text-color"></div>
    <div class="k-var--selected-background"></div>
    <div class="k-var--selected-text-color"></div>
    <div class="k-var--chart-error-bars-background"></div>
    <div class="k-var--chart-notes-background"></div>
    <div class="k-var--chart-notes-border"></div>
    <div class="k-var--chart-notes-lines"></div>
    <div class="k-var--chart-crosshair-background"></div>

    <div class="k-var--chart-inactive"></div>
    <div class="k-var--chart-major-lines"></div>
    <div class="k-var--chart-minor-lines"></div>
    <div class="k-var--chart-area-opacity"></div>
    <div class="k-var--chart-area-inactive-opacity"></div>
    <div class="k-var--chart-line-inactive-opacity"></div>

    <div class="k-widget k-chart">
        <div class="k-var--chart-font"></div>
        <div class="k-var--chart-title-font"></div>
        <div class="k-var--chart-pane-title-font"></div>
        <div class="k-var--chart-label-font"></div>
    </div>

    <div class="k-var--series-unset"></div>
    <div class="k-var--series">
      ${seriesTemplate()}
    </div>
`;
/**
 * @hidden
 */
let ThemeService = class ThemeService extends ConfigurationService {
    constructor(ngZone) {
        super(ngZone);
        this.loaded = false;
    }
    loadTheme() {
        if (this.loaded || !isDocumentAvailable()) {
            return;
        }
        if (!this.readTheme()) {
            this.readDefaultTheme();
        }
        this.loaded = true;
        this.next();
    }
    readTheme() {
        this.createElement();
        const available = this.queryColor('accent') !==
            this.queryColor('accent-contrast');
        try {
            if (available) {
                this.push(chartBaseTheme());
                this.setColors();
                this.setFonts();
                this.setSeriesColors();
            }
        }
        finally {
            this.destroyElement();
        }
        return available;
    }
    readDefaultTheme() {
        this.push(chartDefaultTheme());
    }
    createElement() {
        const container = this.element = document.createElement('div');
        container.style.display = 'none';
        container.innerHTML = template();
        document.body.appendChild(container);
    }
    destroyElement() {
        if (this.element) {
            document.body.removeChild(this.element);
            this.element = undefined;
        }
    }
    setStyle(key, value) {
        this.set(key, value);
    }
    setColors() {
        this.mapColor('axisDefaults.crosshair.color', 'chart-crosshair-background');
        this.mapColor('axisDefaults.labels.color', 'normal-text-color');
        this.mapColor('axisDefaults.line.color', 'chart-major-lines');
        this.mapColor('axisDefaults.majorGridLines.color', 'chart-major-lines');
        this.mapColor('axisDefaults.minorGridLines.color', 'chart-minor-lines');
        this.mapColor('axisDefaults.notes.icon.background', 'chart-notes-background');
        this.mapColor('axisDefaults.notes.icon.border.color', 'chart-notes-border');
        this.mapColor('axisDefaults.notes.line.color', 'chart-notes-lines');
        this.mapColor('axisDefaults.title.color', 'normal-text-color');
        this.mapColor('chartArea.background', 'background');
        this.mapColor('legend.inactiveItems.labels.color', 'chart-inactive');
        this.mapColor('legend.inactiveItems.markers.color', 'chart-inactive');
        this.mapColor('legend.labels.color', 'normal-text-color');
        this.mapColor('seriesDefaults.boxPlot.downColor', 'chart-major-lines');
        this.mapColor('seriesDefaults.boxPlot.mean.color', 'base');
        this.mapColor('seriesDefaults.boxPlot.median.color', 'base');
        this.mapColor('seriesDefaults.boxPlot.whiskers.color', 'accent');
        this.mapColor('seriesDefaults.bullet.target.color', 'normal-text-color');
        this.mapColor('seriesDefaults.candlestick.downColor', 'normal-text-color');
        this.mapColor('seriesDefaults.candlestick.line.color', 'normal-text-color');
        this.mapColor('seriesDefaults.errorBars.color', 'chart-error-bars-background');
        this.mapColor('seriesDefaults.horizontalWaterfall.line.color', 'chart-major-lines');
        this.mapColor('seriesDefaults.icon.border.color', 'chart-major-lines');
        this.mapColor('seriesDefaults.labels.background', 'background');
        this.mapColor('seriesDefaults.labels.color', 'normal-text-color');
        this.mapColor('seriesDefaults.notes.icon.background', 'chart-notes-background');
        this.mapColor('seriesDefaults.notes.icon.border.color', 'chart-notes-border');
        this.mapColor('seriesDefaults.notes.line.color', 'chart-notes-lines');
        this.mapColor('seriesDefaults.verticalBoxPlot.downColor', 'chart-major-lines');
        this.mapColor('seriesDefaults.verticalBoxPlot.mean.color', 'base');
        this.mapColor('seriesDefaults.verticalBoxPlot.median.color', 'base');
        this.mapColor('seriesDefaults.verticalBoxPlot.whiskers.color', 'accent');
        this.mapColor('seriesDefaults.verticalBullet.target.color', 'normal-text-color');
        this.mapColor('seriesDefaults.waterfall.line.color', 'chart-major-lines');
        this.mapColor('title.color', 'normal-text-color');
        const opacity = parseFloat(this.queryStyle('chart-area-opacity').opacity);
        if (!isNaN(opacity)) {
            this.setStyle('seriesDefaults.area.opacity', opacity);
            this.setStyle('seriesDefaults.radarArea.opacity', opacity);
            this.setStyle('seriesDefaults.verticalArea.opacity', opacity);
            this.setStyle('seriesDefaults.labels.opacity', opacity);
        }
        this.setInactiveOpacity(['area', 'verticalArea'], 'chart-area-inactive-opacity');
        this.setInactiveOpacity(['line', 'verticalLine'], 'chart-line-inactive-opacity');
    }
    setInactiveOpacity(seriesTypes, selector) {
        const inactiveOpacity = parseFloat(this.queryStyle(selector).opacity);
        if (!isNaN(inactiveOpacity) && inactiveOpacity < 1) {
            seriesTypes.forEach(type => this.setStyle(`seriesDefaults.${type}.highlight.inactiveOpacity`, inactiveOpacity));
        }
    }
    setFonts() {
        const defaultFont = font(this.queryStyle('chart-font'));
        const titleFont = font(this.queryStyle('chart-title-font'));
        const paneTitleFont = font(this.queryStyle('chart-pane-title-font'));
        const labelFont = font(this.queryStyle('chart-label-font'));
        this.setStyle('axisDefaults.labels.font', labelFont);
        this.setStyle('axisDefaults.notes.label.font', defaultFont);
        this.setStyle('axisDefaults.title.font', defaultFont);
        this.setStyle('legend.labels.font', defaultFont);
        this.setStyle('seriesDefaults.labels.font', labelFont);
        this.setStyle('seriesDefaults.notes.label.font', defaultFont);
        this.setStyle('title.font', titleFont);
        this.setStyle('paneDefaults.title.font', paneTitleFont);
    }
    setSeriesColors() {
        const element = this.element;
        const series = [].slice.call(element.querySelectorAll('.k-var--series div'));
        const unsetColor = computedBackgroundColor(element.querySelector('.k-var--series-unset'));
        const seriesColors = series.reduce((arr, el) => {
            const pos = seriesPos(el.className);
            const color = computedBackgroundColor(el);
            if (color !== unsetColor) {
                arr[pos] = color;
            }
            return arr;
        }, [] // Will populate the series colors in this array
        );
        this.setStyle('seriesColors', seriesColors);
    }
    mapColor(key, varName) {
        this.setStyle(key, this.queryColor(varName));
    }
    queryColor(varName) {
        return this.queryStyle(varName).backgroundColor;
    }
    queryStyle(varName) {
        const element = this.element.querySelector(`.k-var--${varName}`);
        return window.getComputedStyle(element);
    }
};
ThemeService.ɵfac = function ThemeService_Factory(t) { return new (t || ThemeService)(ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
ThemeService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: ThemeService, factory: function (t) { return ThemeService.ɵfac(t); } });
ThemeService = __decorate([ __metadata("design:paramtypes", [NgZone])
], ThemeService);

/**
 * @hidden
 */
class ChartInstanceObserver extends InstanceObserver {
    constructor(instance) {
        super(instance);
        this.handlerMap = {
            hideTooltip: 'onHideTooltip',
            legendItemClick: 'onLegendItemClick',
            render: 'onRender',
            showTooltip: 'onShowTooltip',
            init: 'onInit'
        };
    }
}

/**
 * @hidden
 */
let TooltipTemplateService = class TooltipTemplateService {
    setTemplate(template) {
        this.template = template;
    }
    getTemplate(seriesIndex) {
        if (this.seriesTemplates && this.seriesTemplates[seriesIndex]) {
            return this.seriesTemplates[seriesIndex];
        }
        return this.template;
    }
    setSeriesTemplates(seriesTemplates) {
        this.seriesTemplates = seriesTemplates;
    }
    setSharedTemplate(sharedTemplate) {
        this.sharedTemplate = sharedTemplate;
    }
    getSharedTemplate() {
        return this.sharedTemplate;
    }
};
TooltipTemplateService.ɵfac = function TooltipTemplateService_Factory(t) { return new (t || TooltipTemplateService)(); };
TooltipTemplateService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: TooltipTemplateService, factory: function (t) { return TooltipTemplateService.ɵfac(t); } });

/**
 * A directive that selects a [template]({{ site.data.urls.angular['templatesyntax'] }})
 * within the `<kendo-chart-tooltip>` component for the
 * [series tooltip]({% slug tooltips_chart_charts %}#toc-series-tooltip).
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-chart>
 *       <kendo-chart-tooltip>
 *          <ng-template kendoChartSeriesTooltipTemplate let-value="value">
 *             Value is {{value}}
 *           </ng-template>
 *       </kendo-chart-tooltip>
 *       <kendo-chart-series>
 *         <kendo-chart-series-item [data]="[1, 2, 3]">
 *         </kendo-chart-series-item>
 *       </kendo-chart-series>
 *     </kendo-chart>
 *   `
 * })
 * class AppComponent {
 * }
 *
 * ```
 */
let SeriesTooltipTemplateDirective = class SeriesTooltipTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
SeriesTooltipTemplateDirective.ɵfac = function SeriesTooltipTemplateDirective_Factory(t) { return new (t || SeriesTooltipTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
SeriesTooltipTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SeriesTooltipTemplateDirective, selectors: [["", "kendoChartSeriesTooltipTemplate", ""]] });
SeriesTooltipTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], SeriesTooltipTemplateDirective);

/**
 * A directive that selects a [template]({{ site.data.urls.angular['templatesyntax'] }})
 * within the `<kendo-chart-tooltip>` component for the
 * [shared series tooltip]({% slug tooltips_chart_charts %}#toc-shared-tooltip).
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-chart>
 *       <kendo-chart-tooltip [shared]="true">
 *         <ng-template kendoChartSharedTooltipTemplate let-category="category" let-points="points">
 *             <div> {{ category }} </div>
 *             <div *ngFor="let point of points">
 *                 {{ point.series.name }} : {{ point.value }}
 *             </div>
 *         </ng-template>
 *       </kendo-chart-tooltip>
 *       <kendo-chart-category-axis>
 *         <kendo-chart-category-axis-item [categories]="['A', 'B', 'C']">
 *         </kendo-chart-category-axis-item>
 *       </kendo-chart-category-axis>
 *       <kendo-chart-series>
 *         <kendo-chart-series-item name="A" [data]="[1, 2, 3]">
 *         </kendo-chart-series-item>
 *         <kendo-chart-series-item name="B" [data]="[1, 2, 3]">
 *         </kendo-chart-series-item>
 *       </kendo-chart-series>
 *     </kendo-chart>
 *   `
 * })
 * class AppComponent {
 * }
 *
 * ```
 */
let SharedTooltipTemplateDirective = class SharedTooltipTemplateDirective {
    constructor(templateRef) {
        this.templateRef = templateRef;
    }
};
SharedTooltipTemplateDirective.ɵfac = function SharedTooltipTemplateDirective_Factory(t) { return new (t || SharedTooltipTemplateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.TemplateRef, 8)); };
SharedTooltipTemplateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SharedTooltipTemplateDirective, selectors: [["", "kendoChartSharedTooltipTemplate", ""]] });
SharedTooltipTemplateDirective = __decorate([ __param(0, Optional()),
    __metadata("design:paramtypes", [TemplateRef])
], SharedTooltipTemplateDirective);

/**
 * The point that is passed to the tooltip template.
 */
class TooltipTemplatePoint {
    /**
     * @hidden
     */
    constructor(point, format, template) {
        this.value = point.value;
        this.category = point.category;
        this.categoryIndex = point.categoryIx;
        this.series = point.series;
        this.dataItem = point.dataItem;
        this.percentage = point.percentage;
        this.runningTotal = point.runningTotal;
        this.total = point.total;
        this.low = point.low;
        this.high = point.high;
        this.xLow = point.xLow;
        this.xHigh = point.xHigh;
        this.yLow = point.yLow;
        this.yHigh = point.yHigh;
        this.template = template;
        this.point = point;
        this.format = format;
    }
    /**
     * @hidden
     */
    get formattedValue() {
        return this.format ? this.point.formatValue(this.format) : String(this.value);
    }
}

/* tslint:disable:align no-empty */
const POSITION_MODE = 'absolute';
const COLLISION = { horizontal: "fit", vertical: "fit" };
/**
 * @hidden
 */
class BaseTooltip {
    constructor(popupService, localizationService) {
        this.popupService = popupService;
        this.localizationService = localizationService;
        this.style = {};
        this.popupRef = null;
    }
    get active() {
        return this.popupRef !== null;
    }
    show(e) {
        const align = e.anchor.align;
        const offset = this.position(e.anchor.point);
        this.style = e.style;
        if (!this.popupRef) {
            this.popupRef = this.popupService.open(Object.assign({
                offset: offset,
                popupAlign: align,
                animate: this.animate,
                content: this.templateRef,
                collision: COLLISION,
                positionMode: POSITION_MODE
            }, this.popupSettings));
            if (this.localizationService.rtl) {
                this.popupRef.popupElement.setAttribute('dir', 'rtl');
            }
            this.onInit();
        }
        else {
            const popup = this.popupRef.popup.instance;
            popup.offset = offset;
            popup.popupAlign = align;
        }
    }
    hide() {
        if (this.popupRef) {
            this.popupRef.close();
            this.popupRef = null;
        }
    }
    onInit() {
    }
    ngOnDestroy() {
        this.hide();
    }
    position(offset) {
        if (!this.popupSettings || !this.popupSettings.appendTo) {
            return offset;
        }
        const appendTo = this.popupSettings.appendTo.element.nativeElement;
        console.log('appendTo', appendTo);
        const bbox = appendTo.getBoundingClientRect();
        const { scrollLeft, scrollTop } = this.scrollOffset(appendTo);
        return {
            left: offset.left - bbox.left - scrollLeft,
            top: offset.top - bbox.top - scrollTop
        };
    }
    scrollOffset(element) {
        if (!element) {
            return null;
        }
        let scrollLeft = element.scrollLeft;
        let scrollTop = element.scrollTop;
        let parent = element.parentElement;
        while (parent) {
            scrollLeft += parent.scrollLeft;
            scrollTop += parent.scrollTop;
            parent = parent.parentElement;
        }
        return { scrollLeft, scrollTop };
    }
}
BaseTooltip.ɵfac = function BaseTooltip_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
BaseTooltip.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: BaseTooltip });

/**
 * @hidden
 */
function hasParent(element, parent) {
    let current = element;
    while (current && current !== parent) {
        current = current.parentNode;
    }
    return current ? true : false;
}

/**
 * @hidden
 */
function bodyFactory() {
    if (isDocumentAvailable()) {
        return new ElementRef(document.body);
    }
}

const SHARED_TOOLTIP_CLASS = 'k-chart-shared-tooltip';
const TOOLTIP_CLASS = "k-chart-tooltip";
const ɵ0$2 = bodyFactory;
// Codelyzer 2.0.0-beta2 doesn't handle inherited members
/* tslint:disable:no-access-missing-member */
/**
 * @hidden
 */
let TooltipPopupComponent = class TooltipPopupComponent extends BaseTooltip {
    constructor(popupService, templateService, localizationService, ngZone) {
        super(popupService, localizationService);
        this.popupService = popupService;
        this.templateService = templateService;
        this.localizationService = localizationService;
        this.ngZone = ngZone;
        this.seriesTooltipContext = {};
        this.seriesSharedTooltipContext = {};
        this.animate = true;
        this.wrapperClass = 'k-chart-tooltip-wrapper';
        this.leave = new EventEmitter();
        this.popupClasses = {};
    }
    show(e) {
        this.shared = e.shared;
        this.popupClasses = Object.assign({
            [SHARED_TOOLTIP_CLASS]: e.shared,
            [TOOLTIP_CLASS]: true,
            [e.className]: !!e.className
        }, this.classNames);
        if (!e.shared) {
            this.seriesTooltipContext = new TooltipTemplatePoint(e.point, e.format);
            this.seriesTooltipTemplateRef = this.pointTemplateRef(e.point);
        }
        else {
            this.seriesSharedTooltipTemplateRef = this.templateService.getSharedTemplate()
                || this.defaultSharedTooltipTemplate.templateRef;
            this.seriesSharedTooltipContext = this.sharedTemplateContext(e);
        }
        super.show(e);
    }
    containsElement(element) {
        if (this.popupRef) {
            return hasParent(element, this.popupRef.popupElement);
        }
    }
    sharedTemplateContext(e) {
        const points = e.points;
        const nameColumn = points.filter((point) => typeof point.series.name !== 'undefined').length > 0;
        const colorMarker = e.series.length > 1;
        let colspan = 1;
        if (nameColumn) {
            colspan++;
        }
        if (colorMarker) {
            colspan++;
        }
        return {
            category: e.category,
            categoryText: e.categoryText,
            colorMarker: colorMarker,
            colspan: colspan,
            nameColumn: nameColumn,
            points: this.wrapPoints(e.points, e.format)
        };
    }
    pointTemplateRef(point) {
        return this.templateService.getTemplate(point.series.index) || this.defaultSeriesTooltipTemplate.templateRef;
    }
    wrapPoints(points, format) {
        const result = [];
        for (let idx = 0; idx < points.length; idx++) {
            const point = points[idx];
            const template = this.pointTemplateRef(point);
            const pointFormat = ((point.options || {}).tooltip || {}).format || format;
            result.push(new TooltipTemplatePoint(point, pointFormat, template));
        }
        return result;
    }
    onInit() {
        this.ngZone.runOutsideAngular(() => {
            this.mouseleaveSubscription = this.popupRef.popupElement.addEventListener('mouseleave', (args) => {
                this.leave.emit(args);
            });
        });
        this.popupRef.popupElement.className += ` ${this.wrapperClass}`;
    }
    hide() {
        if (this.mouseleaveSubscription) {
            this.mouseleaveSubscription();
            this.mouseleaveSubscription = null;
        }
        super.hide();
    }
};
TooltipPopupComponent.ɵfac = function TooltipPopupComponent_Factory(t) { return new (t || TooltipPopupComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.PopupService), ɵngcc0.ɵɵdirectiveInject(TooltipTemplateService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone)); };
TooltipPopupComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TooltipPopupComponent, selectors: [["kendo-chart-tooltip-popup"]], viewQuery: function TooltipPopupComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(SeriesTooltipTemplateDirective, 1);
        ɵngcc0.ɵɵviewQuery(SharedTooltipTemplateDirective, 1);
        ɵngcc0.ɵɵviewQuery(_c0, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultSeriesTooltipTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defaultSharedTooltipTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    } }, inputs: { animate: "animate", wrapperClass: "wrapperClass", classNames: "classNames", popupSettings: "popupSettings" }, outputs: { leave: "leave" }, features: [ɵngcc0.ɵɵProvidersFeature([PopupService, {
                provide: POPUP_CONTAINER,
                useFactory: ɵ0$2
            }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 4, vars: 0, consts: [["content", ""], ["kendoChartSeriesTooltipTemplate", ""], ["kendoChartSharedTooltipTemplate", ""], [3, "ngClass", "ngStyle"], [4, "ngIf"], [3, "ngTemplateOutlet", "ngTemplateOutletContext"], [3, "innerHTML"], [4, "ngFor", "ngForOf"], [1, "k-chart-shared-tooltip-marker"]], template: function TooltipPopupComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, TooltipPopupComponent_ng_template_0_Template, 3, 4, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
        ɵngcc0.ɵɵtemplate(2, TooltipPopupComponent_ng_template_2_Template, 1, 1, "ng-template", 1);
        ɵngcc0.ɵɵtemplate(3, TooltipPopupComponent_ng_template_3_Template, 5, 3, "ng-template", 2);
    } }, directives: [SeriesTooltipTemplateDirective, SharedTooltipTemplateDirective, ɵngcc3.NgClass, ɵngcc3.NgStyle, ɵngcc3.NgIf, ɵngcc3.NgTemplateOutlet, ɵngcc3.NgForOf], encapsulation: 2 });
__decorate([
    ViewChild(SeriesTooltipTemplateDirective, { static: false }),
    __metadata("design:type", SeriesTooltipTemplateDirective)
], TooltipPopupComponent.prototype, "defaultSeriesTooltipTemplate", void 0);
__decorate([
    ViewChild(SharedTooltipTemplateDirective, { static: false }),
    __metadata("design:type", SharedTooltipTemplateDirective)
], TooltipPopupComponent.prototype, "defaultSharedTooltipTemplate", void 0);
__decorate([
    ViewChild('content', { static: true }),
    __metadata("design:type", TemplateRef)
], TooltipPopupComponent.prototype, "templateRef", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TooltipPopupComponent.prototype, "animate", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TooltipPopupComponent.prototype, "classNames", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TooltipPopupComponent.prototype, "popupSettings", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TooltipPopupComponent.prototype, "wrapperClass", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], TooltipPopupComponent.prototype, "leave", void 0);
TooltipPopupComponent = __decorate([ __metadata("design:paramtypes", [PopupService,
        TooltipTemplateService,
        LocalizationService,
        NgZone])
], TooltipPopupComponent);

const ɵ0$3 = bodyFactory;
// Codelyzer 2.0.0-beta2 doesn't handle inherited members
/* tslint:disable:no-access-missing-member */
/**
 * @hidden
 */
let CrosshairTooltipComponent = class CrosshairTooltipComponent extends BaseTooltip {
    constructor(popupService, localizationService) {
        super(popupService, localizationService);
        this.animate = false;
    }
    show(e) {
        super.show(e);
        this.value = e.value;
        this.popupRef.popup.changeDetectorRef.detectChanges();
    }
};
CrosshairTooltipComponent.ɵfac = function CrosshairTooltipComponent_Factory(t) { return new (t || CrosshairTooltipComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.PopupService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService)); };
CrosshairTooltipComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CrosshairTooltipComponent, selectors: [["kendo-chart-crosshair-tooltip"]], viewQuery: function CrosshairTooltipComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.templateRef = _t.first);
    } }, inputs: { key: "key", popupSettings: "popupSettings" }, features: [ɵngcc0.ɵɵProvidersFeature([PopupService, {
                provide: POPUP_CONTAINER,
                useFactory: ɵ0$3
            }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 2, vars: 0, consts: [["content", ""], [1, "k-chart-tooltip", "k-chart-crosshair-tooltip", 3, "ngStyle"]], template: function CrosshairTooltipComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, CrosshairTooltipComponent_ng_template_0_Template, 2, 2, "ng-template", null, 0, ɵngcc0.ɵɵtemplateRefExtractor);
    } }, directives: [ɵngcc3.NgStyle], encapsulation: 2 });
__decorate([
    ViewChild('content', { static: true }),
    __metadata("design:type", TemplateRef)
], CrosshairTooltipComponent.prototype, "templateRef", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CrosshairTooltipComponent.prototype, "key", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CrosshairTooltipComponent.prototype, "popupSettings", void 0);
CrosshairTooltipComponent = __decorate([ __metadata("design:paramtypes", [PopupService, LocalizationService])
], CrosshairTooltipComponent);

const AXES = ["categoryAxis", "valueAxis", "xAxis", "yAxis"];
/**
 * @hidden
 */
let CrosshairTooltipsContainerComponent = class CrosshairTooltipsContainerComponent {
    /**
     * @hidden
     */
    constructor() {
        this.tooltipKeys = [];
        this.tooltipsMap = {};
    }
    show(e) {
        const tooltipComponents = this.crossahirTooltipComponents.toArray();
        const axisName = e.axisName;
        const axisIndex = e.axisIndex;
        for (let idx = 0; idx < tooltipComponents.length; idx++) {
            if (tooltipComponents[idx].key === axisName + axisIndex) {
                tooltipComponents[idx].show(e);
                break;
            }
        }
    }
    hide() {
        const tooltipComponents = this.crossahirTooltipComponents.toArray();
        for (let idx = 0; idx < tooltipComponents.length; idx++) {
            tooltipComponents[idx].hide();
        }
    }
    get active() {
        return this.tooltipKeys.length > 0;
    }
    createCrosshairTooltips(options) {
        const newMap = this.mapTooltips(options);
        const map = this.tooltipsMap;
        for (let key in map) {
            if (!newMap[key]) {
                this.removeTooltip(key);
                delete map[key];
            }
        }
        for (let key in newMap) {
            if (!map[key]) {
                map[key] = newMap[key];
                this.tooltipKeys.push(key);
            }
        }
    }
    removeTooltip(key) {
        const keys = this.tooltipKeys;
        for (let idx = 0; idx < keys.length; idx++) {
            if (keys[idx] === key) {
                keys.splice(idx, 1);
                break;
            }
        }
    }
    mapTooltips(options) {
        const map = {};
        for (let idx = 0; idx < AXES.length; idx++) {
            const tooltips = this.axesCrosshairTooltipOptions(options, AXES[idx]);
            for (let tooltipIdx = 0; tooltipIdx < tooltips.length; tooltipIdx++) {
                const tooltip = tooltips[tooltipIdx];
                map[tooltip.name + tooltip.index] = tooltip;
            }
        }
        return map;
    }
    axesCrosshairTooltipOptions(options, name) {
        const result = [];
        if (options[name]) {
            const axes = [].concat(options[name]);
            for (let idx = 0; idx < axes.length; idx++) {
                const tooltip = (axes[idx].crosshair || {}).tooltip;
                if (tooltip && tooltip.visible) {
                    result.push({
                        index: idx,
                        name: name
                    });
                }
            }
        }
        return result;
    }
};
CrosshairTooltipsContainerComponent.ɵfac = function CrosshairTooltipsContainerComponent_Factory(t) { return new (t || CrosshairTooltipsContainerComponent)(); };
CrosshairTooltipsContainerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CrosshairTooltipsContainerComponent, selectors: [["kendo-chart-crosshair-tooltips-container"]], viewQuery: function CrosshairTooltipsContainerComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(CrosshairTooltipComponent, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.crossahirTooltipComponents = _t);
    } }, inputs: { popupSettings: "popupSettings" }, decls: 1, vars: 1, consts: [[3, "key", "popupSettings", 4, "ngFor", "ngForOf"], [3, "key", "popupSettings"]], template: function CrosshairTooltipsContainerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, CrosshairTooltipsContainerComponent_kendo_chart_crosshair_tooltip_0_Template, 1, 2, "kendo-chart-crosshair-tooltip", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngForOf", ctx.tooltipKeys);
    } }, directives: [ɵngcc3.NgForOf, CrosshairTooltipComponent], encapsulation: 2 });
__decorate([
    Input(),
    __metadata("design:type", Object)
], CrosshairTooltipsContainerComponent.prototype, "popupSettings", void 0);
__decorate([
    ViewChildren(CrosshairTooltipComponent),
    __metadata("design:type", QueryList)
], CrosshairTooltipsContainerComponent.prototype, "crossahirTooltipComponents", void 0);

const getTouch = (domEvent) => {
    return {
        x: {
            location: domEvent.pageX
        },
        y: {
            location: domEvent.pageY
        }
    };
};
const eventArgs = (e, previousArgs) => {
    const pointers = e.pointers;
    const pointer = pointers[0];
    const xLocation = pointer.pageX;
    const yLocation = pointer.pageY;
    let distance = 0;
    if (pointers.length > 1) {
        const pointer1 = pointers[0];
        const pointer2 = pointers[1];
        distance = Math.sqrt(Math.pow(pointer1.pageX - pointer2.pageX, 2) + Math.pow(pointer1.pageY - pointer2.pageY, 2));
    }
    return {
        distance: distance,
        event: e.srcEvent,
        preventDefault: function () {
            e.preventDefault();
        },
        target: e.target,
        touches: pointers.map(getTouch),
        type: e.type,
        x: {
            delta: previousArgs ? xLocation - previousArgs.x.location : 0,
            initialDelta: e.deltaX,
            location: xLocation,
            startLocation: xLocation - e.deltaX
        },
        y: {
            delta: previousArgs ? yLocation - previousArgs.y.location : 0,
            initialDelta: e.deltaY,
            location: yLocation,
            startLocation: yLocation - e.deltaY
        }
    };
};
function shouldBindGroup(groupNames, events) {
    for (let idx = 0; idx < groupNames.length; idx++) {
        if (events[groupNames[idx]]) {
            return true;
        }
    }
    return false;
}
const eventGroups = [{
        end: 'panend',
        move: 'panmove',
        start: 'panstart'
    }, {
        gesturechange: 'pinchmove',
        gestureend: 'pinchend',
        gesturestart: 'pinchstart'
    }, {
        press: 'press'
    }, {
        tap: 'tap'
    }];
/**
 * @hidden
 */
class DomEvents {
    constructor(hammerInstance, events) {
        this.hammerInstance = hammerInstance;
        this.eventHandlers = {};
        this.tap = this.tap.bind(this);
        this.press = this.press.bind(this);
        this.panstart = this.panstart.bind(this);
        this.panmove = this.panmove.bind(this);
        this.panend = this.panend.bind(this);
        this.pinchstart = this.pinchstart.bind(this);
        this.pinchmove = this.pinchmove.bind(this);
        this.pinchend = this.pinchend.bind(this);
        if (events) {
            this.bind(events);
        }
    }
    tap(e) {
        this.trigger('tap', e);
    }
    press(e) {
        this.trigger('press', e);
    }
    panstart(e) {
        delete this.previous;
        this.previous = this.trigger('start', e);
    }
    panmove(e) {
        this.previous = this.trigger('move', e);
    }
    panend(e) {
        this.trigger('end', e);
        delete this.previous;
    }
    pinchstart(e) {
        this.trigger('gesturestart', e);
    }
    pinchmove(e) {
        this.trigger('gesturechange', e);
    }
    pinchend(e) {
        this.trigger('gestureend', e);
    }
    trigger(name, e) {
        const args = eventArgs(e, this.previous);
        if (this.eventHandlers[name]) {
            this.eventHandlers[name](args);
        }
        return args;
    }
    bind(events = {}) {
        this.unbind();
        this.eventHandlers = events;
        for (let idx = 0; idx < eventGroups.length; idx++) {
            const eventGroup = eventGroups[idx];
            const groupNames = Object.keys(eventGroup);
            if (shouldBindGroup(groupNames, events)) {
                for (let nameIdx = 0; nameIdx < groupNames.length; nameIdx++) {
                    const name = eventGroup[groupNames[nameIdx]];
                    this.hammerInstance.on(name, this[name]);
                }
            }
        }
    }
    unbind() {
        if (this.hammerInstance) {
            this.hammerInstance.off();
        }
        this.eventHandlers = {};
    }
    destroy() {
        if (this.hammerInstance) {
            this.hammerInstance.destroy();
            delete this.hammerInstance;
        }
        delete this.eventHandlers;
    }
    toggleDrag(enable) {
        this.toggle('pan', enable);
    }
    toggleZoom(enable) {
        this.toggle('pinch', enable);
    }
    toggle(recognizer, enable) {
        if (this.hammerInstance) {
            const instanceRecognizer = this.hammerInstance.get(recognizer);
            instanceRecognizer.set({
                enable: enable
            });
        }
    }
}

const MISSING_HAMMER_MESSAGE = 'Hammerjs is not loaded.' +
    'Solution: http://www.telerik.com/kendo-angular-ui/components/charts/troubleshooting/#toc-hammerjs-is-not-loaded';
/**
 * @hidden
 */
class DomEventsBuilder$1 {
    static create(element, events) {
        if (typeof window !== 'undefined') {
            const HAMMER = window.Hammer;
            if (!HAMMER) {
                if (isDevMode()) {
                    throw new Error(MISSING_HAMMER_MESSAGE);
                }
                return;
            }
            const hammerInstance = new HAMMER(element, {
                recognizers: [
                    [HAMMER.Tap],
                    [HAMMER.Pan],
                    [HAMMER.Pinch],
                    [HAMMER.Press, { time: 0 }]
                ]
            });
            return new DomEvents(hammerInstance, events);
        }
    }
}

const dateCategoryAxisFormats = DateCategoryAxis.prototype.options.labels.dateFormats;
const dateValueAxisFormats = DateValueAxis.prototype.options.labels.dateFormats;
const dateFormats = {
    milliseconds: "HH:mm:ss.SSS",
    seconds: { time: 'medium' },
    minutes: { time: 'short' },
    hours: { time: 'short' },
    days: { skeleton: 'Md' },
    weeks: { skeleton: 'Md' },
    months: { skeleton: 'yyMMM' },
    years: { skeleton: 'y' }
};
Object.assign(dateCategoryAxisFormats, dateFormats);
Object.assign(dateValueAxisFormats, dateFormats);
DomEventsBuilder.register(DomEventsBuilder$1);

function hasObservers(emitter) {
    return emitter.observers.length > 0;
}
/**
 * The root Chart component.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <button (click)="toggleLegend()">Toggle Legend</button>
 *     <button (click)="toggleSeries()">Toggle Series</button>
 *     <kendo-chart>
 *       <kendo-chart-legend [visible]="legendVisible">
 *       </kendo-chart-legend>
 *       <kendo-chart-series>
 *         <kendo-chart-series-item *ngIf="seriesVisible" name="Series #1"
 *                                   type="line" [data]="[1, 2, 3]">
 *         </kendo-chart-series-item>
 *       </kendo-chart-series>
 *     </kendo-chart>
 *   `
 * })
 * class AppComponent {
 *   public legendVisible: boolean = true;
 *   public seriesVisible: boolean = true;
 *
 *   public toggleSeries(): void {
 *     this.seriesVisible = !this.seriesVisible;
 *   }
 *
 *   public toggleLegend(): void {
 *     this.legendVisible = !this.legendVisible;
 *   }
 * }
 *
 * ```
 */
let ChartComponent = class ChartComponent extends ChartComponentGenerated {
    constructor(configurationService, themeService, element, intl, localizationService, ngZone, instanceEventService, changeDetector, renderer) {
        super(configurationService);
        this.configurationService = configurationService;
        this.themeService = themeService;
        this.element = element;
        this.intl = intl;
        this.localizationService = localizationService;
        this.ngZone = ngZone;
        this.instanceEventService = instanceEventService;
        this.changeDetector = changeDetector;
        this.renderer = renderer;
        /**
         * Fires when a legend item is clicked before the selected series visibility is toggled.
         * Can be prevented.
         */
        this.legendItemClick = new EventEmitter();
        /**
         * Limits the automatic resizing of the Chart. Sets the maximum number of times per second
         * that the component redraws its content when the size of its container changes.
         * Defaults to `10`. To disable the automatic resizing, set it to `0`.
         *
         * @example
         * ```ts
         * _@Component({
         *     selector: 'my-app',
         *     template: `
         *         <kendo-chart [resizeRateLimit]="2">
         * <!--                 ^^^^^^^^^^^^^^^^^^^^^^
         *       Will update the size of the Chart up to two times a second.
         *       Resize the Plunkr pane or window to try it out.
         * -->
         *          <kendo-chart-series>
         *            <kendo-chart-series-item [data]="seriesData">
         *           </kendo-chart-series-item>
         *         </kendo-chart-series>
         *       </kendo-chart>
         *   `
         * })
         * export class AppComponent {
         *    seriesData: number[] = [1, 2, 3, 5];
         * }
         * ```
         */
        this.resizeRateLimit = 10;
        this.theme = null;
        this.suppressTransitions = false;
        this.rtl = false;
        this.hostClasses = ['k-chart', 'k-widget'];
        validatePackage(packageMetadata);
        this.themeService.loadTheme();
        this.refreshWait();
    }
    ngOnInit() {
        if (this.element) {
            this.hostClasses.forEach(name => {
                this.renderer.addClass(this.element.nativeElement, name);
            });
            this.renderer.setStyle(this.element.nativeElement, 'position', 'relative');
        }
    }
    ngAfterViewInit() {
        if (this.canRender) {
            this.ngZone.runOutsideAngular(() => {
                const chartMouseleave = this.renderer.listen(this.surfaceElement.nativeElement, 'mouseleave', this.chartMouseleave.bind(this));
                this.domSubscriptions = () => {
                    chartMouseleave();
                };
            });
        }
        this.setDirection();
        this.subscriptions = this.intl.changes.subscribe(this.intlChange.bind(this));
        this.subscriptions.add(this.localizationService.changes.subscribe(this.rtlChange.bind(this)));
    }
    ngAfterViewChecked() {
        if (this.instance && this.autoResize) {
            this.ngZone.runOutsideAngular(() => {
                clearTimeout(this.resizeTimeout);
                this.resizeTimeout = setTimeout(() => {
                    this.resize();
                }, 0);
            });
        }
    }
    ngOnChanges(changes) {
        const store = this.configurationService.store;
        copyChanges(changes, store);
        store.popupSettings = null;
        this.configurationService.push(store);
    }
    /**
     * Updates the component fields with the specified values and refreshes the Chart.
     *
     * Use this method when the configuration values cannot be set through the template.
     *
     * @example
     * ```ts-no-run
     * chart.notifyChanges({ title: { text: 'New Title' } });
     * ```
     *
     * @param changes An object containing the updated input fields.
     */
    notifyChanges(changes) {
        this.ngOnChanges(toSimpleChanges(changes));
    }
    ngOnDestroy() {
        this.destroyed = true;
        if (this.subscription) {
            this.subscription.unsubscribe();
        }
        if (this.domSubscriptions) {
            this.domSubscriptions();
            this.domSubscriptions = null;
        }
        if (this.instance) {
            this.instance.destroy();
            this.instance = null;
        }
        if (this.subscriptions) {
            this.subscriptions.unsubscribe();
        }
        clearTimeout(this.resizeTimeout);
        clearTimeout(this.redrawTimeout);
    }
    createInstance(element, observer) {
        this.instance = new Chart(element, this.options, this.theme, {
            intlService: this.intl,
            observer: observer,
            rtl: this.rtl,
            sender: this
        });
    }
    /**
     * Exports the Chart as an image. The export operation is asynchronous and returns a promise.
     *
     * @param {ImageExportOptions} options - The parameters for the exported image.
     * @returns {Promise<string>} - A promise that will be resolved with a PNG image encoded as a Data URI.
     */
    exportImage(options = {}) {
        return exportImage(this.exportVisual(options), options);
    }
    /**
     * Exports the Chart as an SVG document. The export operation is asynchronous and returns a promise.
     *
     * @param options - The parameters for the exported file.
     * @returns - A promise that will be resolved with an SVG document that is encoded as a Data URI.
     */
    exportSVG(options = {}) {
        return exportSVG(this.exportVisual(options), options);
    }
    /**
     * Exports the Chart as a Drawing `Scene`.
     *
     * @param options - The parameters for the export operation.
     * @returns - The root Group of the scene.
     */
    exportVisual(options = {}) {
        return this.instance.exportVisual(options);
    }
    /**
     * Returns the axis with the specified name.
     *
     * @param {string} name - The axis name.
     * @returns {ChartAxis} - The axis with a corresponding name.
     */
    findAxisByName(name) {
        if (this.instance) {
            return this.instance.findAxisByName(name);
        }
    }
    /**
     * Returns the pane at the specified index.
     *
     * @param {number} index - The pane index.
     * @returns {ChartPane} - The pane at the specified index.
     */
    findPaneByIndex(index) {
        if (this.instance) {
            return this.instance.findPaneByIndex(index);
        }
    }
    /**
     * Returns the pane with the specified name.
     *
     * @param {string} name - The name of the pane.
     * @returns {ChartPane} - The pane with the provided name.
     */
    findPaneByName(name) {
        if (this.instance) {
            return this.instance.findPaneByName(name);
        }
    }
    /**
     * Returns the plot area of the Chart.
     * @returns {ChartPlotArea} - The plot area of the Chart.
     */
    getPlotArea() {
        if (this.instance) {
            return this.instance.plotArea();
        }
    }
    /**
     * Highlights the series points or the segments of a Pie, Donut, or Funnel charts.
     *
     * See [Series Highlight]({% slug serieshighlight_chart_charts %}) for more details.
     *
     * In the following example, the callback is evaluated for each data point.
     * If the function returns `true`, the point is highlighted.
     *
     * {% meta height:500 %}
     * {% embed_file elements/highlight/api/app.component.ts preview %}
     * {% embed_file shared/app.module.ts hidden %}
     * {% embed_file shared/main.ts hidden %}
     * {% endmeta %}
     *
     * @param show - A Boolean value that indicates whether the highlight is shown or hidden.
     * @param filter - A string that represents the series or category name, an object with the series and category name, or a function which will be called for each point. The function should return `true` for the points for which the highlight is toggled.
     */
    toggleHighlight(show, filter) {
        if (this.instance) {
            this.instance.toggleHighlight(show, filter);
        }
    }
    /**
     * Hides the tooltip of the Chart.
     */
    hideTooltip() {
        if (this.instance) {
            this.instance.hideTooltip();
        }
    }
    /**
     * Shows the Chart tooltip of a specific point or the shared tooltip of a specific category.
     *
     * @param filter - The category for a shared tooltip or a function which will be called for each point until the function returns `true`.
     */
    showTooltip(filter) {
        if (this.instance) {
            this.instance.showTooltip(filter);
        }
    }
    init() {
        if (!this.canRender) {
            return;
        }
        const element = this.surfaceElement.nativeElement;
        const instanceObserver = new ChartInstanceObserver(this);
        this.createInstance(element, instanceObserver);
    }
    /**
     * Detects the size of the container and redraws the Chart.
     * Resizing is automatic unless you set the `resizeRateLimit` option to `0`.
     */
    resize() {
        if (this.instance) {
            this.instance.resize();
        }
    }
    /**
     * @hidden
     */
    onResize(_event) {
        if (this.autoResize) {
            this.resize();
        }
    }
    onLegendItemClick(e) {
        this.run(() => {
            const args = new LegendItemClickEvent(e, this);
            this.legendItemClick.emit(args);
            if (!args.isDefaultPrevented()) {
                const series = this.seriesComponents.toArray()[e.series.index];
                if (!series) {
                    return;
                }
                if (e.pointIndex === undefined) {
                    series.toggleVisibility();
                }
                else {
                    series.togglePointVisibility(e.pointIndex);
                }
                this.suppressTransitions = true;
            }
        }, hasObservers(this.legendItemClick), this.seriesComponents.length > 0);
    }
    onInit(e) {
        this.instance = e.sender;
    }
    onRender(e) {
        const donutCenterStyle = this.getDonutCenterStyle();
        this.run(() => {
            const args = new RenderEvent(e, this);
            this.surface = e.sender.surface;
            this.render.emit(args);
            this.donutCenterStyle = donutCenterStyle;
        }, hasObservers(this.render), this.donutCenterStyle !== donutCenterStyle);
    }
    onShowTooltip(e) {
        this.run(() => {
            if (!e.crosshair) {
                this.tooltipInstance.show(e);
            }
            else {
                this.crossahirTooltips.show(e);
            }
        }, !e.crosshair, true);
    }
    onHideTooltip(e) {
        if (!e.crosshair) {
            if (this.tooltipInstance.active) {
                this.tooltipInstance.hide();
                this.detectChanges();
            }
        }
        else if (this.crossahirTooltips.active) {
            this.crossahirTooltips.hide();
            this.detectChanges();
        }
    }
    trigger(name, e) {
        if (name === 'resize') {
            return;
        }
        const emitter = this.activeEmitter(name);
        if (emitter) {
            const args = this.instanceEventService.create(name, e, this);
            this.run(() => {
                emitter.emit(args);
            });
            return args.isDefaultPrevented && args.isDefaultPrevented();
        }
    }
    requiresHandlers(names) {
        for (let idx = 0; idx < names.length; idx++) {
            if (this.activeEmitter(names[idx])) {
                return true;
            }
        }
        return false;
    }
    refresh() {
        clearTimeout(this.redrawTimeout);
        this.updateDirection();
        this.crossahirTooltips.createCrosshairTooltips(this.options);
        this.setChartAreaSize();
        if (!this.instance) {
            this.init();
            return;
        }
        const transitions = this.options.transitions;
        if (this.suppressTransitions) {
            this.options.transitions = false;
        }
        this.updateOptions();
        if (this.suppressTransitions) {
            this.options.transitions = transitions;
            this.suppressTransitions = false;
        }
    }
    setChartAreaSize() {
        if (!this.element) {
            return;
        }
        const element = this.element.nativeElement;
        const chartArea = this.options.chartArea || {};
        if (chartArea.width) {
            element.style.width = `${chartArea.width}px`;
        }
        if (chartArea.height) {
            element.style.height = `${chartArea.height}px`;
        }
    }
    updateOptions() {
        this.instance.setOptions(this.options);
    }
    /**
     * @hidden
     */
    tooltipMouseleave(e) {
        const relatedTarget = e.relatedTarget;
        const chartElement = this.element.nativeElement;
        if (this.instance && (!relatedTarget || !hasParent(relatedTarget, chartElement))) {
            this.instance.hideElements();
        }
    }
    /**
     * @hidden
     */
    chartMouseleave(e) {
        const relatedTarget = e.relatedTarget;
        const chartElement = this.element.nativeElement;
        if (this.instance && (!relatedTarget || !(this.tooltipInstance.containsElement(relatedTarget) || hasParent(relatedTarget, chartElement))) &&
            !this.instance.handlingTap) {
            this.instance.hideElements();
        }
    }
    get canRender() {
        return isDocumentAvailable() && Boolean(this.surfaceElement);
    }
    get autoResize() {
        return this.resizeRateLimit > 0;
    }
    activeEmitter(name) {
        const emitter = this[name];
        if (emitter && emitter.emit && hasObservers(emitter)) {
            return emitter;
        }
    }
    getDonutCenterStyle() {
        if (!this.instance || !this.options || !this.options.series) {
            return;
        }
        const firstSeries = this.options.series[0];
        const charts = this.instance._plotArea.charts;
        if (!firstSeries || firstSeries.type !== 'donut' || !charts || charts[0].points.length === 0) {
            return;
        }
        const firstPoint = charts[0].points[0];
        const center = firstPoint.box.center();
        const radius = firstPoint.sector.innerRadius;
        const top = center.y - radius;
        const left = center.x - radius;
        const size = radius * 2;
        return {
            height: size + 'px',
            left: left + 'px',
            top: top + 'px',
            width: size + 'px'
        };
    }
    refreshWait() {
        this.ngZone.runOutsideAngular(() => {
            this.subscription = combineLatest(this.configurationService.onChange$, this.themeService.onChange$).pipe(tap((result) => {
                this.options = result[0];
                this.theme = result[1];
            }), auditTime(THROTTLE_MS))
                .subscribe(() => {
                this.refresh();
            });
        });
    }
    run(callback, inZone = true, detectChanges) {
        if (inZone) {
            if (detectChanges) {
                this.changeDetector.markForCheck();
            }
            this.ngZone.run(callback);
        }
        else {
            callback();
            if (detectChanges) {
                this.detectChanges();
            }
        }
    }
    detectChanges() {
        if (!this.destroyed) {
            this.changeDetector.detectChanges();
        }
    }
    intlChange() {
        if (this.instance) {
            this.deferredRedraw();
        }
    }
    rtlChange() {
        if (this.instance && this.rtl !== this.isRTL) {
            this.deferredRedraw();
        }
    }
    deferredRedraw() {
        this.ngZone.runOutsideAngular(() => {
            clearTimeout(this.redrawTimeout);
            this.redrawTimeout = setTimeout(() => {
                this.updateDirection();
                this.instance.noTransitionsRedraw();
            }, 0);
        });
    }
    updateDirection() {
        const current = this.isRTL;
        if (this.rtl !== current) {
            this.setDirection();
            if (this.instance) {
                this.instance.setDirection(current);
            }
        }
    }
    setDirection() {
        this.rtl = this.isRTL;
        if (this.element) {
            this.renderer.setAttribute(this.element.nativeElement, 'dir', this.rtl ? 'rtl' : 'ltr');
        }
    }
    get isRTL() {
        return Boolean(this.localizationService.rtl);
    }
};
ChartComponent.ɵfac = function ChartComponent_Factory(t) { return new (t || ChartComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(ThemeService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.IntlService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(InstanceEventService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
ChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ChartComponent, selectors: [["kendo-chart"]], contentQueries: function ChartComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, DonutCenterTemplateDirective, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, SeriesItemComponent, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.donutCenterTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.seriesComponents = _t);
    } }, viewQuery: function ChartComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(TooltipPopupComponent, 3);
        ɵngcc0.ɵɵviewQuery(CrosshairTooltipsContainerComponent, 3);
        ɵngcc0.ɵɵviewQuery(_c1, 3);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.tooltipInstance = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.crossahirTooltips = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.surfaceElement = _t.first);
    } }, inputs: { resizeRateLimit: "resizeRateLimit", popupSettings: "popupSettings" }, outputs: { legendItemClick: "legendItemClick" }, exportAs: ["kendoChart"], features: [ɵngcc0.ɵɵProvidersFeature([
            ConfigurationService,
            TooltipTemplateService,
            InstanceEventService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.chart'
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature], decls: 6, vars: 4, consts: [[1, "k-chart-surface"], ["surface", ""], [3, "popupSettings"], [3, "popupSettings", "leave"], [3, "rateLimit", "resize"], ["class", "k-chart-donut-center", 3, "ngStyle", 4, "ngIf"], [1, "k-chart-donut-center", 3, "ngStyle"], [3, "ngTemplateOutlet"]], template: function ChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0, 1);
        ɵngcc0.ɵɵelement(2, "kendo-chart-crosshair-tooltips-container", 2);
        ɵngcc0.ɵɵelementStart(3, "kendo-chart-tooltip-popup", 3);
        ɵngcc0.ɵɵlistener("leave", function ChartComponent_Template_kendo_chart_tooltip_popup_leave_3_listener($event) { return ctx.tooltipMouseleave($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "kendo-resize-sensor", 4);
        ɵngcc0.ɵɵlistener("resize", function ChartComponent_Template_kendo_resize_sensor_resize_4_listener($event) { return ctx.onResize($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, ChartComponent_div_5_Template, 2, 2, "div", 5);
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("popupSettings", ctx.popupSettings);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("popupSettings", ctx.popupSettings);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("rateLimit", ctx.resizeRateLimit);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.donutCenterStyle && ctx.donutCenterTemplate);
    } }, directives: [CrosshairTooltipsContainerComponent, TooltipPopupComponent, ɵngcc5.ResizeSensorComponent, ɵngcc3.NgIf, ɵngcc3.NgStyle, ɵngcc3.NgTemplateOutlet], encapsulation: 2, changeDetection: 0 });
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], ChartComponent.prototype, "legendItemClick", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ChartComponent.prototype, "resizeRateLimit", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartComponent.prototype, "popupSettings", void 0);
__decorate([
    ContentChildren(SeriesItemComponent, { descendants: true }),
    __metadata("design:type", QueryList)
], ChartComponent.prototype, "seriesComponents", void 0);
__decorate([
    ContentChild(DonutCenterTemplateDirective, { static: false }),
    __metadata("design:type", DonutCenterTemplateDirective)
], ChartComponent.prototype, "donutCenterTemplate", void 0);
__decorate([
    ViewChild(TooltipPopupComponent, { static: true }),
    __metadata("design:type", TooltipPopupComponent)
], ChartComponent.prototype, "tooltipInstance", void 0);
__decorate([
    ViewChild(CrosshairTooltipsContainerComponent, { static: true }),
    __metadata("design:type", CrosshairTooltipsContainerComponent)
], ChartComponent.prototype, "crossahirTooltips", void 0);
__decorate([
    ViewChild('surface', { static: true }),
    __metadata("design:type", ElementRef)
], ChartComponent.prototype, "surfaceElement", void 0);
ChartComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        ThemeService,
        ElementRef,
        IntlService,
        LocalizationService,
        NgZone,
        InstanceEventService,
        ChangeDetectorRef,
        Renderer2])
], ChartComponent);

/**
 * @hidden
 */
class AxisDefaultsComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('axisDefaults', configurationService);
        this.configurationService = configurationService;
    }
}
AxisDefaultsComponentGenerated.ɵfac = function AxisDefaultsComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
AxisDefaultsComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AxisDefaultsComponentGenerated, inputs: { background: "background", color: "color", line: "line", majorGridLines: "majorGridLines", majorTicks: "majorTicks", minorGridLines: "minorGridLines", minorTicks: "minorTicks", narrowRange: "narrowRange", pane: "pane", plotBands: "plotBands", reverse: "reverse", startAngle: "startAngle", visible: "visible", crosshair: "crosshair", labels: "labels", title: "title" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], AxisDefaultsComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AxisDefaultsComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AxisDefaultsComponentGenerated.prototype, "line", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AxisDefaultsComponentGenerated.prototype, "majorGridLines", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AxisDefaultsComponentGenerated.prototype, "majorTicks", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AxisDefaultsComponentGenerated.prototype, "minorGridLines", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AxisDefaultsComponentGenerated.prototype, "minorTicks", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], AxisDefaultsComponentGenerated.prototype, "narrowRange", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AxisDefaultsComponentGenerated.prototype, "pane", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], AxisDefaultsComponentGenerated.prototype, "plotBands", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], AxisDefaultsComponentGenerated.prototype, "reverse", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], AxisDefaultsComponentGenerated.prototype, "startAngle", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], AxisDefaultsComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AxisDefaultsComponentGenerated.prototype, "crosshair", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AxisDefaultsComponentGenerated.prototype, "labels", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AxisDefaultsComponentGenerated.prototype, "title", void 0);

/**
 * The default options for all Chart axes.
 * Accepts the options which are supported by [`categoryAxis`]({% slug api_charts_categoryaxisitemcomponent %}),
 * [`valueAxis`]({% slug api_charts_valueaxisitemcomponent %}),
 * [`xAxis`]({% slug api_charts_xaxisitemcomponent %}),
 * and [`yAxis`]({% slug api_charts_yaxisitemcomponent %}).
 *
 * @example
 * ```ts-preview
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *  <div style="height: 600px;">
 *  <kendo-chart [categoryAxis]="{ categories: categories }" [chartArea]="{height: 600}" >
 *    <kendo-chart-axis-defaults
 *      [background]="background"
 *      [color]="color"
 *      [crosshair]="crosshair"
 *      [labels]="labels"
 *      [line]="line"
 *      [majorGridLines]="majorGridLines"
 *      [minorGridLines]="minorGridLines"
 *      [majorTicks]="majorTicks"
 *      [minorTicks]="minorTicks"
 *      [title]="title"
 *      ></kendo-chart-axis-defaults>
 *    <kendo-chart-title text="Gross domestic product growth /GDP annual %/"></kendo-chart-title>
 *    <kendo-chart-legend position="bottom" orientation="horizontal"></kendo-chart-legend>
 *    <kendo-chart-tooltip format="{0}%"></kendo-chart-tooltip>
 *    <kendo-chart-series>
 *        <kendo-chart-series-item *ngFor="let item of series"
 *            type="line" style="smooth" [data]="item.data" [name]="item.name">
 *        </kendo-chart-series-item>
 *    </kendo-chart-series>
 *  </kendo-chart>
 *  </div>
 * `
 * })
 * export class AppComponent {
 * public series: any[] = [{
 * name: "India",
 * data: [4, 8, 8, 9, 9, 9, 3, 8, 9, 6]
 * }, {
 * name: "Russian Federation",
 * data: [4, 7, 7, 6, 8, 8, 5, 8, 4, 4]
 * }, {
 * name: "Germany",
 * data: [0, 0, 1, 1, 4, 3, 1, 5, 4, 3]
 * },{
 * name: "World",
 * data: [2, 3, 4, 4, 4, 4, 1, 2, 4, 3]
 * }];
 *
 * public  categories: number[] = [2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011];
 *
 * public background = 'white';
 * // public color = 'cyan'; // will override the line.color option
 * public crosshair = {
 * visible: true
 * };
 * public labels = {
 * font: 'bold 12px/30px Helvetica, Arial, sans-serif',
 * color: '#4CAF50',
 * padding: 5,
 * rotation: 45,
 * background: 'white',
 * border: {
 * color: '#4CAF50',
 * width: 2
 * },
 * };
 * public line = {
 * color: 'black',
 * width: 3
 * };
 *
 * public majorGridLines = {
 * color: 'black',
 * visible: true
 * }
 *
 * public minorGridLines = {
 * color: 'lightgray',
 * visible: true
 * }
 *
 * public majorTicks = {
 * color: 'black',
 * size: 15
 * }
 *
 * public minorTicks = {
 * color: 'lightgray',
 * size: 10
 * }
 *
 * public title = {
 * text: 'Default Axis Title',
 * color: 'black',
 * background: 'white',
 * border: {
 * color: 'black',
 * width: 2
 * },
 * padding: 10
 * }
 * }
 * ```
 */
let AxisDefaultsComponent = class AxisDefaultsComponent extends AxisDefaultsComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
AxisDefaultsComponent.ɵfac = function AxisDefaultsComponent_Factory(t) { return new (t || AxisDefaultsComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
AxisDefaultsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AxisDefaultsComponent, selectors: [["kendo-chart-axis-defaults"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function AxisDefaultsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
AxisDefaultsComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], AxisDefaultsComponent);

/**
 * @hidden
 */
class AxisDefaultsCrosshairComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('axisDefaults.crosshair', configurationService);
        this.configurationService = configurationService;
    }
}
AxisDefaultsCrosshairComponentGenerated.ɵfac = function AxisDefaultsCrosshairComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
AxisDefaultsCrosshairComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AxisDefaultsCrosshairComponentGenerated, inputs: { color: "color", dashType: "dashType", opacity: "opacity", visible: "visible", width: "width", tooltip: "tooltip" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], AxisDefaultsCrosshairComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AxisDefaultsCrosshairComponentGenerated.prototype, "dashType", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], AxisDefaultsCrosshairComponentGenerated.prototype, "opacity", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], AxisDefaultsCrosshairComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], AxisDefaultsCrosshairComponentGenerated.prototype, "width", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AxisDefaultsCrosshairComponentGenerated.prototype, "tooltip", void 0);

/**
 * The crosshair configuration options ([see example]({% slug api_charts_axisdefaultscomponent %})).
 */
let AxisDefaultsCrosshairComponent = class AxisDefaultsCrosshairComponent extends AxisDefaultsCrosshairComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
};
AxisDefaultsCrosshairComponent.ɵfac = function AxisDefaultsCrosshairComponent_Factory(t) { return new (t || AxisDefaultsCrosshairComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
AxisDefaultsCrosshairComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AxisDefaultsCrosshairComponent, selectors: [["kendo-chart-axis-defaults-crosshair"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function AxisDefaultsCrosshairComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
AxisDefaultsCrosshairComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], AxisDefaultsCrosshairComponent);

/**
 * @hidden
 */
class AxisDefaultsCrosshairTooltipComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('axisDefaults.crosshair.tooltip', configurationService);
        this.configurationService = configurationService;
    }
}
AxisDefaultsCrosshairTooltipComponentGenerated.ɵfac = function AxisDefaultsCrosshairTooltipComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
AxisDefaultsCrosshairTooltipComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AxisDefaultsCrosshairTooltipComponentGenerated, inputs: { background: "background", border: "border", color: "color", font: "font", format: "format", padding: "padding", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], AxisDefaultsCrosshairTooltipComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AxisDefaultsCrosshairTooltipComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AxisDefaultsCrosshairTooltipComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AxisDefaultsCrosshairTooltipComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AxisDefaultsCrosshairTooltipComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AxisDefaultsCrosshairTooltipComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], AxisDefaultsCrosshairTooltipComponentGenerated.prototype, "visible", void 0);

/**
 * The options of the crosshair tooltip ([see example]({% slug crosshairs_chart_charts %})).
 * The crosshair tooltip is displayed when the [`axisDefaults.crosshair.tooltip.visible`]({% slug api_charts_axisdefaultscrosshairtooltipcomponent %}#toc-visible)
 * option is set to `true`.
 */
let AxisDefaultsCrosshairTooltipComponent = class AxisDefaultsCrosshairTooltipComponent extends AxisDefaultsCrosshairTooltipComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
};
AxisDefaultsCrosshairTooltipComponent.ɵfac = function AxisDefaultsCrosshairTooltipComponent_Factory(t) { return new (t || AxisDefaultsCrosshairTooltipComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
AxisDefaultsCrosshairTooltipComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AxisDefaultsCrosshairTooltipComponent, selectors: [["kendo-chart-axis-defaults-crosshair-tooltip"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function AxisDefaultsCrosshairTooltipComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
AxisDefaultsCrosshairTooltipComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], AxisDefaultsCrosshairTooltipComponent);

/**
 * @hidden
 */
class AxisDefaultsLabelsComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('axisDefaults.labels', configurationService);
        this.configurationService = configurationService;
    }
}
AxisDefaultsLabelsComponentGenerated.ɵfac = function AxisDefaultsLabelsComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
AxisDefaultsLabelsComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AxisDefaultsLabelsComponentGenerated, inputs: { content: "content", font: "font", format: "format", margin: "margin", mirror: "mirror", padding: "padding", rotation: "rotation", skip: "skip", step: "step", visible: "visible", visual: "visual" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", Function)
], AxisDefaultsLabelsComponentGenerated.prototype, "content", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AxisDefaultsLabelsComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AxisDefaultsLabelsComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AxisDefaultsLabelsComponentGenerated.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], AxisDefaultsLabelsComponentGenerated.prototype, "mirror", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AxisDefaultsLabelsComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AxisDefaultsLabelsComponentGenerated.prototype, "rotation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], AxisDefaultsLabelsComponentGenerated.prototype, "skip", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], AxisDefaultsLabelsComponentGenerated.prototype, "step", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], AxisDefaultsLabelsComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], AxisDefaultsLabelsComponentGenerated.prototype, "visual", void 0);

/**
 * The configuration of the axis labels ([see example]({% slug api_charts_axisdefaultscomponent %})).
 */
let AxisDefaultsLabelsComponent = class AxisDefaultsLabelsComponent extends AxisDefaultsLabelsComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
AxisDefaultsLabelsComponent.ɵfac = function AxisDefaultsLabelsComponent_Factory(t) { return new (t || AxisDefaultsLabelsComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
AxisDefaultsLabelsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AxisDefaultsLabelsComponent, selectors: [["kendo-chart-axis-defaults-labels"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function AxisDefaultsLabelsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
AxisDefaultsLabelsComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], AxisDefaultsLabelsComponent);

/**
 * @hidden
 */
class AxisDefaultsTitleComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('axisDefaults.title', configurationService);
        this.configurationService = configurationService;
    }
}
AxisDefaultsTitleComponentGenerated.ɵfac = function AxisDefaultsTitleComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
AxisDefaultsTitleComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: AxisDefaultsTitleComponentGenerated, inputs: { background: "background", border: "border", color: "color", font: "font", margin: "margin", padding: "padding", position: "position", rotation: "rotation", text: "text", visible: "visible", visual: "visual" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], AxisDefaultsTitleComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AxisDefaultsTitleComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AxisDefaultsTitleComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AxisDefaultsTitleComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AxisDefaultsTitleComponentGenerated.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], AxisDefaultsTitleComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AxisDefaultsTitleComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], AxisDefaultsTitleComponentGenerated.prototype, "rotation", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], AxisDefaultsTitleComponentGenerated.prototype, "text", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], AxisDefaultsTitleComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], AxisDefaultsTitleComponentGenerated.prototype, "visual", void 0);

/**
 * The configuration of the axis title ([see example]({% slug api_charts_axisdefaultscomponent %})).
 */
let AxisDefaultsTitleComponent = class AxisDefaultsTitleComponent extends AxisDefaultsTitleComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
AxisDefaultsTitleComponent.ɵfac = function AxisDefaultsTitleComponent_Factory(t) { return new (t || AxisDefaultsTitleComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
AxisDefaultsTitleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: AxisDefaultsTitleComponent, selectors: [["kendo-chart-axis-defaults-title"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function AxisDefaultsTitleComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
AxisDefaultsTitleComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], AxisDefaultsTitleComponent);

/**
 * @hidden
 */
class CollectionComponent {
    constructor(configKey, configurationService, collectionService) {
        this.configKey = configKey;
        this.configurationService = configurationService;
        this.collectionService = collectionService;
        this.items = [];
        this.subscription = collectionService.onItemChange$.subscribe(changes => this.processChanges(changes));
    }
    ngOnDestroy() {
        this.subscription.unsubscribe();
    }
    ngAfterContentInit() {
        this.readItems();
        this.children.changes.subscribe(() => this.readItems());
    }
    processChanges(changes) {
        if (!this.children) {
            return;
        }
        const index = this.children.toArray().indexOf(changes.sender);
        if (index < 0) {
            return;
        }
        this.items[index] = changes.options;
        this.change();
    }
    readItems() {
        this.items = this.children.map(s => s.options);
        this.change();
    }
    change() {
        this.configurationService.notify(new Change(this.configKey, this.items.length === 0 ? undefined : this.items));
    }
}
CollectionComponent.ɵfac = function CollectionComponent_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
CollectionComponent.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CollectionComponent });

/**
 * Specifies the `weekStartDay` of a [CategoryAxisItemComponent]({% slug api_charts_categoryaxisitemcomponent %}).
 */
var WeekStartDay;
(function (WeekStartDay) {
    /**
     * Specifies Sunday as the first day of the week.
     */
    WeekStartDay[WeekStartDay["Sunday"] = 0] = "Sunday";
    /**
     * Specifies Monday as the first day of the week.
     */
    WeekStartDay[WeekStartDay["Monday"] = 1] = "Monday";
    /**
     * Specifies Tuesday as the first day of the week.
     */
    WeekStartDay[WeekStartDay["Tuesday"] = 2] = "Tuesday";
    /**
     * Specifies Wednesday as the first day of the week.
     */
    WeekStartDay[WeekStartDay["Wednesday"] = 3] = "Wednesday";
    /**
     * Specifies Thursday as the first day of the week.
     */
    WeekStartDay[WeekStartDay["Thursday"] = 4] = "Thursday";
    /**
     * Specifies Friday as the first day of the week.
     */
    WeekStartDay[WeekStartDay["Friday"] = 5] = "Friday";
    /**
     * Specifies Saturday as the first day of the week.
     */
    WeekStartDay[WeekStartDay["Saturday"] = 6] = "Saturday";
})(WeekStartDay || (WeekStartDay = {}));

/**
 * @hidden
 */
class CategoryAxisItemComponentGenerated extends CollectionItemComponent {
    constructor(configurationService, collectionService, intl, localeId) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
        this.notifyChanges({ weekStartDay: intl.firstDay(localeId) });
    }
}
CategoryAxisItemComponentGenerated.ɵfac = function CategoryAxisItemComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
CategoryAxisItemComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CategoryAxisItemComponentGenerated, inputs: { autoBaseUnitSteps: "autoBaseUnitSteps", axisCrossingValue: "axisCrossingValue", background: "background", baseUnit: "baseUnit", baseUnitStep: "baseUnitStep", categories: "categories", color: "color", justified: "justified", line: "line", majorGridLines: "majorGridLines", majorTicks: "majorTicks", max: "max", maxDateGroups: "maxDateGroups", maxDivisions: "maxDivisions", min: "min", minorGridLines: "minorGridLines", minorTicks: "minorTicks", name: "name", pane: "pane", plotBands: "plotBands", reverse: "reverse", roundToBaseUnit: "roundToBaseUnit", startAngle: "startAngle", type: "type", visible: "visible", weekStartDay: "weekStartDay", crosshair: "crosshair", labels: "labels", notes: "notes", select: "select", title: "title" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisItemComponentGenerated.prototype, "autoBaseUnitSteps", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisItemComponentGenerated.prototype, "axisCrossingValue", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisItemComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisItemComponentGenerated.prototype, "baseUnit", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisItemComponentGenerated.prototype, "baseUnitStep", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], CategoryAxisItemComponentGenerated.prototype, "categories", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisItemComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], CategoryAxisItemComponentGenerated.prototype, "justified", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisItemComponentGenerated.prototype, "line", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisItemComponentGenerated.prototype, "majorGridLines", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisItemComponentGenerated.prototype, "majorTicks", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisItemComponentGenerated.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], CategoryAxisItemComponentGenerated.prototype, "maxDateGroups", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], CategoryAxisItemComponentGenerated.prototype, "maxDivisions", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisItemComponentGenerated.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisItemComponentGenerated.prototype, "minorGridLines", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisItemComponentGenerated.prototype, "minorTicks", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisItemComponentGenerated.prototype, "name", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisItemComponentGenerated.prototype, "pane", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], CategoryAxisItemComponentGenerated.prototype, "plotBands", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], CategoryAxisItemComponentGenerated.prototype, "reverse", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], CategoryAxisItemComponentGenerated.prototype, "roundToBaseUnit", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], CategoryAxisItemComponentGenerated.prototype, "startAngle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisItemComponentGenerated.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], CategoryAxisItemComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], CategoryAxisItemComponentGenerated.prototype, "weekStartDay", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisItemComponentGenerated.prototype, "crosshair", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisItemComponentGenerated.prototype, "labels", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisItemComponentGenerated.prototype, "notes", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisItemComponentGenerated.prototype, "select", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisItemComponentGenerated.prototype, "title", void 0);

/**
 * The configuration component for a category axis ([see example]({% slug axes_chart_charts %})).
 */
let CategoryAxisItemComponent = class CategoryAxisItemComponent extends CategoryAxisItemComponentGenerated {
    constructor(configurationService, collectionService, intl, localeId) {
        super(configurationService, collectionService, intl, localeId);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
};
CategoryAxisItemComponent.ɵfac = function CategoryAxisItemComponent_Factory(t) { return new (t || CategoryAxisItemComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionService), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.IntlService), ɵngcc0.ɵɵdirectiveInject(LOCALE_ID)); };
CategoryAxisItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CategoryAxisItemComponent, selectors: [["kendo-chart-category-axis-item"]], inputs: { rangeLabels: "rangeLabels" }, features: [ɵngcc0.ɵɵProvidersFeature([ConfigurationService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function CategoryAxisItemComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisItemComponent.prototype, "rangeLabels", void 0);
CategoryAxisItemComponent = __decorate([ __param(3, Inject(LOCALE_ID)),
    __metadata("design:paramtypes", [ConfigurationService,
        CollectionService,
        IntlService, String])
], CategoryAxisItemComponent);

/**
 * @hidden
 */
class CategoryAxisComponentGenerated extends CollectionComponent {
    constructor(configurationService, collectionService) {
        super('categoryAxis', configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
}
CategoryAxisComponentGenerated.ɵfac = function CategoryAxisComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
CategoryAxisComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CategoryAxisComponentGenerated, contentQueries: function CategoryAxisComponentGenerated_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, CategoryAxisItemComponent, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    ContentChildren(CategoryAxisItemComponent),
    __metadata("design:type", QueryList)
], CategoryAxisComponentGenerated.prototype, "children", void 0);

/**
 * A collection of one or more category axis items.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-chart>
 *       <kendo-chart-category-axis>
 *         <kendo-chart-category-axis-item [categories]="[2015, 2016]" color="#f00">
 *         </kendo-chart-category-axis-item>
 *       </kendo-chart-category-axis>
 *       <kendo-chart-series>
 *         <kendo-chart-series-item type="line" [data]="[1, 2, 3]">
 *         </kendo-chart-series-item>
 *       </kendo-chart-series>
 *     </kendo-chart>
 *   `
 * })
 * class AppComponent {
 * }
 * ```
 */
let CategoryAxisComponent = class CategoryAxisComponent extends CategoryAxisComponentGenerated {
    // Place custom properties here
    constructor(configurationService, collectionService) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
};
CategoryAxisComponent.ɵfac = function CategoryAxisComponent_Factory(t) { return new (t || CategoryAxisComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionService)); };
CategoryAxisComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CategoryAxisComponent, selectors: [["kendo-chart-category-axis"]], features: [ɵngcc0.ɵɵProvidersFeature([CollectionService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function CategoryAxisComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
CategoryAxisComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        CollectionService])
], CategoryAxisComponent);

/**
 * @hidden
 */
class CategoryAxisCrosshairComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('crosshair', configurationService);
        this.configurationService = configurationService;
    }
}
CategoryAxisCrosshairComponentGenerated.ɵfac = function CategoryAxisCrosshairComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
CategoryAxisCrosshairComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CategoryAxisCrosshairComponentGenerated, inputs: { color: "color", dashType: "dashType", opacity: "opacity", visible: "visible", width: "width", tooltip: "tooltip" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisCrosshairComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisCrosshairComponentGenerated.prototype, "dashType", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], CategoryAxisCrosshairComponentGenerated.prototype, "opacity", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], CategoryAxisCrosshairComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], CategoryAxisCrosshairComponentGenerated.prototype, "width", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisCrosshairComponentGenerated.prototype, "tooltip", void 0);

/**
 * The crosshair configuration options ([see example]({% slug crosshairs_chart_charts %})).
 */
let CategoryAxisCrosshairComponent = class CategoryAxisCrosshairComponent extends CategoryAxisCrosshairComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
};
CategoryAxisCrosshairComponent.ɵfac = function CategoryAxisCrosshairComponent_Factory(t) { return new (t || CategoryAxisCrosshairComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
CategoryAxisCrosshairComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CategoryAxisCrosshairComponent, selectors: [["kendo-chart-category-axis-item-crosshair"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function CategoryAxisCrosshairComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
CategoryAxisCrosshairComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], CategoryAxisCrosshairComponent);

/**
 * @hidden
 */
class CategoryAxisCrosshairTooltipComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('crosshair.tooltip', configurationService);
        this.configurationService = configurationService;
    }
}
CategoryAxisCrosshairTooltipComponentGenerated.ɵfac = function CategoryAxisCrosshairTooltipComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
CategoryAxisCrosshairTooltipComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CategoryAxisCrosshairTooltipComponentGenerated, inputs: { background: "background", border: "border", color: "color", font: "font", format: "format", padding: "padding", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisCrosshairTooltipComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisCrosshairTooltipComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisCrosshairTooltipComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisCrosshairTooltipComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisCrosshairTooltipComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisCrosshairTooltipComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], CategoryAxisCrosshairTooltipComponentGenerated.prototype, "visible", void 0);

/**
 * The options of the crosshair tooltip ([see example]({% slug crosshairs_chart_charts %})).
 * The crosshair tooltip is displayed when the `visible` option is set to `true`.
 */
let CategoryAxisCrosshairTooltipComponent = class CategoryAxisCrosshairTooltipComponent extends CategoryAxisCrosshairTooltipComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
};
CategoryAxisCrosshairTooltipComponent.ɵfac = function CategoryAxisCrosshairTooltipComponent_Factory(t) { return new (t || CategoryAxisCrosshairTooltipComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
CategoryAxisCrosshairTooltipComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CategoryAxisCrosshairTooltipComponent, selectors: [["kendo-chart-category-axis-item-crosshair-tooltip"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function CategoryAxisCrosshairTooltipComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
CategoryAxisCrosshairTooltipComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], CategoryAxisCrosshairTooltipComponent);

/**
 * The configuration of the axis labels ([see example]({% slug labels_chart_charts %})).
 */
let CategoryAxisLabelsComponent = class CategoryAxisLabelsComponent extends SettingsComponent {
    constructor(configurationService) {
        super('labels', configurationService);
        this.configurationService = configurationService;
    }
};
CategoryAxisLabelsComponent.ɵfac = function CategoryAxisLabelsComponent_Factory(t) { return new (t || CategoryAxisLabelsComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
CategoryAxisLabelsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CategoryAxisLabelsComponent, selectors: [["kendo-chart-category-axis-item-labels"]], inputs: { background: "background", border: "border", color: "color", content: "content", culture: "culture", dateFormats: "dateFormats", font: "font", format: "format", margin: "margin", mirror: "mirror", padding: "padding", position: "position", rotation: "rotation", skip: "skip", step: "step", visible: "visible", visual: "visual" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function CategoryAxisLabelsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisLabelsComponent.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisLabelsComponent.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisLabelsComponent.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], CategoryAxisLabelsComponent.prototype, "content", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisLabelsComponent.prototype, "culture", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisLabelsComponent.prototype, "dateFormats", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisLabelsComponent.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisLabelsComponent.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisLabelsComponent.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], CategoryAxisLabelsComponent.prototype, "mirror", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisLabelsComponent.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisLabelsComponent.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisLabelsComponent.prototype, "rotation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], CategoryAxisLabelsComponent.prototype, "skip", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], CategoryAxisLabelsComponent.prototype, "step", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], CategoryAxisLabelsComponent.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], CategoryAxisLabelsComponent.prototype, "visual", void 0);
CategoryAxisLabelsComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], CategoryAxisLabelsComponent);

/**
 * The configuration of the axis date range labels ([see example]({% slug labels_chart_charts %})).
 */
let CategoryAxisRangeLabelsComponent = class CategoryAxisRangeLabelsComponent extends CategoryAxisLabelsComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.configKey = 'rangeLabels';
        this.markAsVisible();
    }
};
CategoryAxisRangeLabelsComponent.ɵfac = function CategoryAxisRangeLabelsComponent_Factory(t) { return new (t || CategoryAxisRangeLabelsComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
CategoryAxisRangeLabelsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CategoryAxisRangeLabelsComponent, selectors: [["kendo-chart-category-axis-item-range-labels"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function CategoryAxisRangeLabelsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
CategoryAxisRangeLabelsComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], CategoryAxisRangeLabelsComponent);

/**
 * @hidden
 */
class CategoryAxisNotesComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('notes', configurationService);
        this.configurationService = configurationService;
    }
}
CategoryAxisNotesComponentGenerated.ɵfac = function CategoryAxisNotesComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
CategoryAxisNotesComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CategoryAxisNotesComponentGenerated, inputs: { data: "data", line: "line", position: "position", visual: "visual", icon: "icon", label: "label" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", Array)
], CategoryAxisNotesComponentGenerated.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisNotesComponentGenerated.prototype, "line", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisNotesComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], CategoryAxisNotesComponentGenerated.prototype, "visual", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisNotesComponentGenerated.prototype, "icon", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisNotesComponentGenerated.prototype, "label", void 0);

/**
 * The configuration of the category axis notes ([see example]({% slug notes_chart_charts %}#toc-axis-notes)).
 */
let CategoryAxisNotesComponent = class CategoryAxisNotesComponent extends CategoryAxisNotesComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
CategoryAxisNotesComponent.ɵfac = function CategoryAxisNotesComponent_Factory(t) { return new (t || CategoryAxisNotesComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
CategoryAxisNotesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CategoryAxisNotesComponent, selectors: [["kendo-chart-category-axis-item-notes"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function CategoryAxisNotesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
CategoryAxisNotesComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], CategoryAxisNotesComponent);

/**
 * @hidden
 */
class CategoryAxisNotesIconComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('notes.icon', configurationService);
        this.configurationService = configurationService;
    }
}
CategoryAxisNotesIconComponentGenerated.ɵfac = function CategoryAxisNotesIconComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
CategoryAxisNotesIconComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CategoryAxisNotesIconComponentGenerated, inputs: { background: "background", border: "border", size: "size", type: "type", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisNotesIconComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisNotesIconComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], CategoryAxisNotesIconComponentGenerated.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisNotesIconComponentGenerated.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], CategoryAxisNotesIconComponentGenerated.prototype, "visible", void 0);

/**
 * The icon of the notes.
 */
let CategoryAxisNotesIconComponent = class CategoryAxisNotesIconComponent extends CategoryAxisNotesIconComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
CategoryAxisNotesIconComponent.ɵfac = function CategoryAxisNotesIconComponent_Factory(t) { return new (t || CategoryAxisNotesIconComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
CategoryAxisNotesIconComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CategoryAxisNotesIconComponent, selectors: [["kendo-chart-category-axis-item-notes-icon"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function CategoryAxisNotesIconComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
CategoryAxisNotesIconComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], CategoryAxisNotesIconComponent);

/**
 * @hidden
 */
class CategoryAxisNotesLabelComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('notes.label', configurationService);
        this.configurationService = configurationService;
    }
}
CategoryAxisNotesLabelComponentGenerated.ɵfac = function CategoryAxisNotesLabelComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
CategoryAxisNotesLabelComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CategoryAxisNotesLabelComponentGenerated, inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", position: "position", rotation: "rotation", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisNotesLabelComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisNotesLabelComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisNotesLabelComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], CategoryAxisNotesLabelComponentGenerated.prototype, "content", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisNotesLabelComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisNotesLabelComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisNotesLabelComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], CategoryAxisNotesLabelComponentGenerated.prototype, "rotation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], CategoryAxisNotesLabelComponentGenerated.prototype, "visible", void 0);

/**
 * The label of the notes.
 */
let CategoryAxisNotesLabelComponent = class CategoryAxisNotesLabelComponent extends CategoryAxisNotesLabelComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
CategoryAxisNotesLabelComponent.ɵfac = function CategoryAxisNotesLabelComponent_Factory(t) { return new (t || CategoryAxisNotesLabelComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
CategoryAxisNotesLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CategoryAxisNotesLabelComponent, selectors: [["kendo-chart-category-axis-item-notes-label"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function CategoryAxisNotesLabelComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
CategoryAxisNotesLabelComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], CategoryAxisNotesLabelComponent);

/**
 * @hidden
 */
class CategoryAxisSelectComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('select', configurationService);
        this.configurationService = configurationService;
    }
}
CategoryAxisSelectComponentGenerated.ɵfac = function CategoryAxisSelectComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
CategoryAxisSelectComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CategoryAxisSelectComponentGenerated, inputs: { from: "from", max: "max", min: "min", mousewheel: "mousewheel", to: "to" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisSelectComponentGenerated.prototype, "from", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisSelectComponentGenerated.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisSelectComponentGenerated.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisSelectComponentGenerated.prototype, "mousewheel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisSelectComponentGenerated.prototype, "to", void 0);

/**
 * The selected axis range. If set, the axis selection is enabled. The range is index-based and starts from zero.
 * Categories with indexes in the
 * ([`select.from`]({% slug api_charts_categoryaxisselectcomponent %}#toc-from)
 * &mdash;[`select.to`]({% slug api_charts_categoryaxisselectcomponent %}#toc-to)) range will be selected.
 * This means that the last category in the range will not be included in the selection.
 * If the categories are dates, the range has to be also specified with date values.
 */
let CategoryAxisSelectComponent = class CategoryAxisSelectComponent extends CategoryAxisSelectComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
CategoryAxisSelectComponent.ɵfac = function CategoryAxisSelectComponent_Factory(t) { return new (t || CategoryAxisSelectComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
CategoryAxisSelectComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CategoryAxisSelectComponent, selectors: [["kendo-chart-category-axis-item-select"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function CategoryAxisSelectComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
CategoryAxisSelectComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], CategoryAxisSelectComponent);

/**
 * @hidden
 */
class CategoryAxisTitleComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('title', configurationService);
        this.configurationService = configurationService;
    }
}
CategoryAxisTitleComponentGenerated.ɵfac = function CategoryAxisTitleComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
CategoryAxisTitleComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: CategoryAxisTitleComponentGenerated, inputs: { background: "background", border: "border", color: "color", font: "font", margin: "margin", padding: "padding", position: "position", rotation: "rotation", text: "text", visible: "visible", visual: "visual" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisTitleComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisTitleComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisTitleComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisTitleComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisTitleComponentGenerated.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], CategoryAxisTitleComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisTitleComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], CategoryAxisTitleComponentGenerated.prototype, "rotation", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], CategoryAxisTitleComponentGenerated.prototype, "text", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], CategoryAxisTitleComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], CategoryAxisTitleComponentGenerated.prototype, "visual", void 0);

/**
 * The configuration of the category axis title.
 */
let CategoryAxisTitleComponent = class CategoryAxisTitleComponent extends CategoryAxisTitleComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
CategoryAxisTitleComponent.ɵfac = function CategoryAxisTitleComponent_Factory(t) { return new (t || CategoryAxisTitleComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
CategoryAxisTitleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: CategoryAxisTitleComponent, selectors: [["kendo-chart-category-axis-item-title"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function CategoryAxisTitleComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
CategoryAxisTitleComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], CategoryAxisTitleComponent);

/**
 * @hidden
 */
class ChartAreaComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('chartArea', configurationService);
        this.configurationService = configurationService;
    }
}
ChartAreaComponentGenerated.ɵfac = function ChartAreaComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
ChartAreaComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ChartAreaComponentGenerated, inputs: { background: "background", border: "border", height: "height", margin: "margin", opacity: "opacity", width: "width" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], ChartAreaComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartAreaComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ChartAreaComponentGenerated.prototype, "height", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ChartAreaComponentGenerated.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ChartAreaComponentGenerated.prototype, "opacity", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ChartAreaComponentGenerated.prototype, "width", void 0);

/**
 * The configuration options of the Chart area.
 * Represents the entire visible area of the Chart
 * ([see example]({% slug chartarea_chart_charts %})).
 */
let ChartAreaComponent = class ChartAreaComponent extends ChartAreaComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
ChartAreaComponent.ɵfac = function ChartAreaComponent_Factory(t) { return new (t || ChartAreaComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
ChartAreaComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ChartAreaComponent, selectors: [["kendo-chart-area"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ChartAreaComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
ChartAreaComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], ChartAreaComponent);

/**
 * @hidden
 */
class LegendComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('legend', configurationService);
        this.configurationService = configurationService;
    }
}
LegendComponentGenerated.ɵfac = function LegendComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
LegendComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LegendComponentGenerated, inputs: { align: "align", background: "background", border: "border", height: "height", labels: "labels", margin: "margin", offsetX: "offsetX", offsetY: "offsetY", orientation: "orientation", padding: "padding", position: "position", reverse: "reverse", visible: "visible", width: "width", markers: "markers", spacing: "spacing", inactiveItems: "inactiveItems", item: "item", title: "title" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], LegendComponentGenerated.prototype, "align", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], LegendComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], LegendComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], LegendComponentGenerated.prototype, "height", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], LegendComponentGenerated.prototype, "labels", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], LegendComponentGenerated.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], LegendComponentGenerated.prototype, "offsetX", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], LegendComponentGenerated.prototype, "offsetY", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], LegendComponentGenerated.prototype, "orientation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], LegendComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], LegendComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], LegendComponentGenerated.prototype, "reverse", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], LegendComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], LegendComponentGenerated.prototype, "width", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], LegendComponentGenerated.prototype, "markers", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], LegendComponentGenerated.prototype, "spacing", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], LegendComponentGenerated.prototype, "inactiveItems", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], LegendComponentGenerated.prototype, "item", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], LegendComponentGenerated.prototype, "title", void 0);

/**
 * The configuration options of the Chart legend
 * ([see example]({% slug legend_chart_charts %})).
 */
let LegendComponent = class LegendComponent extends LegendComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
};
LegendComponent.ɵfac = function LegendComponent_Factory(t) { return new (t || LegendComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
LegendComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LegendComponent, selectors: [["kendo-chart-legend"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function LegendComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
LegendComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], LegendComponent);

/**
 * @hidden
 */
class LegendInactiveItemsComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('legend.inactiveItems', configurationService);
        this.configurationService = configurationService;
    }
}
LegendInactiveItemsComponentGenerated.ɵfac = function LegendInactiveItemsComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
LegendInactiveItemsComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LegendInactiveItemsComponentGenerated, inputs: { labels: "labels" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", Object)
], LegendInactiveItemsComponentGenerated.prototype, "labels", void 0);

/**
 * The configuration of the inactive Chart legend items.
 *
 * @example
 *
 * ```html-no-run
 * <kendo-chart>
 *   <kendo-chart-legend>
 *      <kendo-chart-legend-inactive-items [labels]="{color: 'pink'}"></kendo-chart-legend-inactive-items>
 *   </kendo-chart-legend>
 * </kendo-chart>
 * ```
 */
let LegendInactiveItemsComponent = class LegendInactiveItemsComponent extends LegendInactiveItemsComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
LegendInactiveItemsComponent.ɵfac = function LegendInactiveItemsComponent_Factory(t) { return new (t || LegendInactiveItemsComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
LegendInactiveItemsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LegendInactiveItemsComponent, selectors: [["kendo-chart-legend-inactive-items"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function LegendInactiveItemsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
LegendInactiveItemsComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], LegendInactiveItemsComponent);

/**
 * @hidden
 */
class LegendItemComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('legend.item', configurationService);
        this.configurationService = configurationService;
    }
}
LegendItemComponentGenerated.ɵfac = function LegendItemComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
LegendItemComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: LegendItemComponentGenerated, inputs: { cursor: "cursor", visual: "visual" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], LegendItemComponentGenerated.prototype, "cursor", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], LegendItemComponentGenerated.prototype, "visual", void 0);

/**
 * The configuration of the Chart legend item.
 *
 * @example
 *
 * ```html-no-run
 * <kendo-chart>
 *   <kendo-chart-legend>
 *      <kendo-chart-legend-item cursor="crosshair"></kendo-chart-legend-item>
 *   </kendo-chart-legend>
 * </kendo-chart>
 * ```
 */
let LegendItemComponent = class LegendItemComponent extends LegendItemComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
LegendItemComponent.ɵfac = function LegendItemComponent_Factory(t) { return new (t || LegendItemComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
LegendItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: LegendItemComponent, selectors: [["kendo-chart-legend-item"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function LegendItemComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
LegendItemComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], LegendItemComponent);

/**
 * @hidden
 */
class PaneComponentGenerated extends CollectionItemComponent {
    constructor(configurationService, collectionService) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
}
PaneComponentGenerated.ɵfac = function PaneComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
PaneComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: PaneComponentGenerated, inputs: { background: "background", border: "border", clip: "clip", height: "height", margin: "margin", name: "name", padding: "padding", title: "title" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], PaneComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], PaneComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], PaneComponentGenerated.prototype, "clip", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], PaneComponentGenerated.prototype, "height", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], PaneComponentGenerated.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], PaneComponentGenerated.prototype, "name", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], PaneComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], PaneComponentGenerated.prototype, "title", void 0);

/**
 * The configuration component for a Chart pane.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *       <kendo-chart>
 *         <kendo-chart-panes>
 *             <kendo-chart-pane name="top" background="pink" [border]="{ color: 'black', dashtype: 'dash', width: 2 }">
 *               <!--            ^^^^^^^^^^
 *                   Unique ID for the pane.
 *               -->
 *             </kendo-chart-pane>
 *             <kendo-chart-pane name="bottom" [height]="150" title="Bottom pane">
 *               <!--                          ^^^^^^^^^^^^^^
 *                   Note that the binding is required,
 *                   otherwise the property will be
 *                   bound to a '100' string.
 *               -->
 *             </kendo-chart-pane>
 *         </kendo-chart-panes>
 *
 *         <kendo-chart-value-axis>
 *             <kendo-chart-value-axis-item name="top">
 *               <!--                       ^^^^^^^^^^
 *                   Unique ID for the axis.
 *                   No need to set a pane as it will use the first,
 *                   'top' pane by default.
 *               -->
 *             </kendo-chart-value-axis-item>
 *             <kendo-chart-value-axis-item name="bottom"
 *                                          pane="bottom">
 *               <!--                       ^^^^^^^^^^^^^
 *                   Move the axis to the bottom pane.
 *               -->
 *             </kendo-chart-value-axis-item>
 *         </kendo-chart-value-axis>
 *         <kendo-chart-series>
 *           <kendo-chart-series-item [data]="seriesData[0]">
 *               <!-- Will use the first, 'top' value axis by default. -->
 *           </kendo-chart-series-item>
 *           <kendo-chart-series-item type="line" [data]="seriesData[1]" axis="bottom">
 *               <!-- Plot this series to the 'bottom' axis.              ^^^^^^^^^^^^^ -->
 *           </kendo-chart-series-item>
 *         </kendo-chart-series>
 *       </kendo-chart>
 *   `
 * })
 * export class AppComponent {
 *   public seriesData: number[][] = [[1, 2, 3, 5], [0, 1, 0, 1]];
 * }
 * ```
 */
let PaneComponent = class PaneComponent extends PaneComponentGenerated {
    // Place custom properties here
    constructor(configurationService, collectionService) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
};
PaneComponent.ɵfac = function PaneComponent_Factory(t) { return new (t || PaneComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionService)); };
PaneComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PaneComponent, selectors: [["kendo-chart-pane"], ["kendo-chart-panes-item"]], features: [ɵngcc0.ɵɵProvidersFeature([ConfigurationService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function PaneComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
PaneComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        CollectionService])
], PaneComponent);

/**
 * The default options for all chart panes,
 * ([see example]({% slug panes_chart_charts %}#toc-default-panes-configuration)).
 */
let PaneDefaultsComponent = class PaneDefaultsComponent extends SettingsComponent {
    constructor(configurationService) {
        super('paneDefaults', configurationService);
        this.configurationService = configurationService;
    }
};
PaneDefaultsComponent.ɵfac = function PaneDefaultsComponent_Factory(t) { return new (t || PaneDefaultsComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
PaneDefaultsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PaneDefaultsComponent, selectors: [["kendo-chart-pane-defaults"]], inputs: { background: "background", border: "border", clip: "clip", height: "height", margin: "margin", padding: "padding", title: "title" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function PaneDefaultsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", String)
], PaneDefaultsComponent.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], PaneDefaultsComponent.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], PaneDefaultsComponent.prototype, "clip", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], PaneDefaultsComponent.prototype, "height", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], PaneDefaultsComponent.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], PaneDefaultsComponent.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], PaneDefaultsComponent.prototype, "title", void 0);
PaneDefaultsComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], PaneDefaultsComponent);

/**
 * The configuration of the pane default title.
 */
let PaneDefaultsTitleComponent = class PaneDefaultsTitleComponent extends SettingsComponent {
    constructor(configurationService) {
        super('paneDefaults.title', configurationService);
        this.configurationService = configurationService;
    }
};
PaneDefaultsTitleComponent.ɵfac = function PaneDefaultsTitleComponent_Factory(t) { return new (t || PaneDefaultsTitleComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
PaneDefaultsTitleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PaneDefaultsTitleComponent, selectors: [["kendo-chart-pane-defaults-title"]], inputs: { background: "background", border: "border", color: "color", font: "font", margin: "margin", position: "position", visible: "visible", visual: "visual" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function PaneDefaultsTitleComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", String)
], PaneDefaultsTitleComponent.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], PaneDefaultsTitleComponent.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], PaneDefaultsTitleComponent.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], PaneDefaultsTitleComponent.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], PaneDefaultsTitleComponent.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], PaneDefaultsTitleComponent.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], PaneDefaultsTitleComponent.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], PaneDefaultsTitleComponent.prototype, "visual", void 0);
PaneDefaultsTitleComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], PaneDefaultsTitleComponent);

/**
 * @hidden
 */
class PanesComponentGenerated extends CollectionComponent {
    constructor(configurationService, collectionService) {
        super('panes', configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
}
PanesComponentGenerated.ɵfac = function PanesComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
PanesComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: PanesComponentGenerated, contentQueries: function PanesComponentGenerated_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, PaneComponent, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    ContentChildren(PaneComponent),
    __metadata("design:type", QueryList)
], PanesComponentGenerated.prototype, "children", void 0);

/**
 * A collection of one or more pane configuration components.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-chart>
 *       <kendo-chart-panes>
 *         <kendo-chart-pane name="topPane">
 *         </kendo-chart-pane>
 *         <kendo-chart-pane name="bottomPane">
 *         </kendo-chart-pane>
 *       </kendo-chart-panes>
 *       <kendo-chart-value-axis>
 *         <kendo-chart-value-axis-item pane="topPane">
 *         </kendo-chart-value-axis-item>
 *         <kendo-chart-value-axis-item name="bottomAxis" pane="bottomPane">
 *         </kendo-chart-value-axis-item>
 *       </kendo-chart-value-axis>
 *       <kendo-chart-series>
 *         <kendo-chart-series-item type="line" [data]="[1, 2, 3]">
 *         </kendo-chart-series-item>
 *         <kendo-chart-series-item type="line" [data]="[1, 2, 3, 4]"
 *                                  axis="bottomAxis">
 *         </kendo-chart-series-item>
 *       </kendo-chart-series>
 *     </kendo-chart>
 *   `
 * })
 * class AppComponent {
 * }
 *
 * ```
 */
let PanesComponent = class PanesComponent extends PanesComponentGenerated {
    // Place custom properties here
    constructor(configurationService, collectionService) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
};
PanesComponent.ɵfac = function PanesComponent_Factory(t) { return new (t || PanesComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionService)); };
PanesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PanesComponent, selectors: [["kendo-chart-panes"]], features: [ɵngcc0.ɵɵProvidersFeature([CollectionService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function PanesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
PanesComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        CollectionService])
], PanesComponent);

/**
 * @hidden
 */
class PanesTitleComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('title', configurationService);
        this.configurationService = configurationService;
    }
}
PanesTitleComponentGenerated.ɵfac = function PanesTitleComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
PanesTitleComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: PanesTitleComponentGenerated, inputs: { background: "background", border: "border", color: "color", font: "font", margin: "margin", position: "position", text: "text", visible: "visible", visual: "visual" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], PanesTitleComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], PanesTitleComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], PanesTitleComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], PanesTitleComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], PanesTitleComponentGenerated.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], PanesTitleComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], PanesTitleComponentGenerated.prototype, "text", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], PanesTitleComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], PanesTitleComponentGenerated.prototype, "visual", void 0);

/**
 * The configuration of the Chart pane title.
 */
let PanesTitleComponent = class PanesTitleComponent extends PanesTitleComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
PanesTitleComponent.ɵfac = function PanesTitleComponent_Factory(t) { return new (t || PanesTitleComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
PanesTitleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PanesTitleComponent, selectors: [["kendo-chart-pane-title"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function PanesTitleComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
PanesTitleComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], PanesTitleComponent);

/**
 * @hidden
 */
class PlotAreaComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('plotArea', configurationService);
        this.configurationService = configurationService;
    }
}
PlotAreaComponentGenerated.ɵfac = function PlotAreaComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
PlotAreaComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: PlotAreaComponentGenerated, inputs: { background: "background", border: "border", margin: "margin", opacity: "opacity", padding: "padding" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], PlotAreaComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], PlotAreaComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], PlotAreaComponentGenerated.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], PlotAreaComponentGenerated.prototype, "opacity", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], PlotAreaComponentGenerated.prototype, "padding", void 0);

/**
 * The configuration options of the plot area
 * ([see example]({% slug plotarea_chart_charts %})).
 * The plot area is the area which displays the series.
 */
let PlotAreaComponent = class PlotAreaComponent extends PlotAreaComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
PlotAreaComponent.ɵfac = function PlotAreaComponent_Factory(t) { return new (t || PlotAreaComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
PlotAreaComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: PlotAreaComponent, selectors: [["kendo-chart-plot-area"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function PlotAreaComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
PlotAreaComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], PlotAreaComponent);

/**
 * @hidden
 */
class SeriesComponentGenerated extends CollectionComponent {
    constructor(configurationService, collectionService) {
        super('series', configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
}
SeriesComponentGenerated.ɵfac = function SeriesComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SeriesComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SeriesComponentGenerated, contentQueries: function SeriesComponentGenerated_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, SeriesItemComponent, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    ContentChildren(SeriesItemComponent),
    __metadata("design:type", QueryList)
], SeriesComponentGenerated.prototype, "children", void 0);

/**
 * A collection of one or more series items.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-chart>
 *       <kendo-chart-series>
 *         <kendo-chart-series-item type="line" [data]="[1, 2, 3]">
 *         </kendo-chart-series-item>
 *       </kendo-chart-series>
 *     </kendo-chart>
 *   `
 * })
 * class AppComponent {
 * }
 *
 * ```
 */
let SeriesComponent = class SeriesComponent extends SeriesComponentGenerated {
    // Place custom properties here
    constructor(configurationService, collectionService, tooltipTemplateService) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
        this.tooltipTemplateService = tooltipTemplateService;
    }
    ngAfterContentChecked() {
        this.readTooltipTemplates();
    }
    readTooltipTemplates() {
        const templates = this.children.map((item) => item.seriesTooltipTemplateRef);
        this.tooltipTemplateService.setSeriesTemplates(templates);
    }
};
SeriesComponent.ɵfac = function SeriesComponent_Factory(t) { return new (t || SeriesComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionService), ɵngcc0.ɵɵdirectiveInject(TooltipTemplateService)); };
SeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesComponent, selectors: [["kendo-chart-series"]], features: [ɵngcc0.ɵɵProvidersFeature([CollectionService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SeriesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
SeriesComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        CollectionService,
        TooltipTemplateService])
], SeriesComponent);

/**
 * @hidden
 */
class SeriesDefaultsComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('seriesDefaults', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesDefaultsComponentGenerated.ɵfac = function SeriesDefaultsComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SeriesDefaultsComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SeriesDefaultsComponentGenerated, inputs: { border: "border", gap: "gap", highlight: "highlight", overlay: "overlay", spacing: "spacing", stack: "stack", type: "type", visual: "visual", labels: "labels", notes: "notes", tooltip: "tooltip" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesDefaultsComponentGenerated.prototype, "gap", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsComponentGenerated.prototype, "highlight", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsComponentGenerated.prototype, "overlay", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesDefaultsComponentGenerated.prototype, "spacing", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsComponentGenerated.prototype, "stack", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsComponentGenerated.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], SeriesDefaultsComponentGenerated.prototype, "visual", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsComponentGenerated.prototype, "labels", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsComponentGenerated.prototype, "notes", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsComponentGenerated.prototype, "tooltip", void 0);

/**
 * The default options for all series
 * ([see example]({% slug series_chart_charts %}#toc-default-series-configuration)).
 */
let SeriesDefaultsComponent = class SeriesDefaultsComponent extends SeriesDefaultsComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
SeriesDefaultsComponent.ɵfac = function SeriesDefaultsComponent_Factory(t) { return new (t || SeriesDefaultsComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
SeriesDefaultsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesDefaultsComponent, selectors: [["kendo-chart-series-defaults"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SeriesDefaultsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
SeriesDefaultsComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], SeriesDefaultsComponent);

/**
 * @hidden
 */
class SeriesDefaultsLabelsComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('seriesDefaults.labels', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesDefaultsLabelsComponentGenerated.ɵfac = function SeriesDefaultsLabelsComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SeriesDefaultsLabelsComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SeriesDefaultsLabelsComponentGenerated, inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", margin: "margin", padding: "padding", visible: "visible", visual: "visual", from: "from", to: "to" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsLabelsComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsLabelsComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsLabelsComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], SeriesDefaultsLabelsComponentGenerated.prototype, "content", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsLabelsComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsLabelsComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsLabelsComponentGenerated.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsLabelsComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SeriesDefaultsLabelsComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], SeriesDefaultsLabelsComponentGenerated.prototype, "visual", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsLabelsComponentGenerated.prototype, "from", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsLabelsComponentGenerated.prototype, "to", void 0);

/**
 * The configuration of the Chart series label.
 */
let SeriesDefaultsLabelsComponent = class SeriesDefaultsLabelsComponent extends SeriesDefaultsLabelsComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
};
SeriesDefaultsLabelsComponent.ɵfac = function SeriesDefaultsLabelsComponent_Factory(t) { return new (t || SeriesDefaultsLabelsComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
SeriesDefaultsLabelsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesDefaultsLabelsComponent, selectors: [["kendo-chart-series-defaults-labels"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SeriesDefaultsLabelsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
SeriesDefaultsLabelsComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], SeriesDefaultsLabelsComponent);

/**
 * @hidden
 */
class SeriesDefaultsLabelsFromComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('seriesDefaults.labels.from', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesDefaultsLabelsFromComponentGenerated.ɵfac = function SeriesDefaultsLabelsFromComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SeriesDefaultsLabelsFromComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SeriesDefaultsLabelsFromComponentGenerated, inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", margin: "margin", padding: "padding", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsLabelsFromComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsLabelsFromComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsLabelsFromComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], SeriesDefaultsLabelsFromComponentGenerated.prototype, "content", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsLabelsFromComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsLabelsFromComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsLabelsFromComponentGenerated.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsLabelsFromComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SeriesDefaultsLabelsFromComponentGenerated.prototype, "visible", void 0);

/**
 * The `from` label configuration of the Chart series.
 */
let SeriesDefaultsLabelsFromComponent = class SeriesDefaultsLabelsFromComponent extends SeriesDefaultsLabelsFromComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
};
SeriesDefaultsLabelsFromComponent.ɵfac = function SeriesDefaultsLabelsFromComponent_Factory(t) { return new (t || SeriesDefaultsLabelsFromComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
SeriesDefaultsLabelsFromComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesDefaultsLabelsFromComponent, selectors: [["kendo-chart-series-defaults-labels-from"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SeriesDefaultsLabelsFromComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
SeriesDefaultsLabelsFromComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], SeriesDefaultsLabelsFromComponent);

/**
 * @hidden
 */
class SeriesDefaultsLabelsToComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('seriesDefaults.labels.to', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesDefaultsLabelsToComponentGenerated.ɵfac = function SeriesDefaultsLabelsToComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SeriesDefaultsLabelsToComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SeriesDefaultsLabelsToComponentGenerated, inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", margin: "margin", padding: "padding", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsLabelsToComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsLabelsToComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsLabelsToComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], SeriesDefaultsLabelsToComponentGenerated.prototype, "content", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsLabelsToComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsLabelsToComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsLabelsToComponentGenerated.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsLabelsToComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SeriesDefaultsLabelsToComponentGenerated.prototype, "visible", void 0);

/**
 * The `to` label configuration of the Chart series.
 */
let SeriesDefaultsLabelsToComponent = class SeriesDefaultsLabelsToComponent extends SeriesDefaultsLabelsToComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
};
SeriesDefaultsLabelsToComponent.ɵfac = function SeriesDefaultsLabelsToComponent_Factory(t) { return new (t || SeriesDefaultsLabelsToComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
SeriesDefaultsLabelsToComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesDefaultsLabelsToComponent, selectors: [["kendo-chart-series-defaults-labels-to"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SeriesDefaultsLabelsToComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
SeriesDefaultsLabelsToComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], SeriesDefaultsLabelsToComponent);

/**
 * @hidden
 */
class SeriesDefaultsNotesComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('seriesDefaults.notes', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesDefaultsNotesComponentGenerated.ɵfac = function SeriesDefaultsNotesComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SeriesDefaultsNotesComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SeriesDefaultsNotesComponentGenerated, inputs: { line: "line", visual: "visual", icon: "icon", label: "label" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsNotesComponentGenerated.prototype, "line", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], SeriesDefaultsNotesComponentGenerated.prototype, "visual", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsNotesComponentGenerated.prototype, "icon", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsNotesComponentGenerated.prototype, "label", void 0);

/**
 * The configuration of the [`seriesDefaults`]({% slug api_charts_seriesdefaultscomponent %}) notes.
 */
let SeriesDefaultsNotesComponent = class SeriesDefaultsNotesComponent extends SeriesDefaultsNotesComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
SeriesDefaultsNotesComponent.ɵfac = function SeriesDefaultsNotesComponent_Factory(t) { return new (t || SeriesDefaultsNotesComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
SeriesDefaultsNotesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesDefaultsNotesComponent, selectors: [["kendo-chart-series-defaults-notes"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SeriesDefaultsNotesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
SeriesDefaultsNotesComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], SeriesDefaultsNotesComponent);

/**
 * @hidden
 */
class SeriesDefaultsNotesIconComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('seriesDefaults.notes.icon', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesDefaultsNotesIconComponentGenerated.ɵfac = function SeriesDefaultsNotesIconComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SeriesDefaultsNotesIconComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SeriesDefaultsNotesIconComponentGenerated, inputs: { background: "background", border: "border", size: "size", type: "type", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsNotesIconComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsNotesIconComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesDefaultsNotesIconComponentGenerated.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsNotesIconComponentGenerated.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SeriesDefaultsNotesIconComponentGenerated.prototype, "visible", void 0);

/**
 * The icon of the notes.
 */
let SeriesDefaultsNotesIconComponent = class SeriesDefaultsNotesIconComponent extends SeriesDefaultsNotesIconComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
SeriesDefaultsNotesIconComponent.ɵfac = function SeriesDefaultsNotesIconComponent_Factory(t) { return new (t || SeriesDefaultsNotesIconComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
SeriesDefaultsNotesIconComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesDefaultsNotesIconComponent, selectors: [["kendo-chart-series-defaults-notes-icon"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SeriesDefaultsNotesIconComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
SeriesDefaultsNotesIconComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], SeriesDefaultsNotesIconComponent);

/**
 * @hidden
 */
class SeriesDefaultsNotesLabelComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('seriesDefaults.notes.label', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesDefaultsNotesLabelComponentGenerated.ɵfac = function SeriesDefaultsNotesLabelComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SeriesDefaultsNotesLabelComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SeriesDefaultsNotesLabelComponentGenerated, inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", position: "position", rotation: "rotation", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsNotesLabelComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsNotesLabelComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsNotesLabelComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], SeriesDefaultsNotesLabelComponentGenerated.prototype, "content", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsNotesLabelComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsNotesLabelComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsNotesLabelComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesDefaultsNotesLabelComponentGenerated.prototype, "rotation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SeriesDefaultsNotesLabelComponentGenerated.prototype, "visible", void 0);

/**
 * The label of the notes.
 */
let SeriesDefaultsNotesLabelComponent = class SeriesDefaultsNotesLabelComponent extends SeriesDefaultsNotesLabelComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
SeriesDefaultsNotesLabelComponent.ɵfac = function SeriesDefaultsNotesLabelComponent_Factory(t) { return new (t || SeriesDefaultsNotesLabelComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
SeriesDefaultsNotesLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesDefaultsNotesLabelComponent, selectors: [["kendo-chart-series-defaults-notes-label"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SeriesDefaultsNotesLabelComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
SeriesDefaultsNotesLabelComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], SeriesDefaultsNotesLabelComponent);

/**
 * @hidden
 */
class SeriesDefaultsTooltipComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('seriesDefaults.tooltip', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesDefaultsTooltipComponentGenerated.ɵfac = function SeriesDefaultsTooltipComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SeriesDefaultsTooltipComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SeriesDefaultsTooltipComponentGenerated, inputs: { background: "background", border: "border", color: "color", font: "font", format: "format", padding: "padding", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsTooltipComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsTooltipComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsTooltipComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsTooltipComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesDefaultsTooltipComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesDefaultsTooltipComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SeriesDefaultsTooltipComponentGenerated.prototype, "visible", void 0);

/**
 * The configuration options of the Chart series tooltip.
 */
let SeriesDefaultsTooltipComponent = class SeriesDefaultsTooltipComponent extends SeriesDefaultsTooltipComponentGenerated {
    // Place custom properties here.
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
};
SeriesDefaultsTooltipComponent.ɵfac = function SeriesDefaultsTooltipComponent_Factory(t) { return new (t || SeriesDefaultsTooltipComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
SeriesDefaultsTooltipComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesDefaultsTooltipComponent, selectors: [["kendo-chart-series-defaults-tooltip"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SeriesDefaultsTooltipComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
SeriesDefaultsTooltipComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], SeriesDefaultsTooltipComponent);

/**
 * @hidden
 */
class SeriesErrorBarsComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('errorBars', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesErrorBarsComponentGenerated.ɵfac = function SeriesErrorBarsComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SeriesErrorBarsComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SeriesErrorBarsComponentGenerated, inputs: { color: "color", endCaps: "endCaps", line: "line", value: "value", visual: "visual", xValue: "xValue", yValue: "yValue" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesErrorBarsComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SeriesErrorBarsComponentGenerated.prototype, "endCaps", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesErrorBarsComponentGenerated.prototype, "line", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesErrorBarsComponentGenerated.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], SeriesErrorBarsComponentGenerated.prototype, "visual", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesErrorBarsComponentGenerated.prototype, "xValue", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesErrorBarsComponentGenerated.prototype, "yValue", void 0);

/**
 * The error bars of the Chart series
 * ([see example]({% slug errorbars_chart_charts %})).
 */
let SeriesErrorBarsComponent = class SeriesErrorBarsComponent extends SeriesErrorBarsComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
SeriesErrorBarsComponent.ɵfac = function SeriesErrorBarsComponent_Factory(t) { return new (t || SeriesErrorBarsComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
SeriesErrorBarsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesErrorBarsComponent, selectors: [["kendo-chart-series-item-error-bars"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SeriesErrorBarsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
SeriesErrorBarsComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], SeriesErrorBarsComponent);

/**
 * @hidden
 */
class SeriesExtremesComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('extremes', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesExtremesComponentGenerated.ɵfac = function SeriesExtremesComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SeriesExtremesComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SeriesExtremesComponentGenerated, inputs: { background: "background", border: "border", rotation: "rotation", size: "size", type: "type" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesExtremesComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesExtremesComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesExtremesComponentGenerated.prototype, "rotation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesExtremesComponentGenerated.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesExtremesComponentGenerated.prototype, "type", void 0);

/**
 * The configuration of the Chart series extremes.
 * Applies to extreme outliers.
 * For more information, refer to [`series.outliers`]({% slug api_charts_seriesitemcomponent %}#toc-outliers).
 */
let SeriesExtremesComponent = class SeriesExtremesComponent extends SeriesExtremesComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
SeriesExtremesComponent.ɵfac = function SeriesExtremesComponent_Factory(t) { return new (t || SeriesExtremesComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
SeriesExtremesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesExtremesComponent, selectors: [["kendo-chart-series-item-extremes"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SeriesExtremesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
SeriesExtremesComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], SeriesExtremesComponent);

/**
 * @hidden
 */
class SeriesHighlightComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('highlight', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesHighlightComponentGenerated.ɵfac = function SeriesHighlightComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SeriesHighlightComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SeriesHighlightComponentGenerated, inputs: { border: "border", color: "color", line: "line", markers: "markers", opacity: "opacity", toggle: "toggle", visible: "visible", visual: "visual" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesHighlightComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesHighlightComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesHighlightComponentGenerated.prototype, "line", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesHighlightComponentGenerated.prototype, "markers", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesHighlightComponentGenerated.prototype, "opacity", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], SeriesHighlightComponentGenerated.prototype, "toggle", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SeriesHighlightComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], SeriesHighlightComponentGenerated.prototype, "visual", void 0);

/**
 * The Chart series highlighting configuration options.
 */
let SeriesHighlightComponent = class SeriesHighlightComponent extends SeriesHighlightComponentGenerated {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
SeriesHighlightComponent.ɵfac = function SeriesHighlightComponent_Factory(t) { return new (t || SeriesHighlightComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
SeriesHighlightComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesHighlightComponent, selectors: [["kendo-chart-series-item-highlight"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SeriesHighlightComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
SeriesHighlightComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], SeriesHighlightComponent);

/**
 * @hidden
 */
class SeriesLabelsComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('labels', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesLabelsComponentGenerated.ɵfac = function SeriesLabelsComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SeriesLabelsComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SeriesLabelsComponentGenerated, inputs: { align: "align", background: "background", border: "border", color: "color", content: "content", distance: "distance", font: "font", format: "format", margin: "margin", padding: "padding", position: "position", rotation: "rotation", visible: "visible", visual: "visual", from: "from", to: "to" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesLabelsComponentGenerated.prototype, "align", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesLabelsComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesLabelsComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesLabelsComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], SeriesLabelsComponentGenerated.prototype, "content", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesLabelsComponentGenerated.prototype, "distance", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesLabelsComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesLabelsComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesLabelsComponentGenerated.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesLabelsComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesLabelsComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesLabelsComponentGenerated.prototype, "rotation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SeriesLabelsComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], SeriesLabelsComponentGenerated.prototype, "visual", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesLabelsComponentGenerated.prototype, "from", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesLabelsComponentGenerated.prototype, "to", void 0);

/**
 * The configuration of the Chart series label
 * ([see example]({% slug labels_chart_charts %})).
 */
let SeriesLabelsComponent = class SeriesLabelsComponent extends SeriesLabelsComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
};
SeriesLabelsComponent.ɵfac = function SeriesLabelsComponent_Factory(t) { return new (t || SeriesLabelsComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
SeriesLabelsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesLabelsComponent, selectors: [["kendo-chart-series-item-labels"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SeriesLabelsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
SeriesLabelsComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], SeriesLabelsComponent);

/**
 * @hidden
 */
class SeriesLabelsFromComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('labels.from', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesLabelsFromComponentGenerated.ɵfac = function SeriesLabelsFromComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SeriesLabelsFromComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SeriesLabelsFromComponentGenerated, inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", margin: "margin", padding: "padding", position: "position", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesLabelsFromComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesLabelsFromComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesLabelsFromComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], SeriesLabelsFromComponentGenerated.prototype, "content", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesLabelsFromComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesLabelsFromComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesLabelsFromComponentGenerated.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesLabelsFromComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesLabelsFromComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SeriesLabelsFromComponentGenerated.prototype, "visible", void 0);

/**
 * The `from` label configuration of the Chart series.
 */
let SeriesLabelsFromComponent = class SeriesLabelsFromComponent extends SeriesLabelsFromComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
};
SeriesLabelsFromComponent.ɵfac = function SeriesLabelsFromComponent_Factory(t) { return new (t || SeriesLabelsFromComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
SeriesLabelsFromComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesLabelsFromComponent, selectors: [["kendo-chart-series-item-labels-from"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SeriesLabelsFromComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
SeriesLabelsFromComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], SeriesLabelsFromComponent);

/**
 * @hidden
 */
class SeriesLabelsToComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('labels.to', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesLabelsToComponentGenerated.ɵfac = function SeriesLabelsToComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SeriesLabelsToComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SeriesLabelsToComponentGenerated, inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", margin: "margin", padding: "padding", position: "position", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesLabelsToComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesLabelsToComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesLabelsToComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], SeriesLabelsToComponentGenerated.prototype, "content", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesLabelsToComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesLabelsToComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesLabelsToComponentGenerated.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesLabelsToComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesLabelsToComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SeriesLabelsToComponentGenerated.prototype, "visible", void 0);

/**
 * The `to` label configuration of the Chart series.
 */
let SeriesLabelsToComponent = class SeriesLabelsToComponent extends SeriesLabelsToComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
};
SeriesLabelsToComponent.ɵfac = function SeriesLabelsToComponent_Factory(t) { return new (t || SeriesLabelsToComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
SeriesLabelsToComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesLabelsToComponent, selectors: [["kendo-chart-series-item-labels-to"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SeriesLabelsToComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
SeriesLabelsToComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], SeriesLabelsToComponent);

/**
 * @hidden
 */
class SeriesMarkersComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('markers', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesMarkersComponentGenerated.ɵfac = function SeriesMarkersComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SeriesMarkersComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SeriesMarkersComponentGenerated, inputs: { background: "background", border: "border", rotation: "rotation", size: "size", type: "type", visible: "visible", visual: "visual", from: "from", to: "to" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesMarkersComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesMarkersComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesMarkersComponentGenerated.prototype, "rotation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesMarkersComponentGenerated.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesMarkersComponentGenerated.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SeriesMarkersComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], SeriesMarkersComponentGenerated.prototype, "visual", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesMarkersComponentGenerated.prototype, "from", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesMarkersComponentGenerated.prototype, "to", void 0);

/**
 * The configuration of the Chart series marker.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *       selector: 'my-app',
 *   template: `
 *       <kendo-chart [categoryAxis]="{ categories: categories }">
 *           <kendo-chart-title text="Gross domestic product growth /GDP annual %/"></kendo-chart-title>
 *           <kendo-chart-legend position="bottom" orientation="horizontal"></kendo-chart-legend>
 *           <kendo-chart-tooltip format="{0}%"></kendo-chart-tooltip>
 *           <kendo-chart-series>
 *               <kendo-chart-series-item *ngFor="let item of series"
 *                   type="line"
 *                   style="smooth"
 *                   [data]="item.data"
 *                   [name]="item.name"
 *                   [markers]="item.markers">
 *               </kendo-chart-series-item>
 *           </kendo-chart-series>
 *       </kendo-chart>
 *   `
 * })
 * export class AppComponent {
 * public series: any[] = [{
 *   name: "India",
 *   data: [3.907, 7.943, 7.848, 9.284, 9.263, 9.801, 3.890, 8.238, 9.552, 6.855],
 *   markers: {
 *     background: 'red',
 *     size: 20,
 *     type: 'circle'
 *   }
 * }, {
 *   name: "Russian Federation",
 *   data: [4.743, 7.295, 7.175, 6.376, 8.153, 8.535, 5.247, -7.832, 4.3, 4.3],
 *   markers: {
 *     background: 'yellow',
 *     size: 10,
 *     type: 'square',
 *     rotation: 45
 *   }
 * }, {
 *   name: "Germany",
 *   data: [0.010, -0.375, 1.161, 0.684, 3.7, 3.269, 1.083, -5.127, 3.690, 2.995],
 *   markers: {
 *     background: 'green',
 *     size: 20,
 *     type: 'triangle'
 *   }
 * },{
 *   name: "World",
 *   data: [1.988, 2.733, 3.994, 3.464, 4.001, 3.939, 1.333, -2.245, 4.339, 2.727],
 *   markers: {
 *     background: 'blue',
 *     size: 10,
 *     type: 'cross'
 *   }
 * }];
 * public categories: number[] = [2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011];
 * }
 * ```
 */
let SeriesMarkersComponent = class SeriesMarkersComponent extends SeriesMarkersComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
SeriesMarkersComponent.ɵfac = function SeriesMarkersComponent_Factory(t) { return new (t || SeriesMarkersComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
SeriesMarkersComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesMarkersComponent, selectors: [["kendo-chart-series-item-markers"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SeriesMarkersComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
SeriesMarkersComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], SeriesMarkersComponent);

/**
 * @hidden
 */
class SeriesNotesComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('notes', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesNotesComponentGenerated.ɵfac = function SeriesNotesComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SeriesNotesComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SeriesNotesComponentGenerated, inputs: { line: "line", position: "position", visual: "visual", icon: "icon", label: "label" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesNotesComponentGenerated.prototype, "line", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesNotesComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], SeriesNotesComponentGenerated.prototype, "visual", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesNotesComponentGenerated.prototype, "icon", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesNotesComponentGenerated.prototype, "label", void 0);

/**
 * The series notes configuration
 * ([see example]({% slug notes_chart_charts %})).
 */
let SeriesNotesComponent = class SeriesNotesComponent extends SeriesNotesComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
SeriesNotesComponent.ɵfac = function SeriesNotesComponent_Factory(t) { return new (t || SeriesNotesComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
SeriesNotesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesNotesComponent, selectors: [["kendo-chart-series-item-notes"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SeriesNotesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
SeriesNotesComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], SeriesNotesComponent);

/**
 * @hidden
 */
class SeriesNotesIconComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('notes.icon', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesNotesIconComponentGenerated.ɵfac = function SeriesNotesIconComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SeriesNotesIconComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SeriesNotesIconComponentGenerated, inputs: { background: "background", border: "border", size: "size", type: "type", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesNotesIconComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesNotesIconComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesNotesIconComponentGenerated.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesNotesIconComponentGenerated.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SeriesNotesIconComponentGenerated.prototype, "visible", void 0);

/**
 * The icon of the notes.
 */
let SeriesNotesIconComponent = class SeriesNotesIconComponent extends SeriesNotesIconComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
SeriesNotesIconComponent.ɵfac = function SeriesNotesIconComponent_Factory(t) { return new (t || SeriesNotesIconComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
SeriesNotesIconComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesNotesIconComponent, selectors: [["kendo-chart-series-item-notes-icon"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SeriesNotesIconComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
SeriesNotesIconComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], SeriesNotesIconComponent);

/**
 * @hidden
 */
class SeriesNotesLabelComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('notes.label', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesNotesLabelComponentGenerated.ɵfac = function SeriesNotesLabelComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SeriesNotesLabelComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SeriesNotesLabelComponentGenerated, inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", position: "position", rotation: "rotation", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesNotesLabelComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesNotesLabelComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesNotesLabelComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], SeriesNotesLabelComponentGenerated.prototype, "content", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesNotesLabelComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesNotesLabelComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesNotesLabelComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesNotesLabelComponentGenerated.prototype, "rotation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], SeriesNotesLabelComponentGenerated.prototype, "visible", void 0);

/**
 * The label of the notes.
 */
let SeriesNotesLabelComponent = class SeriesNotesLabelComponent extends SeriesNotesLabelComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
SeriesNotesLabelComponent.ɵfac = function SeriesNotesLabelComponent_Factory(t) { return new (t || SeriesNotesLabelComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
SeriesNotesLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesNotesLabelComponent, selectors: [["kendo-chart-series-item-notes-label"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SeriesNotesLabelComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
SeriesNotesLabelComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], SeriesNotesLabelComponent);

/**
 * @hidden
 */
class SeriesOutliersComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('outliers', configurationService);
        this.configurationService = configurationService;
    }
}
SeriesOutliersComponentGenerated.ɵfac = function SeriesOutliersComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
SeriesOutliersComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: SeriesOutliersComponentGenerated, inputs: { background: "background", border: "border", rotation: "rotation", size: "size", type: "type" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesOutliersComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], SeriesOutliersComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesOutliersComponentGenerated.prototype, "rotation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], SeriesOutliersComponentGenerated.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], SeriesOutliersComponentGenerated.prototype, "type", void 0);

/**
 * The configuration of the Chart series outliers.
 * Applies to mild outliers.
 * For more information, refer to the [`series.extremes`]({% slug api_charts_seriesitemcomponent %}#toc-extremes) option.
 */
let SeriesOutliersComponent = class SeriesOutliersComponent extends SeriesOutliersComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
SeriesOutliersComponent.ɵfac = function SeriesOutliersComponent_Factory(t) { return new (t || SeriesOutliersComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
SeriesOutliersComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SeriesOutliersComponent, selectors: [["kendo-chart-series-item-outliers"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function SeriesOutliersComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
SeriesOutliersComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], SeriesOutliersComponent);

/**
 * @hidden
 */
class TitleComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('title', configurationService);
        this.configurationService = configurationService;
    }
}
TitleComponentGenerated.ɵfac = function TitleComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
TitleComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TitleComponentGenerated, inputs: { align: "align", background: "background", border: "border", color: "color", font: "font", margin: "margin", padding: "padding", position: "position", text: "text", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], TitleComponentGenerated.prototype, "align", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TitleComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TitleComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TitleComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TitleComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TitleComponentGenerated.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TitleComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TitleComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TitleComponentGenerated.prototype, "text", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TitleComponentGenerated.prototype, "visible", void 0);

/**
 * The configuration options of the Chart title or text
 * ([see example]({% slug title_chart_charts %})).
 *
 * @example
 * ```ts-preview
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *    selector: 'my-app',
 *    template: `
 *        <kendo-chart [categoryAxis]="{ categories: categories }">
 *            <kendo-chart-title text="Gross domestic product growth /GDP annual %/"></kendo-chart-title>
 *            <kendo-chart-legend
 *              position="bottom"
 *              orientation="horizontal"
 *              align="end"
 *              background="rgba(255, 0, 0, 0.1)"
 *              [border]="borderOptions"
 *              [margin]="10"
 *              [padding]="10"
 *              [width]="150"
 *              [offsetX]="11"
 *              [offsetY]="-103"
 *              [reverse]="true"
 *              [visible]="isVisible"
 *              ></kendo-chart-legend>
 *            <kendo-chart-tooltip format="{0}%"></kendo-chart-tooltip>
 *            <kendo-chart-series>
 *                <kendo-chart-series-item *ngFor="let item of series"
 *                    type="line" style="smooth" [data]="item.data" [name]="item.name">
 *                </kendo-chart-series-item>
 *            </kendo-chart-series>
 *        </kendo-chart>
 *        <br /><br />
 *        <button class="k-button" (click)="isVisible=!isVisible">Toggle Legend</button>
 *    `
 * })
 * export class AppComponent {
 *  public isVisible = true;
 *  public borderOptions = {
 *    color: "rgba(255, 0, 0, 0.8)",
 *    dashType: 'dash',
 *    width: 2
 *  };
 *
 * public series: any[] = [{
 *   name: "India",
 *   data: [3.907, 7.943, 7.848, 9.284, 9.263, 9.801, 3.890, 8.238, 9.552, 6.855]
 * }, {
 *   name: "Russian Federation",
 *   data: [4.743, 7.295, 7.175, 6.376, 8.153, 8.535, 5.247, -7.832, 4.3, 4.3]
 * }, {
 *   name: "Germany",
 *   data: [0.010, -0.375, 1.161, 0.684, 3.7, 3.269, 1.083, -5.127, 3.690, 2.995]
 * },{
 *   name: "World",
 *   data: [1.988, 2.733, 3.994, 3.464, 4.001, 3.939, 1.333, -2.245, 4.339, 2.727]
 * }];
 *  public categories: number[] = [2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011];
 * }
 * ```
 */
let TitleComponent = class TitleComponent extends TitleComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
TitleComponent.ɵfac = function TitleComponent_Factory(t) { return new (t || TitleComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
TitleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TitleComponent, selectors: [["kendo-chart-title"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function TitleComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
TitleComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], TitleComponent);

/**
 * @hidden
 */
class TooltipComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('tooltip', configurationService);
        this.configurationService = configurationService;
    }
}
TooltipComponentGenerated.ɵfac = function TooltipComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
TooltipComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: TooltipComponentGenerated, inputs: { background: "background", border: "border", color: "color", font: "font", format: "format", opacity: "opacity", padding: "padding", shared: "shared", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], TooltipComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TooltipComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TooltipComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TooltipComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], TooltipComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], TooltipComponentGenerated.prototype, "opacity", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], TooltipComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TooltipComponentGenerated.prototype, "shared", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], TooltipComponentGenerated.prototype, "visible", void 0);

/**
 * The configuration options of the Chart series tooltip
 * ([see example]({% slug tooltips_chart_charts %})).
 */
let TooltipComponent = class TooltipComponent extends TooltipComponentGenerated {
    constructor(configurationService, templateService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.templateService = templateService;
        this.markAsVisible();
    }
    ngAfterContentChecked() {
        this.templateService.setTemplate(this.seriesTooltipTemplate ? this.seriesTooltipTemplate.templateRef : null);
        this.templateService.setSharedTemplate(this.sharedTooltipTemplate ? this.sharedTooltipTemplate.templateRef : null);
    }
};
TooltipComponent.ɵfac = function TooltipComponent_Factory(t) { return new (t || TooltipComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(TooltipTemplateService)); };
TooltipComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TooltipComponent, selectors: [["kendo-chart-tooltip"]], contentQueries: function TooltipComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, SeriesTooltipTemplateDirective, 1);
        ɵngcc0.ɵɵcontentQuery(dirIndex, SharedTooltipTemplateDirective, 1);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.seriesTooltipTemplate = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.sharedTooltipTemplate = _t.first);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function TooltipComponent_Template(rf, ctx) { }, encapsulation: 2 });
__decorate([
    ContentChild(SeriesTooltipTemplateDirective, { static: false }),
    __metadata("design:type", SeriesTooltipTemplateDirective)
], TooltipComponent.prototype, "seriesTooltipTemplate", void 0);
__decorate([
    ContentChild(SharedTooltipTemplateDirective, { static: false }),
    __metadata("design:type", SharedTooltipTemplateDirective)
], TooltipComponent.prototype, "sharedTooltipTemplate", void 0);
TooltipComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        TooltipTemplateService])
], TooltipComponent);

/**
 * @hidden
 */
class ValueAxisItemComponentGenerated extends CollectionItemComponent {
    constructor(configurationService, collectionService) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
}
ValueAxisItemComponentGenerated.ɵfac = function ValueAxisItemComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
ValueAxisItemComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ValueAxisItemComponentGenerated, inputs: { axisCrossingValue: "axisCrossingValue", background: "background", color: "color", line: "line", majorGridLines: "majorGridLines", majorTicks: "majorTicks", majorUnit: "majorUnit", max: "max", min: "min", minorGridLines: "minorGridLines", minorTicks: "minorTicks", minorUnit: "minorUnit", name: "name", narrowRange: "narrowRange", pane: "pane", plotBands: "plotBands", reverse: "reverse", type: "type", visible: "visible", crosshair: "crosshair", labels: "labels", notes: "notes", title: "title" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisItemComponentGenerated.prototype, "axisCrossingValue", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisItemComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisItemComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisItemComponentGenerated.prototype, "line", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisItemComponentGenerated.prototype, "majorGridLines", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisItemComponentGenerated.prototype, "majorTicks", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ValueAxisItemComponentGenerated.prototype, "majorUnit", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisItemComponentGenerated.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisItemComponentGenerated.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisItemComponentGenerated.prototype, "minorGridLines", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisItemComponentGenerated.prototype, "minorTicks", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ValueAxisItemComponentGenerated.prototype, "minorUnit", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisItemComponentGenerated.prototype, "name", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ValueAxisItemComponentGenerated.prototype, "narrowRange", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisItemComponentGenerated.prototype, "pane", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], ValueAxisItemComponentGenerated.prototype, "plotBands", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ValueAxisItemComponentGenerated.prototype, "reverse", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisItemComponentGenerated.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ValueAxisItemComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisItemComponentGenerated.prototype, "crosshair", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisItemComponentGenerated.prototype, "labels", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisItemComponentGenerated.prototype, "notes", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisItemComponentGenerated.prototype, "title", void 0);

/**
 * The configuration component for a value axis.
 */
let ValueAxisItemComponent = class ValueAxisItemComponent extends ValueAxisItemComponentGenerated {
    // Place custom properties here
    constructor(configurationService, collectionService) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
};
ValueAxisItemComponent.ɵfac = function ValueAxisItemComponent_Factory(t) { return new (t || ValueAxisItemComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionService)); };
ValueAxisItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ValueAxisItemComponent, selectors: [["kendo-chart-value-axis-item"]], features: [ɵngcc0.ɵɵProvidersFeature([ConfigurationService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ValueAxisItemComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
ValueAxisItemComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        CollectionService])
], ValueAxisItemComponent);

/**
 * @hidden
 */
class ValueAxisComponentGenerated extends CollectionComponent {
    constructor(configurationService, collectionService) {
        super('valueAxis', configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
}
ValueAxisComponentGenerated.ɵfac = function ValueAxisComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
ValueAxisComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ValueAxisComponentGenerated, contentQueries: function ValueAxisComponentGenerated_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, ValueAxisItemComponent, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    ContentChildren(ValueAxisItemComponent),
    __metadata("design:type", QueryList)
], ValueAxisComponentGenerated.prototype, "children", void 0);

/**
 * A collection of one or more value axis configuration components.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-chart>
 *       <kendo-chart-value-axis>
 *         <kendo-chart-value-axis-item>
 *         </kendo-chart-value-axis-item>
 *         <kendo-chart-value-axis-item name="secondAxis">
 *         </kendo-chart-value-axis-item>
 *       </kendo-chart-value-axis>
 *       <kendo-chart-series>
 *         <kendo-chart-series-item type="line" [data]="[1, 2, 3]">
 *         </kendo-chart-series-item>
 *         <kendo-chart-series-item type="line" [data]="[0.1, 0.2, 0.3]"
 *                                  axis="secondAxis">
 *         </kendo-chart-series-item>
 *       </kendo-chart-series>
 *     </kendo-chart>
 *   `
 * })
 * class AppComponent {
 * }
 *
 * ```
 */
let ValueAxisComponent = class ValueAxisComponent extends ValueAxisComponentGenerated {
    // Place custom properties here
    constructor(configurationService, collectionService) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
};
ValueAxisComponent.ɵfac = function ValueAxisComponent_Factory(t) { return new (t || ValueAxisComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionService)); };
ValueAxisComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ValueAxisComponent, selectors: [["kendo-chart-value-axis"]], features: [ɵngcc0.ɵɵProvidersFeature([CollectionService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ValueAxisComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
ValueAxisComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        CollectionService])
], ValueAxisComponent);

/**
 * @hidden
 */
class ValueAxisCrosshairComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('crosshair', configurationService);
        this.configurationService = configurationService;
    }
}
ValueAxisCrosshairComponentGenerated.ɵfac = function ValueAxisCrosshairComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
ValueAxisCrosshairComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ValueAxisCrosshairComponentGenerated, inputs: { color: "color", opacity: "opacity", visible: "visible", width: "width", tooltip: "tooltip" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisCrosshairComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ValueAxisCrosshairComponentGenerated.prototype, "opacity", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ValueAxisCrosshairComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ValueAxisCrosshairComponentGenerated.prototype, "width", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisCrosshairComponentGenerated.prototype, "tooltip", void 0);

/**
 * The crosshair configuration options ([see example]({% slug crosshairs_chart_charts %})).
 */
let ValueAxisCrosshairComponent = class ValueAxisCrosshairComponent extends ValueAxisCrosshairComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
};
ValueAxisCrosshairComponent.ɵfac = function ValueAxisCrosshairComponent_Factory(t) { return new (t || ValueAxisCrosshairComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
ValueAxisCrosshairComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ValueAxisCrosshairComponent, selectors: [["kendo-chart-value-axis-item-crosshair"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ValueAxisCrosshairComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
ValueAxisCrosshairComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], ValueAxisCrosshairComponent);

/**
 * @hidden
 */
class ValueAxisCrosshairTooltipComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('crosshair.tooltip', configurationService);
        this.configurationService = configurationService;
    }
}
ValueAxisCrosshairTooltipComponentGenerated.ɵfac = function ValueAxisCrosshairTooltipComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
ValueAxisCrosshairTooltipComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ValueAxisCrosshairTooltipComponentGenerated, inputs: { background: "background", border: "border", color: "color", font: "font", format: "format", padding: "padding", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisCrosshairTooltipComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisCrosshairTooltipComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisCrosshairTooltipComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisCrosshairTooltipComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisCrosshairTooltipComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisCrosshairTooltipComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ValueAxisCrosshairTooltipComponentGenerated.prototype, "visible", void 0);

/**
 * The configuration options of the crosshair tooltip ([see example]({% slug crosshairs_chart_charts %})).
 * The crosshair tooltip is displayed when the `visible` option is set to `true`.
 */
let ValueAxisCrosshairTooltipComponent = class ValueAxisCrosshairTooltipComponent extends ValueAxisCrosshairTooltipComponentGenerated {
    // Place custom properties here.
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
};
ValueAxisCrosshairTooltipComponent.ɵfac = function ValueAxisCrosshairTooltipComponent_Factory(t) { return new (t || ValueAxisCrosshairTooltipComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
ValueAxisCrosshairTooltipComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ValueAxisCrosshairTooltipComponent, selectors: [["kendo-chart-value-axis-item-crosshair-tooltip"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ValueAxisCrosshairTooltipComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
ValueAxisCrosshairTooltipComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], ValueAxisCrosshairTooltipComponent);

/**
 * @hidden
 */
class ValueAxisLabelsComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('labels', configurationService);
        this.configurationService = configurationService;
    }
}
ValueAxisLabelsComponentGenerated.ɵfac = function ValueAxisLabelsComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
ValueAxisLabelsComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ValueAxisLabelsComponentGenerated, inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", margin: "margin", mirror: "mirror", padding: "padding", position: "position", rotation: "rotation", skip: "skip", step: "step", visible: "visible", visual: "visual" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisLabelsComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisLabelsComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisLabelsComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], ValueAxisLabelsComponentGenerated.prototype, "content", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisLabelsComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisLabelsComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisLabelsComponentGenerated.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ValueAxisLabelsComponentGenerated.prototype, "mirror", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisLabelsComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisLabelsComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisLabelsComponentGenerated.prototype, "rotation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ValueAxisLabelsComponentGenerated.prototype, "skip", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ValueAxisLabelsComponentGenerated.prototype, "step", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ValueAxisLabelsComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], ValueAxisLabelsComponentGenerated.prototype, "visual", void 0);

/**
 * The axis labels configuration.
 */
let ValueAxisLabelsComponent = class ValueAxisLabelsComponent extends ValueAxisLabelsComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
ValueAxisLabelsComponent.ɵfac = function ValueAxisLabelsComponent_Factory(t) { return new (t || ValueAxisLabelsComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
ValueAxisLabelsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ValueAxisLabelsComponent, selectors: [["kendo-chart-value-axis-item-labels"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ValueAxisLabelsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
ValueAxisLabelsComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], ValueAxisLabelsComponent);

/**
 * @hidden
 */
class ValueAxisNotesComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('notes', configurationService);
        this.configurationService = configurationService;
    }
}
ValueAxisNotesComponentGenerated.ɵfac = function ValueAxisNotesComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
ValueAxisNotesComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ValueAxisNotesComponentGenerated, inputs: { data: "data", line: "line", position: "position", visual: "visual", icon: "icon", label: "label" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", Array)
], ValueAxisNotesComponentGenerated.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisNotesComponentGenerated.prototype, "line", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisNotesComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], ValueAxisNotesComponentGenerated.prototype, "visual", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisNotesComponentGenerated.prototype, "icon", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisNotesComponentGenerated.prototype, "label", void 0);

/**
 * The configuration of the value axis notes ([see example]({% slug notes_chart_charts %}#toc-axis-notes)).
 */
let ValueAxisNotesComponent = class ValueAxisNotesComponent extends ValueAxisNotesComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
ValueAxisNotesComponent.ɵfac = function ValueAxisNotesComponent_Factory(t) { return new (t || ValueAxisNotesComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
ValueAxisNotesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ValueAxisNotesComponent, selectors: [["kendo-chart-value-axis-item-notes"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ValueAxisNotesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
ValueAxisNotesComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], ValueAxisNotesComponent);

/**
 * @hidden
 */
class ValueAxisNotesIconComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('notes.icon', configurationService);
        this.configurationService = configurationService;
    }
}
ValueAxisNotesIconComponentGenerated.ɵfac = function ValueAxisNotesIconComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
ValueAxisNotesIconComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ValueAxisNotesIconComponentGenerated, inputs: { background: "background", border: "border", size: "size", type: "type", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisNotesIconComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisNotesIconComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ValueAxisNotesIconComponentGenerated.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisNotesIconComponentGenerated.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ValueAxisNotesIconComponentGenerated.prototype, "visible", void 0);

/**
 * The icon of the notes.
 */
let ValueAxisNotesIconComponent = class ValueAxisNotesIconComponent extends ValueAxisNotesIconComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
ValueAxisNotesIconComponent.ɵfac = function ValueAxisNotesIconComponent_Factory(t) { return new (t || ValueAxisNotesIconComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
ValueAxisNotesIconComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ValueAxisNotesIconComponent, selectors: [["kendo-chart-value-axis-item-notes-icon"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ValueAxisNotesIconComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
ValueAxisNotesIconComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], ValueAxisNotesIconComponent);

/**
 * @hidden
 */
class ValueAxisNotesLabelComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('notes.label', configurationService);
        this.configurationService = configurationService;
    }
}
ValueAxisNotesLabelComponentGenerated.ɵfac = function ValueAxisNotesLabelComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
ValueAxisNotesLabelComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ValueAxisNotesLabelComponentGenerated, inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", position: "position", rotation: "rotation", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisNotesLabelComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisNotesLabelComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisNotesLabelComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], ValueAxisNotesLabelComponentGenerated.prototype, "content", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisNotesLabelComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisNotesLabelComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisNotesLabelComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ValueAxisNotesLabelComponentGenerated.prototype, "rotation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ValueAxisNotesLabelComponentGenerated.prototype, "visible", void 0);

/**
 * The label of the notes.
 */
let ValueAxisNotesLabelComponent = class ValueAxisNotesLabelComponent extends ValueAxisNotesLabelComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
ValueAxisNotesLabelComponent.ɵfac = function ValueAxisNotesLabelComponent_Factory(t) { return new (t || ValueAxisNotesLabelComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
ValueAxisNotesLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ValueAxisNotesLabelComponent, selectors: [["kendo-chart-value-axis-item-notes-label"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ValueAxisNotesLabelComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
ValueAxisNotesLabelComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], ValueAxisNotesLabelComponent);

/**
 * @hidden
 */
class ValueAxisTitleComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('title', configurationService);
        this.configurationService = configurationService;
    }
}
ValueAxisTitleComponentGenerated.ɵfac = function ValueAxisTitleComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
ValueAxisTitleComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ValueAxisTitleComponentGenerated, inputs: { background: "background", border: "border", color: "color", font: "font", margin: "margin", padding: "padding", position: "position", rotation: "rotation", text: "text", visible: "visible", visual: "visual" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisTitleComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisTitleComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisTitleComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisTitleComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisTitleComponentGenerated.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ValueAxisTitleComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisTitleComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], ValueAxisTitleComponentGenerated.prototype, "rotation", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], ValueAxisTitleComponentGenerated.prototype, "text", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], ValueAxisTitleComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], ValueAxisTitleComponentGenerated.prototype, "visual", void 0);

/**
 * The title configuration of the value axis.
 */
let ValueAxisTitleComponent = class ValueAxisTitleComponent extends ValueAxisTitleComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
ValueAxisTitleComponent.ɵfac = function ValueAxisTitleComponent_Factory(t) { return new (t || ValueAxisTitleComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
ValueAxisTitleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ValueAxisTitleComponent, selectors: [["kendo-chart-value-axis-item-title"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ValueAxisTitleComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
ValueAxisTitleComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], ValueAxisTitleComponent);

/**
 * @hidden
 */
class XAxisItemComponentGenerated extends CollectionItemComponent {
    constructor(configurationService, collectionService, intl, localeId) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
        this.notifyChanges({ weekStartDay: intl.firstDay(localeId) });
    }
}
XAxisItemComponentGenerated.ɵfac = function XAxisItemComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
XAxisItemComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: XAxisItemComponentGenerated, inputs: { axisCrossingValue: "axisCrossingValue", background: "background", baseUnit: "baseUnit", color: "color", line: "line", majorGridLines: "majorGridLines", majorTicks: "majorTicks", majorUnit: "majorUnit", max: "max", min: "min", minorGridLines: "minorGridLines", minorTicks: "minorTicks", minorUnit: "minorUnit", name: "name", narrowRange: "narrowRange", pane: "pane", plotBands: "plotBands", reverse: "reverse", startAngle: "startAngle", type: "type", visible: "visible", weekStartDay: "weekStartDay", crosshair: "crosshair", labels: "labels", notes: "notes", title: "title" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisItemComponentGenerated.prototype, "axisCrossingValue", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisItemComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisItemComponentGenerated.prototype, "baseUnit", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisItemComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisItemComponentGenerated.prototype, "line", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisItemComponentGenerated.prototype, "majorGridLines", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisItemComponentGenerated.prototype, "majorTicks", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], XAxisItemComponentGenerated.prototype, "majorUnit", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisItemComponentGenerated.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisItemComponentGenerated.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisItemComponentGenerated.prototype, "minorGridLines", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisItemComponentGenerated.prototype, "minorTicks", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], XAxisItemComponentGenerated.prototype, "minorUnit", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisItemComponentGenerated.prototype, "name", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], XAxisItemComponentGenerated.prototype, "narrowRange", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisItemComponentGenerated.prototype, "pane", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], XAxisItemComponentGenerated.prototype, "plotBands", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], XAxisItemComponentGenerated.prototype, "reverse", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], XAxisItemComponentGenerated.prototype, "startAngle", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisItemComponentGenerated.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], XAxisItemComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], XAxisItemComponentGenerated.prototype, "weekStartDay", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisItemComponentGenerated.prototype, "crosshair", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisItemComponentGenerated.prototype, "labels", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisItemComponentGenerated.prototype, "notes", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisItemComponentGenerated.prototype, "title", void 0);

/**
 * The configuration component for an X axis
 * ([see example]({% slug api_charts_xaxiscomponent %})).
 */
let XAxisItemComponent = class XAxisItemComponent extends XAxisItemComponentGenerated {
    constructor(configurationService, collectionService, intl, localeId) {
        super(configurationService, collectionService, intl, localeId);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
        this.intl = intl;
    }
};
XAxisItemComponent.ɵfac = function XAxisItemComponent_Factory(t) { return new (t || XAxisItemComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionService), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.IntlService), ɵngcc0.ɵɵdirectiveInject(LOCALE_ID)); };
XAxisItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: XAxisItemComponent, selectors: [["kendo-chart-x-axis-item"]], inputs: { categories: "categories" }, features: [ɵngcc0.ɵɵProvidersFeature([ConfigurationService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function XAxisItemComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", Array)
], XAxisItemComponent.prototype, "categories", void 0);
XAxisItemComponent = __decorate([ __param(3, Inject(LOCALE_ID)),
    __metadata("design:paramtypes", [ConfigurationService,
        CollectionService,
        IntlService, String])
], XAxisItemComponent);

/**
 * @hidden
 */
class XAxisComponentGenerated extends CollectionComponent {
    constructor(configurationService, collectionService) {
        super('xAxis', configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
}
XAxisComponentGenerated.ɵfac = function XAxisComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
XAxisComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: XAxisComponentGenerated, contentQueries: function XAxisComponentGenerated_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, XAxisItemComponent, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    ContentChildren(XAxisItemComponent),
    __metadata("design:type", QueryList)
], XAxisComponentGenerated.prototype, "children", void 0);

/**
 * A collection of one or more X-axis configuration components.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *  selector: 'my-app',
 * template: `
 *   <kendo-chart>
 *     <kendo-chart-x-axis>
 *       <kendo-chart-x-axis-item
 *         [background]="'rgba(100, 100, 100, 0.2)'"
 *         color="red"
 *         [notes]="notesConfig"
 *         [crosshair]="crosshairConfig">
 *       </kendo-chart-x-axis-item>
 *       <kendo-chart-x-axis-item name="secondAxis">
 *       </kendo-chart-x-axis-item>
 *     </kendo-chart-x-axis>
 *     <kendo-chart-series>
 *       <kendo-chart-series-item type="scatter" [data]="[[1, 2]]">
 *       </kendo-chart-series-item>
 *       <kendo-chart-series-item type="scatter" [data]="[[0.1, 0.2]]"
 *                                xAxis="secondAxis">
 *       </kendo-chart-series-item>
 *     </kendo-chart-series>
 *   </kendo-chart>
 * `
 * })
 * export class AppComponent {
 * public notesConfig = {
 *   data: [{
 *       value: 0.2,
 *       text: "foo"
 *     }, {
 *       value: 0.8,
 *       text: "bar"
 *     }],
 *   label: {
 *     content: (args: any) => args.dataItem.text,
 *     background: 'red',
 *     color: 'white'
 *   },
 *   line: {
 *     color: 'blue',
 *     dashType: 'dash',
 *     length: 150,
 *     width: 2
 *   },
 *   position: 'top'
 * };
 *
 * public crosshairConfig = {
 *   color: 'green',
 *   opacity: 0.8,
 *   visible: true,
 *   width: 3
 * };
 * }
 *
 * ```
 */
let XAxisComponent = class XAxisComponent extends XAxisComponentGenerated {
    // Place custom properties here
    constructor(configurationService, collectionService) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
};
XAxisComponent.ɵfac = function XAxisComponent_Factory(t) { return new (t || XAxisComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionService)); };
XAxisComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: XAxisComponent, selectors: [["kendo-chart-x-axis"]], features: [ɵngcc0.ɵɵProvidersFeature([CollectionService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function XAxisComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
XAxisComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        CollectionService])
], XAxisComponent);

/**
 * @hidden
 */
class XAxisCrosshairComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('crosshair', configurationService);
        this.configurationService = configurationService;
    }
}
XAxisCrosshairComponentGenerated.ɵfac = function XAxisCrosshairComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
XAxisCrosshairComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: XAxisCrosshairComponentGenerated, inputs: { color: "color", opacity: "opacity", visible: "visible", width: "width", tooltip: "tooltip" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisCrosshairComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], XAxisCrosshairComponentGenerated.prototype, "opacity", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], XAxisCrosshairComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], XAxisCrosshairComponentGenerated.prototype, "width", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisCrosshairComponentGenerated.prototype, "tooltip", void 0);

/**
 * The crosshair configuration options
 * ([see example]({% slug api_charts_xaxiscomponent %})).
 */
let XAxisCrosshairComponent = class XAxisCrosshairComponent extends XAxisCrosshairComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
};
XAxisCrosshairComponent.ɵfac = function XAxisCrosshairComponent_Factory(t) { return new (t || XAxisCrosshairComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
XAxisCrosshairComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: XAxisCrosshairComponent, selectors: [["kendo-chart-x-axis-item-crosshair"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function XAxisCrosshairComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
XAxisCrosshairComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], XAxisCrosshairComponent);

/**
 * @hidden
 */
class XAxisCrosshairTooltipComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('crosshair.tooltip', configurationService);
        this.configurationService = configurationService;
    }
}
XAxisCrosshairTooltipComponentGenerated.ɵfac = function XAxisCrosshairTooltipComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
XAxisCrosshairTooltipComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: XAxisCrosshairTooltipComponentGenerated, inputs: { background: "background", border: "border", color: "color", font: "font", format: "format", padding: "padding", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisCrosshairTooltipComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisCrosshairTooltipComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisCrosshairTooltipComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisCrosshairTooltipComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisCrosshairTooltipComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisCrosshairTooltipComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], XAxisCrosshairTooltipComponentGenerated.prototype, "visible", void 0);

/**
 * The configuration options of the crosshair tooltip.
 * The crosshair tooltip is displayed when the `visible` option is set to `true`.
 */
let XAxisCrosshairTooltipComponent = class XAxisCrosshairTooltipComponent extends XAxisCrosshairTooltipComponentGenerated {
    // Place custom properties here.
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
};
XAxisCrosshairTooltipComponent.ɵfac = function XAxisCrosshairTooltipComponent_Factory(t) { return new (t || XAxisCrosshairTooltipComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
XAxisCrosshairTooltipComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: XAxisCrosshairTooltipComponent, selectors: [["kendo-chart-x-axis-item-crosshair-tooltip"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function XAxisCrosshairTooltipComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
XAxisCrosshairTooltipComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], XAxisCrosshairTooltipComponent);

/**
 * @hidden
 */
class XAxisLabelsComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('labels', configurationService);
        this.configurationService = configurationService;
    }
}
XAxisLabelsComponentGenerated.ɵfac = function XAxisLabelsComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
XAxisLabelsComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: XAxisLabelsComponentGenerated, inputs: { background: "background", border: "border", color: "color", content: "content", culture: "culture", dateFormats: "dateFormats", font: "font", format: "format", margin: "margin", mirror: "mirror", padding: "padding", position: "position", rotation: "rotation", skip: "skip", step: "step", visible: "visible", visual: "visual" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisLabelsComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisLabelsComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisLabelsComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], XAxisLabelsComponentGenerated.prototype, "content", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisLabelsComponentGenerated.prototype, "culture", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisLabelsComponentGenerated.prototype, "dateFormats", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisLabelsComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisLabelsComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisLabelsComponentGenerated.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], XAxisLabelsComponentGenerated.prototype, "mirror", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisLabelsComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisLabelsComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisLabelsComponentGenerated.prototype, "rotation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], XAxisLabelsComponentGenerated.prototype, "skip", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], XAxisLabelsComponentGenerated.prototype, "step", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], XAxisLabelsComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], XAxisLabelsComponentGenerated.prototype, "visual", void 0);

/**
 * The axis labels configuration.
 */
let XAxisLabelsComponent = class XAxisLabelsComponent extends XAxisLabelsComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
XAxisLabelsComponent.ɵfac = function XAxisLabelsComponent_Factory(t) { return new (t || XAxisLabelsComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
XAxisLabelsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: XAxisLabelsComponent, selectors: [["kendo-chart-x-axis-item-labels"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function XAxisLabelsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
XAxisLabelsComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], XAxisLabelsComponent);

/**
 * @hidden
 */
class XAxisNotesComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('notes', configurationService);
        this.configurationService = configurationService;
    }
}
XAxisNotesComponentGenerated.ɵfac = function XAxisNotesComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
XAxisNotesComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: XAxisNotesComponentGenerated, inputs: { data: "data", line: "line", position: "position", visual: "visual", icon: "icon", label: "label" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", Array)
], XAxisNotesComponentGenerated.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisNotesComponentGenerated.prototype, "line", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisNotesComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], XAxisNotesComponentGenerated.prototype, "visual", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisNotesComponentGenerated.prototype, "icon", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisNotesComponentGenerated.prototype, "label", void 0);

/**
 * The configuration of the X-axis notes.
 * For an example on the basic usage of the XAxisNotesComponent,
 * refer to the [demo on the XAxisComponent]({% slug api_charts_xaxiscomponent %})
 * or to the documentation about the
 * [axis notes]({% slug notes_chart_charts %}#toc-axis-notes).
 */
let XAxisNotesComponent = class XAxisNotesComponent extends XAxisNotesComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
XAxisNotesComponent.ɵfac = function XAxisNotesComponent_Factory(t) { return new (t || XAxisNotesComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
XAxisNotesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: XAxisNotesComponent, selectors: [["kendo-chart-x-axis-item-notes"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function XAxisNotesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
XAxisNotesComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], XAxisNotesComponent);

/**
 * @hidden
 */
class XAxisNotesIconComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('notes.icon', configurationService);
        this.configurationService = configurationService;
    }
}
XAxisNotesIconComponentGenerated.ɵfac = function XAxisNotesIconComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
XAxisNotesIconComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: XAxisNotesIconComponentGenerated, inputs: { background: "background", border: "border", size: "size", type: "type", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisNotesIconComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisNotesIconComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], XAxisNotesIconComponentGenerated.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisNotesIconComponentGenerated.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], XAxisNotesIconComponentGenerated.prototype, "visible", void 0);

/**
 * The icon of the notes.
 */
let XAxisNotesIconComponent = class XAxisNotesIconComponent extends XAxisNotesIconComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
XAxisNotesIconComponent.ɵfac = function XAxisNotesIconComponent_Factory(t) { return new (t || XAxisNotesIconComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
XAxisNotesIconComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: XAxisNotesIconComponent, selectors: [["kendo-chart-x-axis-item-notes-icon"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function XAxisNotesIconComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
XAxisNotesIconComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], XAxisNotesIconComponent);

/**
 * @hidden
 */
class XAxisNotesLabelComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('notes.label', configurationService);
        this.configurationService = configurationService;
    }
}
XAxisNotesLabelComponentGenerated.ɵfac = function XAxisNotesLabelComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
XAxisNotesLabelComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: XAxisNotesLabelComponentGenerated, inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", position: "position", rotation: "rotation", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisNotesLabelComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisNotesLabelComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisNotesLabelComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], XAxisNotesLabelComponentGenerated.prototype, "content", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisNotesLabelComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisNotesLabelComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisNotesLabelComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], XAxisNotesLabelComponentGenerated.prototype, "rotation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], XAxisNotesLabelComponentGenerated.prototype, "visible", void 0);

/**
 * The label of the notes.
 */
let XAxisNotesLabelComponent = class XAxisNotesLabelComponent extends XAxisNotesLabelComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
XAxisNotesLabelComponent.ɵfac = function XAxisNotesLabelComponent_Factory(t) { return new (t || XAxisNotesLabelComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
XAxisNotesLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: XAxisNotesLabelComponent, selectors: [["kendo-chart-x-axis-item-notes-label"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function XAxisNotesLabelComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
XAxisNotesLabelComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], XAxisNotesLabelComponent);

/**
 * @hidden
 */
class XAxisTitleComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('title', configurationService);
        this.configurationService = configurationService;
    }
}
XAxisTitleComponentGenerated.ɵfac = function XAxisTitleComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
XAxisTitleComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: XAxisTitleComponentGenerated, inputs: { background: "background", border: "border", color: "color", font: "font", margin: "margin", padding: "padding", position: "position", rotation: "rotation", text: "text", visible: "visible", visual: "visual" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisTitleComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisTitleComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisTitleComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisTitleComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisTitleComponentGenerated.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], XAxisTitleComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisTitleComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], XAxisTitleComponentGenerated.prototype, "rotation", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], XAxisTitleComponentGenerated.prototype, "text", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], XAxisTitleComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], XAxisTitleComponentGenerated.prototype, "visual", void 0);

/**
 * The title configuration of the Scatter Chart X axis.
 */
let XAxisTitleComponent = class XAxisTitleComponent extends XAxisTitleComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
XAxisTitleComponent.ɵfac = function XAxisTitleComponent_Factory(t) { return new (t || XAxisTitleComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
XAxisTitleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: XAxisTitleComponent, selectors: [["kendo-chart-x-axis-item-title"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function XAxisTitleComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
XAxisTitleComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], XAxisTitleComponent);

/**
 * @hidden
 */
class YAxisItemComponentGenerated extends CollectionItemComponent {
    constructor(configurationService, collectionService) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
}
YAxisItemComponentGenerated.ɵfac = function YAxisItemComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
YAxisItemComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: YAxisItemComponentGenerated, inputs: { axisCrossingValue: "axisCrossingValue", background: "background", baseUnit: "baseUnit", color: "color", line: "line", majorGridLines: "majorGridLines", majorTicks: "majorTicks", majorUnit: "majorUnit", max: "max", min: "min", minorGridLines: "minorGridLines", minorTicks: "minorTicks", minorUnit: "minorUnit", name: "name", narrowRange: "narrowRange", pane: "pane", plotBands: "plotBands", reverse: "reverse", type: "type", visible: "visible", crosshair: "crosshair", labels: "labels", notes: "notes", title: "title" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisItemComponentGenerated.prototype, "axisCrossingValue", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisItemComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisItemComponentGenerated.prototype, "baseUnit", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisItemComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisItemComponentGenerated.prototype, "line", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisItemComponentGenerated.prototype, "majorGridLines", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisItemComponentGenerated.prototype, "majorTicks", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], YAxisItemComponentGenerated.prototype, "majorUnit", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisItemComponentGenerated.prototype, "max", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisItemComponentGenerated.prototype, "min", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisItemComponentGenerated.prototype, "minorGridLines", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisItemComponentGenerated.prototype, "minorTicks", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], YAxisItemComponentGenerated.prototype, "minorUnit", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisItemComponentGenerated.prototype, "name", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], YAxisItemComponentGenerated.prototype, "narrowRange", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisItemComponentGenerated.prototype, "pane", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], YAxisItemComponentGenerated.prototype, "plotBands", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], YAxisItemComponentGenerated.prototype, "reverse", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisItemComponentGenerated.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], YAxisItemComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisItemComponentGenerated.prototype, "crosshair", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisItemComponentGenerated.prototype, "labels", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisItemComponentGenerated.prototype, "notes", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisItemComponentGenerated.prototype, "title", void 0);

/**
 * The configuration component for the Y axis
 * ([see example]({% slug api_charts_yaxiscomponent %})).
 */
let YAxisItemComponent = class YAxisItemComponent extends YAxisItemComponentGenerated {
    constructor(configurationService, collectionService) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
};
YAxisItemComponent.ɵfac = function YAxisItemComponent_Factory(t) { return new (t || YAxisItemComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionService)); };
YAxisItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: YAxisItemComponent, selectors: [["kendo-chart-y-axis-item"]], inputs: { categories: "categories" }, features: [ɵngcc0.ɵɵProvidersFeature([ConfigurationService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function YAxisItemComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", Array)
], YAxisItemComponent.prototype, "categories", void 0);
YAxisItemComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        CollectionService])
], YAxisItemComponent);

/**
 * @hidden
 */
class YAxisComponentGenerated extends CollectionComponent {
    constructor(configurationService, collectionService) {
        super('yAxis', configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
}
YAxisComponentGenerated.ɵfac = function YAxisComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
YAxisComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: YAxisComponentGenerated, contentQueries: function YAxisComponentGenerated_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, YAxisItemComponent, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    ContentChildren(YAxisItemComponent),
    __metadata("design:type", QueryList)
], YAxisComponentGenerated.prototype, "children", void 0);

/**
 * A collection of one or more Y-axis configuration components.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *  selector: 'my-app',
 *  template: `
 *    <kendo-chart>
 *     <kendo-chart-y-axis>
 *       <kendo-chart-y-axis-item
 *         [background]="'rgba(100, 100, 100, 0.2)'"
 *         color="red"
 *         [notes]="notesConfig"
 *         [crosshair]="crosshairConfig">
 *       </kendo-chart-y-axis-item>
 *       <kendo-chart-y-axis-item name="secondAxis">
 *       </kendo-chart-y-axis-item>
 *     </kendo-chart-y-axis>
 *     <kendo-chart-series>
 *       <kendo-chart-series-item type="scatter" [data]="[[1, 2]]">
 *       </kendo-chart-series-item>
 *       <kendo-chart-series-item type="scatter" [data]="[[0.1, 0.2]]"
 *                                yAxis="secondAxis">
 *       </kendo-chart-series-item>
 *     </kendo-chart-series>
 *   </kendo-chart>
 * `
 * })
 * export class AppComponent {
 * public notesConfig = {
 *   data: [{
 *       value: 0.2,
 *       text: "foo"
 *     }, {
 *       value: 0.8,
 *       text: "bar"
 *     }],
 *    label: {
 *     content: (args: any) => args.dataItem.text,
 *     background: 'red',
 *     color: 'white'
 *   },
 *   line: {
 *     color: 'blue',
 *     dashType: 'dash',
 *     length: 150,
 *     width: 2
 *   },
 *   position: 'top'
 * };
 *
 * public crosshairConfig = {
 *   color: 'green',
 *   opacity: 0.8,
 *   visible: true,
 *   width: 3
 * };
 * }
 *
 * ```
 */
let YAxisComponent = class YAxisComponent extends YAxisComponentGenerated {
    // Place custom properties here
    constructor(configurationService, collectionService) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
};
YAxisComponent.ɵfac = function YAxisComponent_Factory(t) { return new (t || YAxisComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionService)); };
YAxisComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: YAxisComponent, selectors: [["kendo-chart-y-axis"]], features: [ɵngcc0.ɵɵProvidersFeature([CollectionService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function YAxisComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
YAxisComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        CollectionService])
], YAxisComponent);

/**
 * @hidden
 */
class YAxisCrosshairComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('crosshair', configurationService);
        this.configurationService = configurationService;
    }
}
YAxisCrosshairComponentGenerated.ɵfac = function YAxisCrosshairComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
YAxisCrosshairComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: YAxisCrosshairComponentGenerated, inputs: { color: "color", opacity: "opacity", visible: "visible", width: "width", tooltip: "tooltip" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisCrosshairComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], YAxisCrosshairComponentGenerated.prototype, "opacity", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], YAxisCrosshairComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], YAxisCrosshairComponentGenerated.prototype, "width", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisCrosshairComponentGenerated.prototype, "tooltip", void 0);

/**
 * The crosshair configuration options
 * ([see example]({% slug api_charts_yaxiscomponent %})).
 */
let YAxisCrosshairComponent = class YAxisCrosshairComponent extends YAxisCrosshairComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
};
YAxisCrosshairComponent.ɵfac = function YAxisCrosshairComponent_Factory(t) { return new (t || YAxisCrosshairComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
YAxisCrosshairComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: YAxisCrosshairComponent, selectors: [["kendo-chart-y-axis-item-crosshair"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function YAxisCrosshairComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
YAxisCrosshairComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], YAxisCrosshairComponent);

/**
 * @hidden
 */
class YAxisCrosshairTooltipComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('crosshair.tooltip', configurationService);
        this.configurationService = configurationService;
    }
}
YAxisCrosshairTooltipComponentGenerated.ɵfac = function YAxisCrosshairTooltipComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
YAxisCrosshairTooltipComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: YAxisCrosshairTooltipComponentGenerated, inputs: { background: "background", border: "border", color: "color", font: "font", format: "format", padding: "padding", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisCrosshairTooltipComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisCrosshairTooltipComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisCrosshairTooltipComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisCrosshairTooltipComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisCrosshairTooltipComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisCrosshairTooltipComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], YAxisCrosshairTooltipComponentGenerated.prototype, "visible", void 0);

/**
 * The configuration options of the crosshair tooltip.
 * The crosshair tooltip is displayed when the `visible` option is set to `true`.
 */
let YAxisCrosshairTooltipComponent = class YAxisCrosshairTooltipComponent extends YAxisCrosshairTooltipComponentGenerated {
    // Place custom properties here.
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
};
YAxisCrosshairTooltipComponent.ɵfac = function YAxisCrosshairTooltipComponent_Factory(t) { return new (t || YAxisCrosshairTooltipComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
YAxisCrosshairTooltipComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: YAxisCrosshairTooltipComponent, selectors: [["kendo-chart-y-axis-item-crosshair-tooltip"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function YAxisCrosshairTooltipComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
YAxisCrosshairTooltipComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], YAxisCrosshairTooltipComponent);

/**
 * @hidden
 */
class YAxisLabelsComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('labels', configurationService);
        this.configurationService = configurationService;
    }
}
YAxisLabelsComponentGenerated.ɵfac = function YAxisLabelsComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
YAxisLabelsComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: YAxisLabelsComponentGenerated, inputs: { background: "background", border: "border", color: "color", content: "content", culture: "culture", dateFormats: "dateFormats", font: "font", format: "format", margin: "margin", mirror: "mirror", padding: "padding", position: "position", rotation: "rotation", skip: "skip", step: "step", visible: "visible", visual: "visual" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisLabelsComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisLabelsComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisLabelsComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], YAxisLabelsComponentGenerated.prototype, "content", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisLabelsComponentGenerated.prototype, "culture", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisLabelsComponentGenerated.prototype, "dateFormats", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisLabelsComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisLabelsComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisLabelsComponentGenerated.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], YAxisLabelsComponentGenerated.prototype, "mirror", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisLabelsComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisLabelsComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisLabelsComponentGenerated.prototype, "rotation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], YAxisLabelsComponentGenerated.prototype, "skip", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], YAxisLabelsComponentGenerated.prototype, "step", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], YAxisLabelsComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], YAxisLabelsComponentGenerated.prototype, "visual", void 0);

/**
 * The axis labels configuration.
 */
let YAxisLabelsComponent = class YAxisLabelsComponent extends YAxisLabelsComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
YAxisLabelsComponent.ɵfac = function YAxisLabelsComponent_Factory(t) { return new (t || YAxisLabelsComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
YAxisLabelsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: YAxisLabelsComponent, selectors: [["kendo-chart-y-axis-item-labels"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function YAxisLabelsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
YAxisLabelsComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], YAxisLabelsComponent);

/**
 * @hidden
 */
class YAxisNotesComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('notes', configurationService);
        this.configurationService = configurationService;
    }
}
YAxisNotesComponentGenerated.ɵfac = function YAxisNotesComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
YAxisNotesComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: YAxisNotesComponentGenerated, inputs: { data: "data", line: "line", position: "position", visual: "visual", icon: "icon", label: "label" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", Array)
], YAxisNotesComponentGenerated.prototype, "data", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisNotesComponentGenerated.prototype, "line", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisNotesComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], YAxisNotesComponentGenerated.prototype, "visual", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisNotesComponentGenerated.prototype, "icon", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisNotesComponentGenerated.prototype, "label", void 0);

/**
 * The configuration of the Y axis notes
 * ([see example]({% slug api_charts_yaxiscomponent %})).
 */
let YAxisNotesComponent = class YAxisNotesComponent extends YAxisNotesComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
YAxisNotesComponent.ɵfac = function YAxisNotesComponent_Factory(t) { return new (t || YAxisNotesComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
YAxisNotesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: YAxisNotesComponent, selectors: [["kendo-chart-y-axis-item-notes"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function YAxisNotesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
YAxisNotesComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], YAxisNotesComponent);

/**
 * @hidden
 */
class YAxisNotesIconComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('notes.icon', configurationService);
        this.configurationService = configurationService;
    }
}
YAxisNotesIconComponentGenerated.ɵfac = function YAxisNotesIconComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
YAxisNotesIconComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: YAxisNotesIconComponentGenerated, inputs: { background: "background", border: "border", size: "size", type: "type", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisNotesIconComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisNotesIconComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], YAxisNotesIconComponentGenerated.prototype, "size", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisNotesIconComponentGenerated.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], YAxisNotesIconComponentGenerated.prototype, "visible", void 0);

/**
 * The icon of the notes.
 */
let YAxisNotesIconComponent = class YAxisNotesIconComponent extends YAxisNotesIconComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
YAxisNotesIconComponent.ɵfac = function YAxisNotesIconComponent_Factory(t) { return new (t || YAxisNotesIconComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
YAxisNotesIconComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: YAxisNotesIconComponent, selectors: [["kendo-chart-y-axis-item-notes-icon"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function YAxisNotesIconComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
YAxisNotesIconComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], YAxisNotesIconComponent);

/**
 * @hidden
 */
class YAxisNotesLabelComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('notes.label', configurationService);
        this.configurationService = configurationService;
    }
}
YAxisNotesLabelComponentGenerated.ɵfac = function YAxisNotesLabelComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
YAxisNotesLabelComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: YAxisNotesLabelComponentGenerated, inputs: { background: "background", border: "border", color: "color", content: "content", font: "font", format: "format", position: "position", rotation: "rotation", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisNotesLabelComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisNotesLabelComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisNotesLabelComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], YAxisNotesLabelComponentGenerated.prototype, "content", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisNotesLabelComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisNotesLabelComponentGenerated.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisNotesLabelComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], YAxisNotesLabelComponentGenerated.prototype, "rotation", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], YAxisNotesLabelComponentGenerated.prototype, "visible", void 0);

/**
 * The label of the notes.
 */
let YAxisNotesLabelComponent = class YAxisNotesLabelComponent extends YAxisNotesLabelComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
YAxisNotesLabelComponent.ɵfac = function YAxisNotesLabelComponent_Factory(t) { return new (t || YAxisNotesLabelComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
YAxisNotesLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: YAxisNotesLabelComponent, selectors: [["kendo-chart-y-axis-item-notes-label"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function YAxisNotesLabelComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
YAxisNotesLabelComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], YAxisNotesLabelComponent);

/**
 * @hidden
 */
class YAxisTitleComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('title', configurationService);
        this.configurationService = configurationService;
    }
}
YAxisTitleComponentGenerated.ɵfac = function YAxisTitleComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
YAxisTitleComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: YAxisTitleComponentGenerated, inputs: { background: "background", border: "border", color: "color", font: "font", margin: "margin", padding: "padding", position: "position", rotation: "rotation", text: "text", visible: "visible", visual: "visual" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisTitleComponentGenerated.prototype, "background", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisTitleComponentGenerated.prototype, "border", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisTitleComponentGenerated.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisTitleComponentGenerated.prototype, "font", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisTitleComponentGenerated.prototype, "margin", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], YAxisTitleComponentGenerated.prototype, "padding", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisTitleComponentGenerated.prototype, "position", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], YAxisTitleComponentGenerated.prototype, "rotation", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], YAxisTitleComponentGenerated.prototype, "text", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], YAxisTitleComponentGenerated.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Function)
], YAxisTitleComponentGenerated.prototype, "visual", void 0);

/**
 * The title configuration of the Scatter Chart Y axis.
 */
let YAxisTitleComponent = class YAxisTitleComponent extends YAxisTitleComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
YAxisTitleComponent.ɵfac = function YAxisTitleComponent_Factory(t) { return new (t || YAxisTitleComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
YAxisTitleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: YAxisTitleComponent, selectors: [["kendo-chart-y-axis-item-title"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function YAxisTitleComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
YAxisTitleComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], YAxisTitleComponent);

/**
 * @hidden
 */
class ZoomableComponentGenerated extends SettingsComponent {
    constructor(configurationService) {
        super('zoomable', configurationService);
        this.configurationService = configurationService;
    }
}
ZoomableComponentGenerated.ɵfac = function ZoomableComponentGenerated_Factory(t) { ɵngcc0.ɵɵinvalidFactory(); };
ZoomableComponentGenerated.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: ZoomableComponentGenerated, inputs: { mousewheel: "mousewheel", selection: "selection" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature] });
__decorate([
    Input(),
    __metadata("design:type", Object)
], ZoomableComponentGenerated.prototype, "mousewheel", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], ZoomableComponentGenerated.prototype, "selection", void 0);

/**
 * Specifies if the Chart can be zoomed.
 *
 * @example
 *
 * ```html-no-run
 * <kendo-chart>
 *   <kendo-chart-zoomable [mousewheel]="false"></kendo-chart-zoomable>
 * </kendo-chart>
 * ```
 */
let ZoomableComponent = class ZoomableComponent extends ZoomableComponentGenerated {
    // Place custom properties here
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
ZoomableComponent.ɵfac = function ZoomableComponent_Factory(t) { return new (t || ZoomableComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
ZoomableComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: ZoomableComponent, selectors: [["kendo-chart-zoomable"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function ZoomableComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
ZoomableComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], ZoomableComponent);

/**
 * @hidden
 */
const CHART_DIRECTIVES = [
    ChartComponent,
    TooltipPopupComponent,
    SeriesTooltipTemplateDirective,
    SharedTooltipTemplateDirective,
    CrosshairTooltipsContainerComponent,
    CrosshairTooltipComponent,
    DonutCenterTemplateDirective,
    AxisDefaultsComponent,
    AxisDefaultsCrosshairComponent,
    AxisDefaultsCrosshairTooltipComponent,
    AxisDefaultsLabelsComponent,
    AxisDefaultsTitleComponent,
    CategoryAxisComponent,
    CategoryAxisCrosshairComponent,
    CategoryAxisCrosshairTooltipComponent,
    CategoryAxisItemComponent,
    CategoryAxisLabelsComponent,
    CategoryAxisRangeLabelsComponent,
    CategoryAxisNotesComponent,
    CategoryAxisNotesIconComponent,
    CategoryAxisNotesLabelComponent,
    CategoryAxisSelectComponent,
    CategoryAxisTitleComponent,
    ChartAreaComponent,
    LegendComponent,
    LegendInactiveItemsComponent,
    LegendItemComponent,
    PaneComponent,
    PaneDefaultsComponent,
    PaneDefaultsTitleComponent,
    PanesComponent,
    PanesTitleComponent,
    PlotAreaComponent,
    SeriesComponent,
    SeriesDefaultsComponent,
    SeriesDefaultsLabelsComponent,
    SeriesDefaultsLabelsFromComponent,
    SeriesDefaultsLabelsToComponent,
    SeriesDefaultsNotesComponent,
    SeriesDefaultsNotesIconComponent,
    SeriesDefaultsNotesLabelComponent,
    SeriesDefaultsTooltipComponent,
    SeriesErrorBarsComponent,
    SeriesExtremesComponent,
    SeriesHighlightComponent,
    SeriesItemComponent,
    SeriesLabelsComponent,
    SeriesLabelsFromComponent,
    SeriesLabelsToComponent,
    SeriesMarkersComponent,
    SeriesNotesComponent,
    SeriesNotesIconComponent,
    SeriesNotesLabelComponent,
    SeriesOutliersComponent,
    SeriesTooltipComponent,
    TitleComponent,
    TooltipComponent,
    ValueAxisComponent,
    ValueAxisCrosshairComponent,
    ValueAxisCrosshairTooltipComponent,
    ValueAxisItemComponent,
    ValueAxisLabelsComponent,
    ValueAxisNotesComponent,
    ValueAxisNotesIconComponent,
    ValueAxisNotesLabelComponent,
    ValueAxisTitleComponent,
    XAxisComponent,
    XAxisCrosshairComponent,
    XAxisCrosshairTooltipComponent,
    XAxisItemComponent,
    XAxisLabelsComponent,
    XAxisNotesComponent,
    XAxisNotesIconComponent,
    XAxisNotesLabelComponent,
    XAxisTitleComponent,
    YAxisComponent,
    YAxisCrosshairComponent,
    YAxisCrosshairTooltipComponent,
    YAxisItemComponent,
    YAxisLabelsComponent,
    YAxisNotesComponent,
    YAxisNotesIconComponent,
    YAxisNotesLabelComponent,
    YAxisTitleComponent,
    ZoomableComponent
];

// Re-export event types

/**
 * The arguments for the `navigatorFilter` event.
 */
class NavigatorFilterEvent extends BaseEvent {
    /**
     * Constructs the event arguments from a raw object.
     */
    constructor(e, sender) {
        super(sender);
        this.from = e.from;
        this.to = e.to;
    }
}

// Re-export event types

/**
 * @hidden
 */
let RootConfigurationService = class RootConfigurationService extends ConfigurationService {
};
RootConfigurationService.ɵfac = function RootConfigurationService_Factory(t) { return ɵRootConfigurationService_BaseFactory(t || RootConfigurationService); };
RootConfigurationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: RootConfigurationService, factory: function (t) { return RootConfigurationService.ɵfac(t); } });

const EVENT_MAP$1 = {
    navigatorFilter: NavigatorFilterEvent
};
/**
 * @hidden
 */
class StockInstanceEventService extends InstanceEventService {
    create(name, args, sender) {
        if (EVENT_MAP$1[name]) {
            return new EVENT_MAP$1[name](args, sender);
        }
        return super.create(name, args, sender);
    }
}
StockInstanceEventService.ɵfac = function StockInstanceEventService_Factory(t) { return ɵStockInstanceEventService_BaseFactory(t || StockInstanceEventService); };
StockInstanceEventService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: StockInstanceEventService, factory: StockInstanceEventService.ɵfac });

const NAVIGATOR_DEFAULTS = {
    autoBindElements: true,
    liveDrag: false,
    partialRedraw: true
};
/* tslint:disable:no-access-missing-member */
/**
 * The root StockChart component.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-stockchart>
 *         <kendo-chart-series>
 *             <kendo-chart-series-item type="line" [data]="data" field="value" categoryField="date">
 *             </kendo-chart-series-item>
 *         </kendo-chart-series>
 *         <kendo-chart-navigator>
 *             <kendo-chart-navigator-select to="2017/02/01">
 *             </kendo-chart-navigator-select>
 *             <kendo-chart-navigator-series>
 *                 <kendo-chart-navigator-series-item type="area" [data]="data" field="value" categoryField="date">
 *                 </kendo-chart-navigator-series-item>
 *             </kendo-chart-navigator-series>
 *         </kendo-chart-navigator>
 *     </kendo-stockchart>
 *   `
 * })
 * class AppComponent {
 *   public data: any[] = [];
 *
 *   constructor() {
 *      for (let idx = 0; idx < 100; idx++) {
 *          this.data.push({
 *              date: new Date(2017, 0, idx),
 *              value: Math.random() * 100
 *          });
 *      }
 *   }
 * }
 *
 * ```
 */
let StockChartComponent = class StockChartComponent extends ChartComponent {
    constructor(configurationService, themeService, element, intl, localizationService, ngZone, instanceEventService, changeDetector, renderer) {
        super(configurationService, themeService, element, intl, localizationService, ngZone, instanceEventService, changeDetector, renderer);
        this.configurationService = configurationService;
        this.themeService = themeService;
        this.element = element;
        this.intl = intl;
        this.localizationService = localizationService;
        this.ngZone = ngZone;
        this.instanceEventService = instanceEventService;
        this.changeDetector = changeDetector;
        this.renderer = renderer;
        /**
         * Fires when the navigator range is changed.
         */
        this.navigatorFilter = new EventEmitter();
        this.redrawSlaves = false;
        this.hostClasses = ['k-chart', 'k-stockchart'];
        validatePackage(packageMetadata);
    }
    /**
     * If called, the navigator pane is not redrawn the next time the StockChart options are updated.
     * The method is useful if you need to update only the main series data for the selected period.
     */
    skipNavigatorRedraw() {
        this.redrawSlaves = true;
    }
    createInstance(element, observer) {
        this.applyNavigatorDefaults();
        if (this.isDevMode() && (this.options.zoomable || this.options.pannable)) {
            throw new Error('The pannable and zoomable options are not supported by the StockChart component.');
        }
        this.instance = new StockChart(element, this.options, this.theme, {
            intlService: this.intl,
            observer: observer,
            rtl: this.rtl,
            sender: this
        });
    }
    updateOptions() {
        this.applyNavigatorDefaults();
        if (this.redrawSlaves) {
            this.instance.applyOptions(this.options);
            this.instance.bindCategories();
            this.instance.navigator.redrawSlaves();
        }
        else {
            this.instance.setOptions(this.options);
        }
        this.redrawSlaves = false;
    }
    applyNavigatorDefaults() {
        this.options.navigator = Object.assign({}, this.options.navigator, NAVIGATOR_DEFAULTS);
    }
    isDevMode() {
        return isDevMode();
    }
};
StockChartComponent.ɵfac = function StockChartComponent_Factory(t) { return new (t || StockChartComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(ThemeService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.IntlService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(StockInstanceEventService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
StockChartComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: StockChartComponent, selectors: [["kendo-stockchart"]], inputs: { navigator: "navigator", pannable: "pannable", zoomable: "zoomable" }, outputs: { navigatorFilter: "navigatorFilter" }, exportAs: ["kendoStockChart"], features: [ɵngcc0.ɵɵProvidersFeature([
            ConfigurationService,
            TooltipTemplateService,
            { provide: RootConfigurationService, useExisting: ConfigurationService },
            StockInstanceEventService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.chart'
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 2, consts: [[1, "k-chart-surface"], ["surface", ""], [3, "popupSettings"], [3, "popupSettings", "leave"], [3, "resize"]], template: function StockChartComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "div", 0, 1);
        ɵngcc0.ɵɵelement(2, "kendo-chart-crosshair-tooltips-container", 2);
        ɵngcc0.ɵɵelementStart(3, "kendo-chart-tooltip-popup", 3);
        ɵngcc0.ɵɵlistener("leave", function StockChartComponent_Template_kendo_chart_tooltip_popup_leave_3_listener($event) { return ctx.tooltipMouseleave($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "kendo-resize-sensor", 4);
        ɵngcc0.ɵɵlistener("resize", function StockChartComponent_Template_kendo_resize_sensor_resize_4_listener($event) { return ctx.onResize($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("popupSettings", ctx.popupSettings);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("popupSettings", ctx.popupSettings);
    } }, directives: [CrosshairTooltipsContainerComponent, TooltipPopupComponent, ɵngcc5.ResizeSensorComponent], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", Object)
], StockChartComponent.prototype, "navigator", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], StockChartComponent.prototype, "pannable", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], StockChartComponent.prototype, "zoomable", void 0);
__decorate([
    Output(),
    __metadata("design:type", EventEmitter)
], StockChartComponent.prototype, "navigatorFilter", void 0);
StockChartComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        ThemeService,
        ElementRef,
        IntlService,
        LocalizationService,
        NgZone,
        StockInstanceEventService,
        ChangeDetectorRef,
        Renderer2])
], StockChartComponent);

/**
 * @hidden
 */
const PREFIX = new InjectionToken('configuration prefix');
/**
 * @hidden
 */
let PrefixConfigurationService = class PrefixConfigurationService extends ConfigurationService {
    constructor(rootService, prefix, ngZone) {
        super(ngZone);
        this.rootService = rootService;
        this.prefix = prefix;
    }
    push(store) {
        this.rootService.notify(new Change(this.prefix, store));
    }
    notify(change) {
        change.key = this.prefix + (change.key ? `.${change.key}` : '');
        this.rootService.notify(change);
    }
};
PrefixConfigurationService.ɵfac = function PrefixConfigurationService_Factory(t) { return new (t || PrefixConfigurationService)(ɵngcc0.ɵɵinject(RootConfigurationService), ɵngcc0.ɵɵinject(PREFIX), ɵngcc0.ɵɵinject(ɵngcc0.NgZone)); };
PrefixConfigurationService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: PrefixConfigurationService, factory: function (t) { return PrefixConfigurationService.ɵfac(t); } });
PrefixConfigurationService = __decorate([ __param(0, Inject(RootConfigurationService)),
    __param(1, Inject(PREFIX)),
    __metadata("design:paramtypes", [RootConfigurationService, String, NgZone])
], PrefixConfigurationService);

/**
 * The configuration options of the navigator
 * ([see runnable example]({% slug overview_stockchart_charts %}#toc-navigator)).
 *
 * @example
 * ```ts-no-run
 * _@Component({
 *     selector: 'my-app',
 *       template: `
 *         <kendo-stockchart (navigatorFilter)="onNavigatorFilter($event)">
 *             <kendo-chart-series>
 *                <kendo-chart-series-item
 *                type="candlestick"
 *                 [data]="seriesData"
 *                 openField="Open"
 *                 closeField="Close"
 *                 lowField="Low"
 *                 highField="High"
 *                 categoryField="Date">
 *             </kendo-chart-series-item>
 *          </kendo-chart-series>
 *          <kendo-chart-navigator
 *            [categoryAxis]="categoryAxisOptions"
 *            [hint]="hintOptions"
 *            [pane]="paneOptions"
 *            [visible]="isVisible">
 *            <kendo-chart-navigator-select [from]="from" [to]="to">
 *            </kendo-chart-navigator-select>
 *            <kendo-chart-navigator-series>
 *              <kendo-chart-navigator-series-item type="area" [data]="navigatorData" field="Close" categoryField="Date">
 *              </kendo-chart-navigator-series-item>
 *           </kendo-chart-navigator-series>
 *          </kendo-chart-navigator>
 *        </kendo-stockchart>
 *        <br /><br />
 *        <button class="k-button" (click)="isVisible = !isVisible">Toggle Navigator</button>
 *    `
 * })
 * ```
 */
let NavigatorComponent = class NavigatorComponent extends SettingsComponent {
    constructor(configurationService) {
        super('', configurationService);
        this.configurationService = configurationService;
    }
};
NavigatorComponent.ɵfac = function NavigatorComponent_Factory(t) { return new (t || NavigatorComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorComponent, selectors: [["kendo-chart-navigator"]], inputs: { visible: "visible", categoryAxis: "categoryAxis", hint: "hint", pane: "pane", select: "select", series: "series" }, features: [ɵngcc0.ɵɵProvidersFeature([{ provide: PREFIX, useValue: 'navigator' }, { provide: ConfigurationService, useClass: PrefixConfigurationService }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NavigatorComponent.prototype, "visible", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NavigatorComponent.prototype, "categoryAxis", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NavigatorComponent.prototype, "hint", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NavigatorComponent.prototype, "pane", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NavigatorComponent.prototype, "select", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NavigatorComponent.prototype, "series", void 0);
NavigatorComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorComponent);

/**
 * The configuration component of the navigator category axis.
 *
 * @example
 *
 * ```html-no-run
 * <kendo-stockchart>
 *   <kendo-chart-navigator>
 *     <kendo-chart-navigator-category-axis
 *       color="maroon"
 *       [labels]="{color: 'green'}">
 *     </kendo-chart-navigator-category-axis>
 *   </kendo-chart-navigator>
 * </kendo-stockchart>
 * ```
 */
let NavigatorCategoryAxisComponent = class NavigatorCategoryAxisComponent extends CategoryAxisItemComponent {
    constructor(configurationService, intl, localeId) {
        super(configurationService, null, intl, localeId);
        this.configurationService = configurationService;
    }
};
NavigatorCategoryAxisComponent.ɵfac = function NavigatorCategoryAxisComponent_Factory(t) { return new (t || NavigatorCategoryAxisComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.IntlService), ɵngcc0.ɵɵdirectiveInject(LOCALE_ID)); };
NavigatorCategoryAxisComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorCategoryAxisComponent, selectors: [["kendo-chart-navigator-category-axis"]], features: [ɵngcc0.ɵɵProvidersFeature([{
                provide: PREFIX,
                useValue: 'navigator.categoryAxis'
            }, {
                provide: ConfigurationService,
                useClass: PrefixConfigurationService
            }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorCategoryAxisComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorCategoryAxisComponent = __decorate([ __param(2, Inject(LOCALE_ID)),
    __metadata("design:paramtypes", [ConfigurationService,
        IntlService, String])
], NavigatorCategoryAxisComponent);

/**
 * The configuration options of the crosshair.
 */
let NavigatorCategoryAxisCrosshairComponent = class NavigatorCategoryAxisCrosshairComponent extends CategoryAxisCrosshairComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
NavigatorCategoryAxisCrosshairComponent.ɵfac = function NavigatorCategoryAxisCrosshairComponent_Factory(t) { return new (t || NavigatorCategoryAxisCrosshairComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorCategoryAxisCrosshairComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorCategoryAxisCrosshairComponent, selectors: [["kendo-chart-navigator-category-axis-crosshair"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorCategoryAxisCrosshairComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorCategoryAxisCrosshairComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorCategoryAxisCrosshairComponent);

/**
 * The configuration options of the crosshair tooltip.
 * The crosshair tooltip is displayed when the `visible` option is set to `true`.
 */
let NavigatorCategoryAxisCrosshairTooltipComponent = class NavigatorCategoryAxisCrosshairTooltipComponent extends CategoryAxisCrosshairTooltipComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
NavigatorCategoryAxisCrosshairTooltipComponent.ɵfac = function NavigatorCategoryAxisCrosshairTooltipComponent_Factory(t) { return new (t || NavigatorCategoryAxisCrosshairTooltipComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorCategoryAxisCrosshairTooltipComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorCategoryAxisCrosshairTooltipComponent, selectors: [["kendo-chart-navigator-category-axis-crosshair-tooltip"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorCategoryAxisCrosshairTooltipComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorCategoryAxisCrosshairTooltipComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorCategoryAxisCrosshairTooltipComponent);

/**
 * The configuration of the axis labels.
 */
let NavigatorCategoryAxisLabelsComponent = class NavigatorCategoryAxisLabelsComponent extends CategoryAxisLabelsComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
NavigatorCategoryAxisLabelsComponent.ɵfac = function NavigatorCategoryAxisLabelsComponent_Factory(t) { return new (t || NavigatorCategoryAxisLabelsComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorCategoryAxisLabelsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorCategoryAxisLabelsComponent, selectors: [["kendo-chart-navigator-category-axis-labels"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorCategoryAxisLabelsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorCategoryAxisLabelsComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorCategoryAxisLabelsComponent);

/**
 * The configuration of the category axis notes.
 */
let NavigatorCategoryAxisNotesComponent = class NavigatorCategoryAxisNotesComponent extends CategoryAxisNotesComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
NavigatorCategoryAxisNotesComponent.ɵfac = function NavigatorCategoryAxisNotesComponent_Factory(t) { return new (t || NavigatorCategoryAxisNotesComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorCategoryAxisNotesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorCategoryAxisNotesComponent, selectors: [["kendo-chart-navigator-category-axis-notes"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorCategoryAxisNotesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorCategoryAxisNotesComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorCategoryAxisNotesComponent);

/**
 * The icon of the notes.
 */
let NavigatorCategoryAxisNotesIconComponent = class NavigatorCategoryAxisNotesIconComponent extends CategoryAxisNotesIconComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
NavigatorCategoryAxisNotesIconComponent.ɵfac = function NavigatorCategoryAxisNotesIconComponent_Factory(t) { return new (t || NavigatorCategoryAxisNotesIconComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorCategoryAxisNotesIconComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorCategoryAxisNotesIconComponent, selectors: [["kendo-chart-navigator-category-axis-notes-icon"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorCategoryAxisNotesIconComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorCategoryAxisNotesIconComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorCategoryAxisNotesIconComponent);

/**
 * The label of the notes.
 */
let NavigatorCategoryAxisNotesLabelComponent = class NavigatorCategoryAxisNotesLabelComponent extends CategoryAxisNotesLabelComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
NavigatorCategoryAxisNotesLabelComponent.ɵfac = function NavigatorCategoryAxisNotesLabelComponent_Factory(t) { return new (t || NavigatorCategoryAxisNotesLabelComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorCategoryAxisNotesLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorCategoryAxisNotesLabelComponent, selectors: [["kendo-chart-navigator-category-axis-notes-label"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorCategoryAxisNotesLabelComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorCategoryAxisNotesLabelComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorCategoryAxisNotesLabelComponent);

/**
 * The selected axis range. If set, the axis selection is enabled. The range is index-based and starts from zero.
 * Categories with indexes in the range (`select.from`, `select.to`) will be selected.
 * This means that the last category in the range will not be included in the selection.
 * If the categories are dates, the range has also to be specified with date values.
 */
let NavigatorCategoryAxisSelectComponent = class NavigatorCategoryAxisSelectComponent extends CategoryAxisSelectComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
NavigatorCategoryAxisSelectComponent.ɵfac = function NavigatorCategoryAxisSelectComponent_Factory(t) { return new (t || NavigatorCategoryAxisSelectComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorCategoryAxisSelectComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorCategoryAxisSelectComponent, selectors: [["kendo-chart-navigator-category-axis-select"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorCategoryAxisSelectComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorCategoryAxisSelectComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorCategoryAxisSelectComponent);

/**
 * The title configuration of the navigator category axis.
 */
let NavigatorCategoryAxisTitleComponent = class NavigatorCategoryAxisTitleComponent extends CategoryAxisTitleComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
NavigatorCategoryAxisTitleComponent.ɵfac = function NavigatorCategoryAxisTitleComponent_Factory(t) { return new (t || NavigatorCategoryAxisTitleComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorCategoryAxisTitleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorCategoryAxisTitleComponent, selectors: [["kendo-chart-navigator-category-axis-title"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorCategoryAxisTitleComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorCategoryAxisTitleComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorCategoryAxisTitleComponent);

/**
 * The default options of the navigator hint
 * ([see example]({% slug overview_stockchart_charts %}#toc-navigator)).
 */
let NavigatorHintComponent = class NavigatorHintComponent extends SettingsComponent {
    constructor(configurationService) {
        super('hint', configurationService);
        this.configurationService = configurationService;
    }
};
NavigatorHintComponent.ɵfac = function NavigatorHintComponent_Factory(t) { return new (t || NavigatorHintComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorHintComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorHintComponent, selectors: [["kendo-chart-navigator-hint"]], inputs: { content: "content", format: "format", visible: "visible" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorHintComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", Function)
], NavigatorHintComponent.prototype, "content", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], NavigatorHintComponent.prototype, "format", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], NavigatorHintComponent.prototype, "visible", void 0);
NavigatorHintComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorHintComponent);

/**
 * The configuration component of the navigator pane
 * ([see example]({% slug overview_stockchart_charts %}#toc-navigator)).
 */
let NavigatorPaneComponent = class NavigatorPaneComponent extends PaneComponentGenerated {
    constructor(configurationService) {
        super(configurationService, null);
        this.configurationService = configurationService;
    }
};
NavigatorPaneComponent.ɵfac = function NavigatorPaneComponent_Factory(t) { return new (t || NavigatorPaneComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorPaneComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorPaneComponent, selectors: [["kendo-chart-navigator-pane"]], features: [ɵngcc0.ɵɵProvidersFeature([{ provide: PREFIX, useValue: 'navigator.pane' }, { provide: ConfigurationService, useClass: PrefixConfigurationService }]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorPaneComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorPaneComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorPaneComponent);

/**
 * The title configuration of the StockChart navigator pane.
 */
let NavigatorPaneTitleComponent = class NavigatorPaneTitleComponent extends PanesTitleComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
NavigatorPaneTitleComponent.ɵfac = function NavigatorPaneTitleComponent_Factory(t) { return new (t || NavigatorPaneTitleComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorPaneTitleComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorPaneTitleComponent, selectors: [["kendo-chart-navigator-pane-title"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorPaneTitleComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorPaneTitleComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorPaneTitleComponent);

/**
 * Specifies the initially selected range.
 * If no range is specified, the full range of values is rendered.
 */
let NavigatorSelectComponent = class NavigatorSelectComponent extends SettingsComponent {
    constructor(configurationService) {
        super('select', configurationService);
        this.configurationService = configurationService;
    }
};
NavigatorSelectComponent.ɵfac = function NavigatorSelectComponent_Factory(t) { return new (t || NavigatorSelectComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorSelectComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorSelectComponent, selectors: [["kendo-chart-navigator-select"]], inputs: { from: "from", to: "to", mousewheel: "mousewheel" }, features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorSelectComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", Date)
], NavigatorSelectComponent.prototype, "from", void 0);
__decorate([
    Input(),
    __metadata("design:type", Date)
], NavigatorSelectComponent.prototype, "to", void 0);
__decorate([
    Input(),
    __metadata("design:type", Object)
], NavigatorSelectComponent.prototype, "mousewheel", void 0);
NavigatorSelectComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorSelectComponent);

/**
 * The configuration component of a navigator series item
 * ([see example]({% slug navigator_stockchart_charts %})).
 */
let NavigatorSeriesItemComponent = class NavigatorSeriesItemComponent extends SeriesItemComponent {
    constructor(configurationService, collectionService) {
        super(configurationService, collectionService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
    }
};
NavigatorSeriesItemComponent.ɵfac = function NavigatorSeriesItemComponent_Factory(t) { return new (t || NavigatorSeriesItemComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionService)); };
NavigatorSeriesItemComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorSeriesItemComponent, selectors: [["kendo-chart-navigator-series-item"]], features: [ɵngcc0.ɵɵProvidersFeature([ConfigurationService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorSeriesItemComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorSeriesItemComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        CollectionService])
], NavigatorSeriesItemComponent);

/**
 * A collection of one or more navigator series items.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-stockchart>
 *         <kendo-chart-navigator>
 *             <kendo-chart-navigator-series>
 *                 <kendo-chart-navigator-series-item type="area" [data]="data" field="value" categoryField="date">
 *                 </kendo-chart-navigator-series-item>
 *             </kendo-chart-navigator-series>
 *         </kendo-chart-navigator>
 *     </kendo-stockchart>
 *   `
 * })
 * class AppComponent {
 *   public data: any[] = [];
 *
 *   constructor() {
 *      for (let idx = 0; idx < 100; idx++) {
 *          this.data.push({
 *              date: new Date(2017, 0, idx),
 *              value: Math.random() * 100
 *          });
 *      }
 *   }
 * }
 *
 * ```
 */
let NavigatorSeriesComponent = class NavigatorSeriesComponent extends SeriesComponent {
    constructor(configurationService, collectionService, tooltipTemplateService) {
        super(configurationService, collectionService, tooltipTemplateService);
        this.configurationService = configurationService;
        this.collectionService = collectionService;
        this.tooltipTemplateService = tooltipTemplateService;
    }
    readTooltipTemplates() {
    }
};
NavigatorSeriesComponent.ɵfac = function NavigatorSeriesComponent_Factory(t) { return new (t || NavigatorSeriesComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(CollectionService), ɵngcc0.ɵɵdirectiveInject(TooltipTemplateService)); };
NavigatorSeriesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorSeriesComponent, selectors: [["kendo-chart-navigator-series"]], contentQueries: function NavigatorSeriesComponent_ContentQueries(rf, ctx, dirIndex) { if (rf & 1) {
        ɵngcc0.ɵɵcontentQuery(dirIndex, NavigatorSeriesItemComponent, 0);
    } if (rf & 2) {
        let _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.children = _t);
    } }, features: [ɵngcc0.ɵɵProvidersFeature([CollectionService]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorSeriesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
__decorate([
    ContentChildren(NavigatorSeriesItemComponent),
    __metadata("design:type", QueryList)
], NavigatorSeriesComponent.prototype, "children", void 0);
NavigatorSeriesComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        CollectionService,
        TooltipTemplateService])
], NavigatorSeriesComponent);

/**
 * The error bars of the StockChart navigator series.
 */
let NavigatorSeriesErrorBarsComponent = class NavigatorSeriesErrorBarsComponent extends SeriesErrorBarsComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
NavigatorSeriesErrorBarsComponent.ɵfac = function NavigatorSeriesErrorBarsComponent_Factory(t) { return new (t || NavigatorSeriesErrorBarsComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorSeriesErrorBarsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorSeriesErrorBarsComponent, selectors: [["kendo-chart-navigator-series-item-error-bars"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorSeriesErrorBarsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorSeriesErrorBarsComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorSeriesErrorBarsComponent);

/**
 * The extremes configuration of the StockChart navigator series. Applies to extreme outliers.
 */
let NavigatorSeriesExtremesComponent = class NavigatorSeriesExtremesComponent extends SeriesExtremesComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
NavigatorSeriesExtremesComponent.ɵfac = function NavigatorSeriesExtremesComponent_Factory(t) { return new (t || NavigatorSeriesExtremesComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorSeriesExtremesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorSeriesExtremesComponent, selectors: [["kendo-chart-navigator-series-item-extremes"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorSeriesExtremesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorSeriesExtremesComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorSeriesExtremesComponent);

/**
 * The configuration options of the StockChart series highlight.
 */
let NavigatorSeriesHighlightComponent = class NavigatorSeriesHighlightComponent extends SeriesHighlightComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
NavigatorSeriesHighlightComponent.ɵfac = function NavigatorSeriesHighlightComponent_Factory(t) { return new (t || NavigatorSeriesHighlightComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorSeriesHighlightComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorSeriesHighlightComponent, selectors: [["kendo-chart-navigator-series-item-highlight"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorSeriesHighlightComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorSeriesHighlightComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorSeriesHighlightComponent);

/**
 * The label configuration of the StockChart navigator series.
 */
let NavigatorSeriesLabelsComponent = class NavigatorSeriesLabelsComponent extends SeriesLabelsComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
};
NavigatorSeriesLabelsComponent.ɵfac = function NavigatorSeriesLabelsComponent_Factory(t) { return new (t || NavigatorSeriesLabelsComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorSeriesLabelsComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorSeriesLabelsComponent, selectors: [["kendo-chart-navigator-series-item-labels"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorSeriesLabelsComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorSeriesLabelsComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorSeriesLabelsComponent);

/**
 * The `from` label configuration of the StockChart navigator series.
 */
let NavigatorSeriesLabelsFromComponent = class NavigatorSeriesLabelsFromComponent extends SeriesLabelsFromComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
};
NavigatorSeriesLabelsFromComponent.ɵfac = function NavigatorSeriesLabelsFromComponent_Factory(t) { return new (t || NavigatorSeriesLabelsFromComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorSeriesLabelsFromComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorSeriesLabelsFromComponent, selectors: [["kendo-chart-navigator-series-item-labels-from"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorSeriesLabelsFromComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorSeriesLabelsFromComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorSeriesLabelsFromComponent);

/**
 * The `to` label configuration of the StockChart navigator series.
 */
let NavigatorSeriesLabelsToComponent = class NavigatorSeriesLabelsToComponent extends SeriesLabelsToComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
        this.markAsVisible();
    }
};
NavigatorSeriesLabelsToComponent.ɵfac = function NavigatorSeriesLabelsToComponent_Factory(t) { return new (t || NavigatorSeriesLabelsToComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorSeriesLabelsToComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorSeriesLabelsToComponent, selectors: [["kendo-chart-navigator-series-item-labels-to"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorSeriesLabelsToComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorSeriesLabelsToComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorSeriesLabelsToComponent);

/**
 * The marker configuration of the StockChart navigator series.
 */
let NavigatorSeriesMarkersComponent = class NavigatorSeriesMarkersComponent extends SeriesMarkersComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
NavigatorSeriesMarkersComponent.ɵfac = function NavigatorSeriesMarkersComponent_Factory(t) { return new (t || NavigatorSeriesMarkersComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorSeriesMarkersComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorSeriesMarkersComponent, selectors: [["kendo-chart-navigator-series-item-markers"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorSeriesMarkersComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorSeriesMarkersComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorSeriesMarkersComponent);

/**
 * The notes configuration of the StockChart navigator series.
 */
let NavigatorSeriesNotesComponent = class NavigatorSeriesNotesComponent extends SeriesNotesComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
NavigatorSeriesNotesComponent.ɵfac = function NavigatorSeriesNotesComponent_Factory(t) { return new (t || NavigatorSeriesNotesComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorSeriesNotesComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorSeriesNotesComponent, selectors: [["kendo-chart-navigator-series-item-notes"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorSeriesNotesComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorSeriesNotesComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorSeriesNotesComponent);

/**
 * The icon of the notes.
 */
let NavigatorSeriesNotesIconComponent = class NavigatorSeriesNotesIconComponent extends SeriesNotesIconComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
NavigatorSeriesNotesIconComponent.ɵfac = function NavigatorSeriesNotesIconComponent_Factory(t) { return new (t || NavigatorSeriesNotesIconComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorSeriesNotesIconComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorSeriesNotesIconComponent, selectors: [["kendo-chart-navigator-series-item-notes-icon"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorSeriesNotesIconComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorSeriesNotesIconComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorSeriesNotesIconComponent);

/**
 * The label of the notes.
 */
let NavigatorSeriesNotesLabelComponent = class NavigatorSeriesNotesLabelComponent extends SeriesNotesLabelComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
NavigatorSeriesNotesLabelComponent.ɵfac = function NavigatorSeriesNotesLabelComponent_Factory(t) { return new (t || NavigatorSeriesNotesLabelComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorSeriesNotesLabelComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorSeriesNotesLabelComponent, selectors: [["kendo-chart-navigator-series-item-notes-label"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorSeriesNotesLabelComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorSeriesNotesLabelComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorSeriesNotesLabelComponent);

/**
 * The outliers configuration of the StockChart navigator series. Applies to mild outliers.
 */
let NavigatorSeriesOutliersComponent = class NavigatorSeriesOutliersComponent extends SeriesOutliersComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
NavigatorSeriesOutliersComponent.ɵfac = function NavigatorSeriesOutliersComponent_Factory(t) { return new (t || NavigatorSeriesOutliersComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorSeriesOutliersComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorSeriesOutliersComponent, selectors: [["kendo-chart-navigator-series-item-outliers"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorSeriesOutliersComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorSeriesOutliersComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorSeriesOutliersComponent);

/**
 * The tooltip configuration of the StockChart navigator series.
 * The StockChart navigator series tooltip is displayed when the `navigator.series.tooltip.visible` option is set to `true`.
 */
let NavigatorSeriesTooltipComponent = class NavigatorSeriesTooltipComponent extends SeriesTooltipComponent {
    constructor(configurationService) {
        super(configurationService);
        this.configurationService = configurationService;
    }
};
NavigatorSeriesTooltipComponent.ɵfac = function NavigatorSeriesTooltipComponent_Factory(t) { return new (t || NavigatorSeriesTooltipComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService)); };
NavigatorSeriesTooltipComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NavigatorSeriesTooltipComponent, selectors: [["kendo-chart-navigator-series-item-tooltip"]], features: [ɵngcc0.ɵɵInheritDefinitionFeature], decls: 0, vars: 0, template: function NavigatorSeriesTooltipComponent_Template(rf, ctx) { }, encapsulation: 2, changeDetection: 0 });
NavigatorSeriesTooltipComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService])
], NavigatorSeriesTooltipComponent);

/**
 * @hidden
 */
const STOCK_CHART_DIRECTIVES = [
    StockChartComponent,
    NavigatorComponent,
    NavigatorCategoryAxisComponent,
    NavigatorCategoryAxisCrosshairComponent,
    NavigatorCategoryAxisCrosshairTooltipComponent,
    NavigatorCategoryAxisLabelsComponent,
    NavigatorCategoryAxisNotesComponent,
    NavigatorCategoryAxisNotesIconComponent,
    NavigatorCategoryAxisNotesLabelComponent,
    NavigatorCategoryAxisSelectComponent,
    NavigatorCategoryAxisTitleComponent,
    NavigatorHintComponent,
    NavigatorPaneComponent,
    NavigatorPaneTitleComponent,
    NavigatorSelectComponent,
    NavigatorSeriesComponent,
    NavigatorSeriesItemComponent,
    NavigatorSeriesErrorBarsComponent,
    NavigatorSeriesExtremesComponent,
    NavigatorSeriesHighlightComponent,
    NavigatorSeriesLabelsComponent,
    NavigatorSeriesLabelsFromComponent,
    NavigatorSeriesLabelsToComponent,
    NavigatorSeriesMarkersComponent,
    NavigatorSeriesNotesComponent,
    NavigatorSeriesNotesIconComponent,
    NavigatorSeriesNotesLabelComponent,
    NavigatorSeriesOutliersComponent,
    NavigatorSeriesTooltipComponent
];

/* tslint:disable:no-access-missing-member */
/**
 * The root Chart component.
 *
 * @example
 * ```ts
 * import { Component } from '@angular/core';
 *
 * _@Component({
 *   selector: 'my-app',
 *   template: `
 *     <kendo-sparkline [data]="data" type="column">
 *     </kendo-sparkline>
 *   `
 * })
 * class AppComponent {
 *   public data: any[] = [
 *     936, 968, 1025, 999, 998, 1014, 1017, 1010, 1010, 1007,
 *     1004, 988, 990, 988, 987, 995, 946, 954, 991, 984,
 *     974, 956, 986, 936, 955, 1021, 1013, 1005, 958, 953,
 *     952, 940, 937, 980, 966, 965, 928, 916, 910, 980
 *   ];
 * }
 *
 * ```
 */
let SparklineComponent = class SparklineComponent extends ChartComponent {
    constructor(configurationService, themeService, element, intl, localizationService, ngZone, instanceEventService, changeDetector, renderer) {
        super(configurationService, themeService, element, intl, localizationService, ngZone, instanceEventService, changeDetector, renderer);
        this.configurationService = configurationService;
        this.themeService = themeService;
        this.element = element;
        this.intl = intl;
        this.localizationService = localizationService;
        this.ngZone = ngZone;
        this.instanceEventService = instanceEventService;
        this.changeDetector = changeDetector;
        this.renderer = renderer;
        /**
         * @hidden
         */
        this.tooltipWrapperClass = 'k-sparkline-tooltip-wrapper';
        /**
         * @hidden
         */
        this.tooltipContentClasses = {
            'k-sparkline-tooltip': true
        };
        this.hostClasses = ['k-sparkline', 'k-widget'];
        validatePackage(packageMetadata);
    }
    createInstance(element, observer) {
        this.instance = new Sparkline(element, Sparkline.normalizeOptions(this.options), this.theme, {
            intlService: this.intl,
            observer: observer,
            rtl: this.rtl,
            sender: this
        });
    }
    updateOptions() {
        this.instance.setOptions(Sparkline.normalizeOptions(this.options));
    }
};
SparklineComponent.ɵfac = function SparklineComponent_Factory(t) { return new (t || SparklineComponent)(ɵngcc0.ɵɵdirectiveInject(ConfigurationService), ɵngcc0.ɵɵdirectiveInject(ThemeService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc4.IntlService), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.LocalizationService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(InstanceEventService), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2)); };
SparklineComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: SparklineComponent, selectors: [["kendo-sparkline"]], inputs: { type: "type", data: "data" }, exportAs: ["kendoSparkline"], features: [ɵngcc0.ɵɵProvidersFeature([
            ConfigurationService,
            TooltipTemplateService,
            InstanceEventService,
            LocalizationService,
            {
                provide: L10N_PREFIX,
                useValue: 'kendo.chart'
            }
        ]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 5, vars: 5, consts: [[1, "k-chart-surface"], ["surface", ""], [3, "popupSettings"], [3, "animate", "wrapperClass", "classNames", "popupSettings", "leave"], [3, "resize"]], template: function SparklineComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelement(0, "span", 0, 1);
        ɵngcc0.ɵɵelement(2, "kendo-chart-crosshair-tooltips-container", 2);
        ɵngcc0.ɵɵelementStart(3, "kendo-chart-tooltip-popup", 3);
        ɵngcc0.ɵɵlistener("leave", function SparklineComponent_Template_kendo_chart_tooltip_popup_leave_3_listener($event) { return ctx.tooltipMouseleave($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "kendo-resize-sensor", 4);
        ɵngcc0.ɵɵlistener("resize", function SparklineComponent_Template_kendo_resize_sensor_resize_4_listener($event) { return ctx.onResize($event); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("popupSettings", ctx.popupSettings);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("animate", false)("wrapperClass", ctx.tooltipWrapperClass)("classNames", ctx.tooltipContentClasses)("popupSettings", ctx.popupSettings);
    } }, directives: [CrosshairTooltipsContainerComponent, TooltipPopupComponent, ɵngcc5.ResizeSensorComponent], encapsulation: 2, changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", String)
], SparklineComponent.prototype, "type", void 0);
__decorate([
    Input(),
    __metadata("design:type", Array)
], SparklineComponent.prototype, "data", void 0);
SparklineComponent = __decorate([ __metadata("design:paramtypes", [ConfigurationService,
        ThemeService,
        ElementRef,
        IntlService,
        LocalizationService,
        NgZone,
        InstanceEventService,
        ChangeDetectorRef,
        Renderer2])
], SparklineComponent);

/**
 * @hidden
 */
const SPARKLINE_DIRECTIVES = [
    SparklineComponent
];

/**
 * A [module]({{ site.data.urls.angular['ngmoduleapi'] }}) that includes the Chart component and directives.
 *
 * Imports the ChartModule into your application
 * [root module]({{ site.data.url.angular['ngmodules'] }}#angular-modularity) or any other sub-module
 * that will use the Chart component.
 *
 * @example
 * ```ts-no-run
 * import { NgModule } from '@angular/core';
 * import { BrowserModule } from '@angular/platform-browser';
 * import { ChartModule } from '@progress/kendo-angular-charts';
 * import { AppComponent } from './app.component';
 *
 * _@NgModule({
 *     bootstrap:    [AppComponent],
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, ChartModule]
 * })
 * export class AppModule {
 * }
 * ```
 */
let ChartModule = class ChartModule {
};
ChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ChartModule });
ChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ChartModule_Factory(t) { return new (t || ChartModule)(); }, providers: [
        ThemeService
    ], imports: [[CommonModule, PopupModule, ResizeSensorModule]] });

/**
 * A [module]({{ site.data.urls.angular['ngmoduleapi'] }}) that includes the StockChart component and directives.
 *
 * Imports the StockChartModule into your application
 * [root module]({{ site.data.urls.angular['ngmodules'] }}#angular-modularity) or any other sub-module
 * that will use the StockChart component.
 *
 * @example
 * ```ts-no-run
 * import { NgModule } from '@angular/core';
 * import { BrowserModule } from '@angular/platform-browser';
 * import { StockChartModule } from '@progress/kendo-angular-charts';
 * import { AppComponent } from './app.component';
 *
 * _@NgModule({
 *     bootstrap:    [AppComponent],
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, StockChartModule]
 * })
 * export class AppModule {
 * }
 * ```
 */
let StockChartModule = class StockChartModule {
};
StockChartModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: StockChartModule });
StockChartModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function StockChartModule_Factory(t) { return new (t || StockChartModule)(); }, imports: [[ChartModule, CommonModule, PopupModule, ResizeSensorModule], ChartModule] });

/**
 * A [module]({{ site.data.urls.angular['ngmoduleapi'] }}) that includes the Sparkline component and directives.
 *
 * Imports the SparklineModule into your application
 * [root module]({{ site.data.urls.angular['ngmodules'] }}#angular-modularity) or any other sub-module
 * that will use the Sparkline component.
 *
 * @example
 * ```ts-no-run
 * import { NgModule } from '@angular/core';
 * import { BrowserModule } from '@angular/platform-browser';
 * import { SparklineModule } from '@progress/kendo-angular-charts';
 * import { AppComponent } from './app.component';
 *
 * _@NgModule({
 *     bootstrap:    [AppComponent],
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, SparklineModule]
 * })
 * export class AppModule {
 * }
 * ```
 */
let SparklineModule = class SparklineModule {
};
SparklineModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: SparklineModule });
SparklineModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function SparklineModule_Factory(t) { return new (t || SparklineModule)(); }, imports: [[ChartModule, CommonModule, PopupModule, ResizeSensorModule], ChartModule] });

/**
 * A [module]({{ site.data.urls.angular['ngmoduleapi'] }}) that includes all Chart components and directives.
 *
 * Imports the ChartsModule into your application
 * [root module]({{ site.data.urls.angular['ngmodules'] }}#angular-modularity) or any other sub-module
 * that will use the Charts components.
 *
 * @example
 * ```ts-no-run
 * import { NgModule } from '@angular/core';
 * import { BrowserModule } from '@angular/platform-browser';
 * import { ChartsModule } from '@progress/kendo-angular-charts';
 * import { AppComponent } from './app.component';
 *
 * _@NgModule({
 *     bootstrap:    [AppComponent],
 *     declarations: [AppComponent],
 *     imports:      [BrowserModule, ChartsModule]
 * })
 * export class AppModule {
 * }
 * ```
 */
let ChartsModule = class ChartsModule {
};
ChartsModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: ChartsModule });
ChartsModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function ChartsModule_Factory(t) { return new (t || ChartsModule)(); }, imports: [ChartModule, SparklineModule, StockChartModule] });

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ConfigurationService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(DonutCenterTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoChartDonutCenterTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CollectionService, [{
        type: Injectable
    }], function () { return []; }, null); })();




(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesTooltipComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-series-item-tooltip',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, { seriesTooltipTemplate: [{
            type: ContentChild,
            args: [TemplateRef, { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesItemComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [ConfigurationService],
                selector: 'kendo-chart-series-item',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionService }]; }, { seriesTooltip: [{
            type: ContentChild,
            args: [SeriesTooltipComponent, { static: false }]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ThemeService, [{
        type: Injectable
    }], function () { return [{ type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TooltipTemplateService, [{
        type: Injectable
    }], null, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesTooltipTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoChartSeriesTooltipTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SharedTooltipTemplateDirective, [{
        type: Directive,
        args: [{
                selector: '[kendoChartSharedTooltipTemplate]'
            }]
    }], function () { return [{ type: ɵngcc0.TemplateRef, decorators: [{
                type: Optional
            }] }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TooltipPopupComponent, [{
        type: Component,
        args: [{
                providers: [PopupService, {
                        provide: POPUP_CONTAINER,
                        useFactory: ɵ0$2
                    }],
                selector: 'kendo-chart-tooltip-popup',
                template: `
    <ng-template #content>
        <div [ngClass]="popupClasses" [ngStyle]="style">
          <ng-template [ngTemplateOutlet]="seriesTooltipTemplateRef" *ngIf="!shared"
                    [ngTemplateOutletContext]="seriesTooltipContext">
          </ng-template>
          <ng-template [ngTemplateOutlet]="seriesSharedTooltipTemplateRef" *ngIf="shared"
                    [ngTemplateOutletContext]="seriesSharedTooltipContext">
          </ng-template>
        </div>
    </ng-template>

    <ng-template kendoChartSeriesTooltipTemplate let-formattedValue="formattedValue">
        <span [innerHTML]="formattedValue"></span>
    </ng-template>
    <ng-template kendoChartSharedTooltipTemplate let-points="points" let-categoryText="categoryText" let-colspan="colspan" let-colorMarker="colorMarker" let-nameColumn="nameColumn" >
        <table>
            <tr><th [attr.colspan]='colspan'> {{ categoryText }} </th></tr>
            <tr *ngFor="let point of points">
                <td *ngIf="colorMarker"><span class='k-chart-shared-tooltip-marker' [style.background-color]='point.series.color'></span></td>
                <td *ngIf="nameColumn">
                    <ng-container *ngIf="point.series.name !== undefined">{{ point.series.name }}</ng-container>
                    <ng-container *ngIf="point.series.name === undefined">&nbsp;</ng-container>
                </td>
                <td>
                  <ng-template [ngTemplateOutlet]="point.template"
                            [ngTemplateOutletContext]="point">
                  </ng-template>
                </td>
            </tr>
        </table>
    </ng-template>
    `
            }]
    }], function () { return [{ type: ɵngcc1.PopupService }, { type: TooltipTemplateService }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc0.NgZone }]; }, { animate: [{
            type: Input
        }], wrapperClass: [{
            type: Input
        }], leave: [{
            type: Output
        }], defaultSeriesTooltipTemplate: [{
            type: ViewChild,
            args: [SeriesTooltipTemplateDirective, { static: false }]
        }], defaultSharedTooltipTemplate: [{
            type: ViewChild,
            args: [SharedTooltipTemplateDirective, { static: false }]
        }], templateRef: [{
            type: ViewChild,
            args: ['content', { static: true }]
        }], classNames: [{
            type: Input
        }], popupSettings: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CrosshairTooltipComponent, [{
        type: Component,
        args: [{
                providers: [PopupService, {
                        provide: POPUP_CONTAINER,
                        useFactory: ɵ0$3
                    }],
                selector: 'kendo-chart-crosshair-tooltip',
                template: `
        <ng-template #content>
            <div class="k-chart-tooltip k-chart-crosshair-tooltip" [ngStyle]="style">
                {{ value }}
            </div>
        </ng-template>
    `
            }]
    }], function () { return [{ type: ɵngcc1.PopupService }, { type: ɵngcc2.LocalizationService }]; }, { templateRef: [{
            type: ViewChild,
            args: ['content', { static: true }]
        }], key: [{
            type: Input
        }], popupSettings: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CrosshairTooltipsContainerComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-chart-crosshair-tooltips-container',
                template: `
        <kendo-chart-crosshair-tooltip *ngFor="let key of tooltipKeys" [key]="key" [popupSettings]="popupSettings">
        </kendo-chart-crosshair-tooltip>
    `
            }]
    }], function () { return []; }, { popupSettings: [{
            type: Input
        }], crossahirTooltipComponents: [{
            type: ViewChildren,
            args: [CrosshairTooltipComponent]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ChartComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'kendoChart',
                providers: [
                    ConfigurationService,
                    TooltipTemplateService,
                    InstanceEventService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.chart'
                    }
                ],
                selector: 'kendo-chart',
                template: `
    <div #surface class="k-chart-surface"></div>
    <kendo-chart-crosshair-tooltips-container [popupSettings]="popupSettings">
    </kendo-chart-crosshair-tooltips-container>
    <kendo-chart-tooltip-popup (leave)="tooltipMouseleave($event)" [popupSettings]="popupSettings">
    </kendo-chart-tooltip-popup>
    <kendo-resize-sensor (resize)="onResize($event)" [rateLimit]="resizeRateLimit"></kendo-resize-sensor>
    <div class="k-chart-donut-center" [ngStyle]="donutCenterStyle" *ngIf="donutCenterStyle && donutCenterTemplate">
      <ng-template [ngTemplateOutlet]="donutCenterTemplate.templateRef"></ng-template>
    </div>
  `
            }]
    }], function () { return [{ type: ConfigurationService }, { type: ThemeService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc4.IntlService }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc0.NgZone }, { type: InstanceEventService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.Renderer2 }]; }, { legendItemClick: [{
            type: Output
        }], resizeRateLimit: [{
            type: Input
        }], popupSettings: [{
            type: Input
        }], seriesComponents: [{
            type: ContentChildren,
            args: [SeriesItemComponent, { descendants: true }]
        }], donutCenterTemplate: [{
            type: ContentChild,
            args: [DonutCenterTemplateDirective, { static: false }]
        }], tooltipInstance: [{
            type: ViewChild,
            args: [TooltipPopupComponent, { static: true }]
        }], crossahirTooltips: [{
            type: ViewChild,
            args: [CrosshairTooltipsContainerComponent, { static: true }]
        }], surfaceElement: [{
            type: ViewChild,
            args: ['surface', { static: true }]
        }] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AxisDefaultsComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-axis-defaults',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AxisDefaultsCrosshairComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-axis-defaults-crosshair',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AxisDefaultsCrosshairTooltipComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-axis-defaults-crosshair-tooltip',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AxisDefaultsLabelsComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-axis-defaults-labels',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(AxisDefaultsTitleComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-axis-defaults-title',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();


(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CategoryAxisItemComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [ConfigurationService],
                selector: 'kendo-chart-category-axis-item',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionService }, { type: ɵngcc4.IntlService }, { type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }]; }, { rangeLabels: [{
            type: Input
        }] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CategoryAxisComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [CollectionService],
                selector: 'kendo-chart-category-axis',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CategoryAxisCrosshairComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-category-axis-item-crosshair',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CategoryAxisCrosshairTooltipComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-category-axis-item-crosshair-tooltip',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CategoryAxisLabelsComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-category-axis-item-labels',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, { background: [{
            type: Input
        }], border: [{
            type: Input
        }], color: [{
            type: Input
        }], content: [{
            type: Input
        }], culture: [{
            type: Input
        }], dateFormats: [{
            type: Input
        }], font: [{
            type: Input
        }], format: [{
            type: Input
        }], margin: [{
            type: Input
        }], mirror: [{
            type: Input
        }], padding: [{
            type: Input
        }], position: [{
            type: Input
        }], rotation: [{
            type: Input
        }], skip: [{
            type: Input
        }], step: [{
            type: Input
        }], visible: [{
            type: Input
        }], visual: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CategoryAxisRangeLabelsComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-category-axis-item-range-labels',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CategoryAxisNotesComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-category-axis-item-notes',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CategoryAxisNotesIconComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-category-axis-item-notes-icon',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CategoryAxisNotesLabelComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-category-axis-item-notes-label',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CategoryAxisSelectComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-category-axis-item-select',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(CategoryAxisTitleComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-category-axis-item-title',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ChartAreaComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-area',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LegendComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-legend',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LegendInactiveItemsComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-legend-inactive-items',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(LegendItemComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-legend-item',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PaneComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [ConfigurationService],
                selector: 'kendo-chart-pane, kendo-chart-panes-item',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PaneDefaultsComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-pane-defaults',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, { background: [{
            type: Input
        }], border: [{
            type: Input
        }], clip: [{
            type: Input
        }], height: [{
            type: Input
        }], margin: [{
            type: Input
        }], padding: [{
            type: Input
        }], title: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PaneDefaultsTitleComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-pane-defaults-title',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, { background: [{
            type: Input
        }], border: [{
            type: Input
        }], color: [{
            type: Input
        }], font: [{
            type: Input
        }], margin: [{
            type: Input
        }], position: [{
            type: Input
        }], visible: [{
            type: Input
        }], visual: [{
            type: Input
        }] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PanesComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [CollectionService],
                selector: 'kendo-chart-panes',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PanesTitleComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-pane-title',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PlotAreaComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-plot-area',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [CollectionService],
                selector: 'kendo-chart-series',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionService }, { type: TooltipTemplateService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesDefaultsComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-series-defaults',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesDefaultsLabelsComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-series-defaults-labels',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesDefaultsLabelsFromComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-series-defaults-labels-from',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesDefaultsLabelsToComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-series-defaults-labels-to',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesDefaultsNotesComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-series-defaults-notes',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesDefaultsNotesIconComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-series-defaults-notes-icon',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesDefaultsNotesLabelComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-series-defaults-notes-label',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesDefaultsTooltipComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-series-defaults-tooltip',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesErrorBarsComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-series-item-error-bars',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesExtremesComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-series-item-extremes',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesHighlightComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-series-item-highlight',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesLabelsComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-series-item-labels',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesLabelsFromComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-series-item-labels-from',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesLabelsToComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-series-item-labels-to',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesMarkersComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-series-item-markers',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesNotesComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-series-item-notes',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesNotesIconComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-series-item-notes-icon',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesNotesLabelComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-series-item-notes-label',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SeriesOutliersComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-series-item-outliers',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TitleComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-title',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(TooltipComponent, [{
        type: Component,
        args: [{
                selector: 'kendo-chart-tooltip',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: TooltipTemplateService }]; }, { seriesTooltipTemplate: [{
            type: ContentChild,
            args: [SeriesTooltipTemplateDirective, { static: false }]
        }], sharedTooltipTemplate: [{
            type: ContentChild,
            args: [SharedTooltipTemplateDirective, { static: false }]
        }] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ValueAxisItemComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [ConfigurationService],
                selector: 'kendo-chart-value-axis-item',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ValueAxisComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [CollectionService],
                selector: 'kendo-chart-value-axis',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ValueAxisCrosshairComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-value-axis-item-crosshair',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ValueAxisCrosshairTooltipComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-value-axis-item-crosshair-tooltip',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ValueAxisLabelsComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-value-axis-item-labels',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ValueAxisNotesComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-value-axis-item-notes',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ValueAxisNotesIconComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-value-axis-item-notes-icon',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ValueAxisNotesLabelComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-value-axis-item-notes-label',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ValueAxisTitleComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-value-axis-item-title',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(XAxisItemComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [ConfigurationService],
                selector: 'kendo-chart-x-axis-item',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionService }, { type: ɵngcc4.IntlService }, { type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }]; }, { categories: [{
            type: Input
        }] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(XAxisComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [CollectionService],
                selector: 'kendo-chart-x-axis',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(XAxisCrosshairComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-x-axis-item-crosshair',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(XAxisCrosshairTooltipComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-x-axis-item-crosshair-tooltip',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(XAxisLabelsComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-x-axis-item-labels',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(XAxisNotesComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-x-axis-item-notes',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(XAxisNotesIconComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-x-axis-item-notes-icon',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(XAxisNotesLabelComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-x-axis-item-notes-label',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(XAxisTitleComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-x-axis-item-title',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(YAxisItemComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [ConfigurationService],
                selector: 'kendo-chart-y-axis-item',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionService }]; }, { categories: [{
            type: Input
        }] }); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(YAxisComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [CollectionService],
                selector: 'kendo-chart-y-axis',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(YAxisCrosshairComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-y-axis-item-crosshair',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(YAxisCrosshairTooltipComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-y-axis-item-crosshair-tooltip',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(YAxisLabelsComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-y-axis-item-labels',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(YAxisNotesComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-y-axis-item-notes',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(YAxisNotesIconComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-y-axis-item-notes-icon',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(YAxisNotesLabelComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-y-axis-item-notes-label',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(YAxisTitleComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-y-axis-item-title',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();

(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ZoomableComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-zoomable',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
const ɵRootConfigurationService_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(RootConfigurationService);
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(RootConfigurationService, [{
        type: Injectable
    }], null, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StockChartComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'kendoStockChart',
                providers: [
                    ConfigurationService,
                    TooltipTemplateService,
                    { provide: RootConfigurationService, useExisting: ConfigurationService },
                    StockInstanceEventService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.chart'
                    }
                ],
                selector: 'kendo-stockchart',
                template: `
        <div #surface class="k-chart-surface"></div>
        <kendo-chart-crosshair-tooltips-container [popupSettings]="popupSettings">
        </kendo-chart-crosshair-tooltips-container>
        <kendo-chart-tooltip-popup (leave)="tooltipMouseleave($event)" [popupSettings]="popupSettings">
        </kendo-chart-tooltip-popup>
        <kendo-resize-sensor (resize)="onResize($event)"></kendo-resize-sensor>
    `
            }]
    }], function () { return [{ type: ConfigurationService }, { type: ThemeService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc4.IntlService }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc0.NgZone }, { type: StockInstanceEventService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.Renderer2 }]; }, { navigatorFilter: [{
            type: Output
        }], navigator: [{
            type: Input
        }], pannable: [{
            type: Input
        }], zoomable: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(PrefixConfigurationService, [{
        type: Injectable
    }], function () { return [{ type: RootConfigurationService, decorators: [{
                type: Inject,
                args: [RootConfigurationService]
            }] }, { type: String, decorators: [{
                type: Inject,
                args: [PREFIX]
            }] }, { type: ɵngcc0.NgZone }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [{ provide: PREFIX, useValue: 'navigator' }, { provide: ConfigurationService, useClass: PrefixConfigurationService }],
                selector: 'kendo-chart-navigator',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, { visible: [{
            type: Input
        }], categoryAxis: [{
            type: Input
        }], hint: [{
            type: Input
        }], pane: [{
            type: Input
        }], select: [{
            type: Input
        }], series: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorCategoryAxisComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [{
                        provide: PREFIX,
                        useValue: 'navigator.categoryAxis'
                    }, {
                        provide: ConfigurationService,
                        useClass: PrefixConfigurationService
                    }],
                selector: 'kendo-chart-navigator-category-axis',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: ɵngcc4.IntlService }, { type: String, decorators: [{
                type: Inject,
                args: [LOCALE_ID]
            }] }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorCategoryAxisCrosshairComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-navigator-category-axis-crosshair',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorCategoryAxisCrosshairTooltipComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-navigator-category-axis-crosshair-tooltip',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorCategoryAxisLabelsComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-navigator-category-axis-labels',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorCategoryAxisNotesComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-navigator-category-axis-notes',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorCategoryAxisNotesIconComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-navigator-category-axis-notes-icon',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorCategoryAxisNotesLabelComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-navigator-category-axis-notes-label',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorCategoryAxisSelectComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-navigator-category-axis-select',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorCategoryAxisTitleComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-navigator-category-axis-title',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorHintComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-navigator-hint',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, { content: [{
            type: Input
        }], format: [{
            type: Input
        }], visible: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorPaneComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [{ provide: PREFIX, useValue: 'navigator.pane' }, { provide: ConfigurationService, useClass: PrefixConfigurationService }],
                selector: 'kendo-chart-navigator-pane',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorPaneTitleComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-navigator-pane-title',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorSelectComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-navigator-select',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, { from: [{
            type: Input
        }], to: [{
            type: Input
        }], mousewheel: [{
            type: Input
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorSeriesItemComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [ConfigurationService],
                selector: 'kendo-chart-navigator-series-item',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorSeriesComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                providers: [CollectionService],
                selector: 'kendo-chart-navigator-series',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }, { type: CollectionService }, { type: TooltipTemplateService }]; }, { children: [{
            type: ContentChildren,
            args: [NavigatorSeriesItemComponent]
        }] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorSeriesErrorBarsComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-navigator-series-item-error-bars',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorSeriesExtremesComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-navigator-series-item-extremes',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorSeriesHighlightComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-navigator-series-item-highlight',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorSeriesLabelsComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-navigator-series-item-labels',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorSeriesLabelsFromComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-navigator-series-item-labels-from',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorSeriesLabelsToComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-navigator-series-item-labels-to',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorSeriesMarkersComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-navigator-series-item-markers',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorSeriesNotesComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-navigator-series-item-notes',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorSeriesNotesIconComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-navigator-series-item-notes-icon',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorSeriesNotesLabelComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-navigator-series-item-notes-label',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorSeriesOutliersComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-navigator-series-item-outliers',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(NavigatorSeriesTooltipComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                selector: 'kendo-chart-navigator-series-item-tooltip',
                template: ''
            }]
    }], function () { return [{ type: ConfigurationService }]; }, null); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SparklineComponent, [{
        type: Component,
        args: [{
                changeDetection: ChangeDetectionStrategy.OnPush,
                exportAs: 'kendoSparkline',
                providers: [
                    ConfigurationService,
                    TooltipTemplateService,
                    InstanceEventService,
                    LocalizationService,
                    {
                        provide: L10N_PREFIX,
                        useValue: 'kendo.chart'
                    }
                ],
                selector: 'kendo-sparkline',
                template: `
        <span #surface class="k-chart-surface"></span>
        <kendo-chart-crosshair-tooltips-container [popupSettings]="popupSettings">
        </kendo-chart-crosshair-tooltips-container>
        <kendo-chart-tooltip-popup [animate]="false" [wrapperClass]="tooltipWrapperClass"
            [classNames]="tooltipContentClasses" (leave)="tooltipMouseleave($event)" [popupSettings]="popupSettings">
        </kendo-chart-tooltip-popup>
        <kendo-resize-sensor (resize)="onResize($event)"></kendo-resize-sensor>
    `
            }]
    }], function () { return [{ type: ConfigurationService }, { type: ThemeService }, { type: ɵngcc0.ElementRef }, { type: ɵngcc4.IntlService }, { type: ɵngcc2.LocalizationService }, { type: ɵngcc0.NgZone }, { type: InstanceEventService }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc0.Renderer2 }]; }, { type: [{
            type: Input
        }], data: [{
            type: Input
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ChartModule, { declarations: function () { return [ChartComponent, TooltipPopupComponent, SeriesTooltipTemplateDirective, SharedTooltipTemplateDirective, CrosshairTooltipsContainerComponent, CrosshairTooltipComponent, DonutCenterTemplateDirective, AxisDefaultsComponent, AxisDefaultsCrosshairComponent, AxisDefaultsCrosshairTooltipComponent, AxisDefaultsLabelsComponent, AxisDefaultsTitleComponent, CategoryAxisComponent, CategoryAxisCrosshairComponent, CategoryAxisCrosshairTooltipComponent, CategoryAxisItemComponent, CategoryAxisLabelsComponent, CategoryAxisRangeLabelsComponent, CategoryAxisNotesComponent, CategoryAxisNotesIconComponent, CategoryAxisNotesLabelComponent, CategoryAxisSelectComponent, CategoryAxisTitleComponent, ChartAreaComponent, LegendComponent, LegendInactiveItemsComponent, LegendItemComponent, PaneComponent, PaneDefaultsComponent, PaneDefaultsTitleComponent, PanesComponent, PanesTitleComponent, PlotAreaComponent, SeriesComponent, SeriesDefaultsComponent, SeriesDefaultsLabelsComponent, SeriesDefaultsLabelsFromComponent, SeriesDefaultsLabelsToComponent, SeriesDefaultsNotesComponent, SeriesDefaultsNotesIconComponent, SeriesDefaultsNotesLabelComponent, SeriesDefaultsTooltipComponent, SeriesErrorBarsComponent, SeriesExtremesComponent, SeriesHighlightComponent, SeriesItemComponent, SeriesLabelsComponent, SeriesLabelsFromComponent, SeriesLabelsToComponent, SeriesMarkersComponent, SeriesNotesComponent, SeriesNotesIconComponent, SeriesNotesLabelComponent, SeriesOutliersComponent, SeriesTooltipComponent, TitleComponent, TooltipComponent, ValueAxisComponent, ValueAxisCrosshairComponent, ValueAxisCrosshairTooltipComponent, ValueAxisItemComponent, ValueAxisLabelsComponent, ValueAxisNotesComponent, ValueAxisNotesIconComponent, ValueAxisNotesLabelComponent, ValueAxisTitleComponent, XAxisComponent, XAxisCrosshairComponent, XAxisCrosshairTooltipComponent, XAxisItemComponent, XAxisLabelsComponent, XAxisNotesComponent, XAxisNotesIconComponent, XAxisNotesLabelComponent, XAxisTitleComponent, YAxisComponent, YAxisCrosshairComponent, YAxisCrosshairTooltipComponent, YAxisItemComponent, YAxisLabelsComponent, YAxisNotesComponent, YAxisNotesIconComponent, YAxisNotesLabelComponent, YAxisTitleComponent, ZoomableComponent]; }, imports: function () { return [CommonModule, PopupModule, ResizeSensorModule]; }, exports: function () { return [ChartComponent, TooltipPopupComponent, SeriesTooltipTemplateDirective, SharedTooltipTemplateDirective, CrosshairTooltipsContainerComponent, CrosshairTooltipComponent, DonutCenterTemplateDirective, AxisDefaultsComponent, AxisDefaultsCrosshairComponent, AxisDefaultsCrosshairTooltipComponent, AxisDefaultsLabelsComponent, AxisDefaultsTitleComponent, CategoryAxisComponent, CategoryAxisCrosshairComponent, CategoryAxisCrosshairTooltipComponent, CategoryAxisItemComponent, CategoryAxisLabelsComponent, CategoryAxisRangeLabelsComponent, CategoryAxisNotesComponent, CategoryAxisNotesIconComponent, CategoryAxisNotesLabelComponent, CategoryAxisSelectComponent, CategoryAxisTitleComponent, ChartAreaComponent, LegendComponent, LegendInactiveItemsComponent, LegendItemComponent, PaneComponent, PaneDefaultsComponent, PaneDefaultsTitleComponent, PanesComponent, PanesTitleComponent, PlotAreaComponent, SeriesComponent, SeriesDefaultsComponent, SeriesDefaultsLabelsComponent, SeriesDefaultsLabelsFromComponent, SeriesDefaultsLabelsToComponent, SeriesDefaultsNotesComponent, SeriesDefaultsNotesIconComponent, SeriesDefaultsNotesLabelComponent, SeriesDefaultsTooltipComponent, SeriesErrorBarsComponent, SeriesExtremesComponent, SeriesHighlightComponent, SeriesItemComponent, SeriesLabelsComponent, SeriesLabelsFromComponent, SeriesLabelsToComponent, SeriesMarkersComponent, SeriesNotesComponent, SeriesNotesIconComponent, SeriesNotesLabelComponent, SeriesOutliersComponent, SeriesTooltipComponent, TitleComponent, TooltipComponent, ValueAxisComponent, ValueAxisCrosshairComponent, ValueAxisCrosshairTooltipComponent, ValueAxisItemComponent, ValueAxisLabelsComponent, ValueAxisNotesComponent, ValueAxisNotesIconComponent, ValueAxisNotesLabelComponent, ValueAxisTitleComponent, XAxisComponent, XAxisCrosshairComponent, XAxisCrosshairTooltipComponent, XAxisItemComponent, XAxisLabelsComponent, XAxisNotesComponent, XAxisNotesIconComponent, XAxisNotesLabelComponent, XAxisTitleComponent, YAxisComponent, YAxisCrosshairComponent, YAxisCrosshairTooltipComponent, YAxisItemComponent, YAxisLabelsComponent, YAxisNotesComponent, YAxisNotesIconComponent, YAxisNotesLabelComponent, YAxisTitleComponent, ZoomableComponent]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ChartModule, [{
        type: NgModule,
        args: [{
                declarations: [CHART_DIRECTIVES],
                exports: [CHART_DIRECTIVES],
                imports: [CommonModule, PopupModule, ResizeSensorModule],
                providers: [
                    ThemeService
                ]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(StockChartModule, { declarations: function () { return [StockChartComponent, NavigatorComponent, NavigatorCategoryAxisComponent, NavigatorCategoryAxisCrosshairComponent, NavigatorCategoryAxisCrosshairTooltipComponent, NavigatorCategoryAxisLabelsComponent, NavigatorCategoryAxisNotesComponent, NavigatorCategoryAxisNotesIconComponent, NavigatorCategoryAxisNotesLabelComponent, NavigatorCategoryAxisSelectComponent, NavigatorCategoryAxisTitleComponent, NavigatorHintComponent, NavigatorPaneComponent, NavigatorPaneTitleComponent, NavigatorSelectComponent, NavigatorSeriesComponent, NavigatorSeriesItemComponent, NavigatorSeriesErrorBarsComponent, NavigatorSeriesExtremesComponent, NavigatorSeriesHighlightComponent, NavigatorSeriesLabelsComponent, NavigatorSeriesLabelsFromComponent, NavigatorSeriesLabelsToComponent, NavigatorSeriesMarkersComponent, NavigatorSeriesNotesComponent, NavigatorSeriesNotesIconComponent, NavigatorSeriesNotesLabelComponent, NavigatorSeriesOutliersComponent, NavigatorSeriesTooltipComponent]; }, imports: function () { return [ChartModule, CommonModule, PopupModule, ResizeSensorModule]; }, exports: function () { return [StockChartComponent, NavigatorComponent, NavigatorCategoryAxisComponent, NavigatorCategoryAxisCrosshairComponent, NavigatorCategoryAxisCrosshairTooltipComponent, NavigatorCategoryAxisLabelsComponent, NavigatorCategoryAxisNotesComponent, NavigatorCategoryAxisNotesIconComponent, NavigatorCategoryAxisNotesLabelComponent, NavigatorCategoryAxisSelectComponent, NavigatorCategoryAxisTitleComponent, NavigatorHintComponent, NavigatorPaneComponent, NavigatorPaneTitleComponent, NavigatorSelectComponent, NavigatorSeriesComponent, NavigatorSeriesItemComponent, NavigatorSeriesErrorBarsComponent, NavigatorSeriesExtremesComponent, NavigatorSeriesHighlightComponent, NavigatorSeriesLabelsComponent, NavigatorSeriesLabelsFromComponent, NavigatorSeriesLabelsToComponent, NavigatorSeriesMarkersComponent, NavigatorSeriesNotesComponent, NavigatorSeriesNotesIconComponent, NavigatorSeriesNotesLabelComponent, NavigatorSeriesOutliersComponent, NavigatorSeriesTooltipComponent, ChartModule]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(StockChartModule, [{
        type: NgModule,
        args: [{
                declarations: [STOCK_CHART_DIRECTIVES],
                exports: [STOCK_CHART_DIRECTIVES, ChartModule],
                imports: [ChartModule, CommonModule, PopupModule, ResizeSensorModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(SparklineModule, { declarations: function () { return [SparklineComponent]; }, imports: function () { return [ChartModule, CommonModule, PopupModule, ResizeSensorModule]; }, exports: function () { return [SparklineComponent, ChartModule]; } }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(SparklineModule, [{
        type: NgModule,
        args: [{
                declarations: [SPARKLINE_DIRECTIVES],
                exports: [SPARKLINE_DIRECTIVES, ChartModule],
                imports: [ChartModule, CommonModule, PopupModule, ResizeSensorModule]
            }]
    }], null, null); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(ChartsModule, { exports: [ChartModule, SparklineModule, StockChartModule] }); })();
(function () { (typeof ngDevMode === "undefined" || ngDevMode) && ɵngcc0.ɵsetClassMetadata(ChartsModule, [{
        type: NgModule,
        args: [{
                exports: [ChartModule, SparklineModule, StockChartModule]
            }]
    }], null, null); })();

const ɵStockInstanceEventService_BaseFactory = /*@__PURE__*/ ɵngcc0.ɵɵgetInheritedFactory(StockInstanceEventService);

/**
 * Generated bundle index. Do not edit.
 */

export { ChartComponentGenerated, AxisDefaultsComponentGenerated, AxisDefaultsCrosshairComponentGenerated, AxisDefaultsCrosshairTooltipComponentGenerated, AxisDefaultsLabelsComponentGenerated, AxisDefaultsTitleComponentGenerated, CategoryAxisItemComponentGenerated, CategoryAxisCrosshairComponentGenerated, CategoryAxisCrosshairTooltipComponentGenerated, CategoryAxisNotesComponentGenerated, CategoryAxisNotesIconComponentGenerated, CategoryAxisNotesLabelComponentGenerated, CategoryAxisSelectComponentGenerated, CategoryAxisTitleComponentGenerated, CategoryAxisComponentGenerated, ChartAreaComponentGenerated, DonutCenterTemplateDirective, LegendComponentGenerated, LegendInactiveItemsComponentGenerated, LegendItemComponentGenerated, PaneComponentGenerated, PanesTitleComponentGenerated, PanesComponentGenerated, PlotAreaComponentGenerated, SeriesDefaultsComponentGenerated, SeriesDefaultsLabelsComponentGenerated, SeriesDefaultsLabelsFromComponentGenerated, SeriesDefaultsLabelsToComponentGenerated, SeriesDefaultsNotesComponentGenerated, SeriesDefaultsNotesIconComponentGenerated, SeriesDefaultsNotesLabelComponentGenerated, SeriesDefaultsTooltipComponentGenerated, SeriesItemComponentGenerated, SeriesErrorBarsComponentGenerated, SeriesExtremesComponentGenerated, SeriesHighlightComponentGenerated, SeriesLabelsComponentGenerated, SeriesLabelsFromComponentGenerated, SeriesLabelsToComponentGenerated, SeriesMarkersComponentGenerated, SeriesNotesComponentGenerated, SeriesNotesIconComponentGenerated, SeriesNotesLabelComponentGenerated, SeriesOutliersComponentGenerated, SeriesTooltipComponentGenerated, SeriesComponentGenerated, TitleComponentGenerated, TooltipComponentGenerated, BaseTooltip, bodyFactory, CrosshairTooltipComponent, SeriesTooltipTemplateDirective, SharedTooltipTemplateDirective, ValueAxisItemComponentGenerated, ValueAxisCrosshairComponentGenerated, ValueAxisCrosshairTooltipComponentGenerated, ValueAxisLabelsComponentGenerated, ValueAxisNotesComponentGenerated, ValueAxisNotesIconComponentGenerated, ValueAxisNotesLabelComponentGenerated, ValueAxisTitleComponentGenerated, ValueAxisComponentGenerated, XAxisItemComponentGenerated, XAxisCrosshairComponentGenerated, XAxisCrosshairTooltipComponentGenerated, XAxisLabelsComponentGenerated, XAxisNotesComponentGenerated, XAxisNotesIconComponentGenerated, XAxisNotesLabelComponentGenerated, XAxisTitleComponentGenerated, XAxisComponentGenerated, YAxisItemComponentGenerated, YAxisCrosshairComponentGenerated, YAxisCrosshairTooltipComponentGenerated, YAxisLabelsComponentGenerated, YAxisNotesComponentGenerated, YAxisNotesIconComponentGenerated, YAxisNotesLabelComponentGenerated, YAxisTitleComponentGenerated, YAxisComponentGenerated, ZoomableComponentGenerated, CollectionItemComponent, CollectionComponent, CollectionService, ConfigurationService, PREFIX, PrefixConfigurationService, RootConfigurationService, SettingsComponent, ThemeService, TooltipTemplateService, BaseEvent, InstanceEventService, LegendEvent, NoteEvent, PreventableEvent, SeriesEvent, StockInstanceEventService, NavigatorComponent, NavigatorCategoryAxisComponent, NavigatorCategoryAxisCrosshairComponent, NavigatorCategoryAxisCrosshairTooltipComponent, NavigatorCategoryAxisLabelsComponent, NavigatorCategoryAxisNotesComponent, NavigatorCategoryAxisNotesIconComponent, NavigatorCategoryAxisNotesLabelComponent, NavigatorCategoryAxisSelectComponent, NavigatorCategoryAxisTitleComponent, NavigatorHintComponent, NavigatorPaneComponent, NavigatorPaneTitleComponent, NavigatorSelectComponent, NavigatorSeriesItemComponent, NavigatorSeriesErrorBarsComponent, NavigatorSeriesExtremesComponent, NavigatorSeriesHighlightComponent, NavigatorSeriesLabelsComponent, NavigatorSeriesLabelsFromComponent, NavigatorSeriesLabelsToComponent, NavigatorSeriesMarkersComponent, NavigatorSeriesNotesComponent, NavigatorSeriesNotesIconComponent, NavigatorSeriesNotesLabelComponent, NavigatorSeriesOutliersComponent, NavigatorSeriesTooltipComponent, NavigatorSeriesComponent, ChartModule, StockChartModule, SparklineModule, ChartsModule, TooltipPopupComponent, CrosshairTooltipsContainerComponent, ChartComponent, AxisDefaultsComponent, AxisDefaultsCrosshairComponent, AxisDefaultsCrosshairTooltipComponent, AxisDefaultsLabelsComponent, AxisDefaultsTitleComponent, CategoryAxisComponent, CategoryAxisCrosshairComponent, CategoryAxisCrosshairTooltipComponent, CategoryAxisItemComponent, CategoryAxisLabelsComponent, CategoryAxisRangeLabelsComponent, CategoryAxisNotesComponent, CategoryAxisNotesIconComponent, CategoryAxisNotesLabelComponent, CategoryAxisSelectComponent, CategoryAxisTitleComponent, ChartAreaComponent, LegendComponent, LegendInactiveItemsComponent, LegendItemComponent, PaneComponent, PaneDefaultsComponent, PaneDefaultsTitleComponent, PanesComponent, PanesTitleComponent, PlotAreaComponent, SeriesComponent, SeriesDefaultsComponent, SeriesDefaultsLabelsComponent, SeriesDefaultsLabelsFromComponent, SeriesDefaultsLabelsToComponent, SeriesDefaultsNotesComponent, SeriesDefaultsNotesIconComponent, SeriesDefaultsNotesLabelComponent, SeriesDefaultsTooltipComponent, SeriesErrorBarsComponent, SeriesExtremesComponent, SeriesHighlightComponent, SeriesItemComponent, SeriesLabelsComponent, SeriesLabelsFromComponent, SeriesLabelsToComponent, SeriesMarkersComponent, SeriesNotesComponent, SeriesNotesIconComponent, SeriesNotesLabelComponent, SeriesOutliersComponent, SeriesTooltipComponent, TitleComponent, TooltipComponent, ValueAxisComponent, ValueAxisCrosshairComponent, ValueAxisCrosshairTooltipComponent, ValueAxisItemComponent, ValueAxisLabelsComponent, ValueAxisNotesComponent, ValueAxisNotesIconComponent, ValueAxisNotesLabelComponent, ValueAxisTitleComponent, XAxisComponent, XAxisCrosshairComponent, XAxisCrosshairTooltipComponent, XAxisItemComponent, XAxisLabelsComponent, XAxisNotesComponent, XAxisNotesIconComponent, XAxisNotesLabelComponent, XAxisTitleComponent, YAxisComponent, YAxisCrosshairComponent, YAxisCrosshairTooltipComponent, YAxisItemComponent, YAxisLabelsComponent, YAxisNotesComponent, YAxisNotesIconComponent, YAxisNotesLabelComponent, YAxisTitleComponent, ZoomableComponent, CHART_DIRECTIVES, AxisLabelClickEvent, DragEndEvent, DragEvent, DragStartEvent, LegendItemClickEvent, LegendItemHoverEvent, NoteClickEvent, NoteHoverEvent, PaneRenderEvent, PlotAreaClickEvent, PlotAreaHoverEvent, RenderEvent, SelectEndEvent, SelectEvent, SelectStartEvent, SeriesClickEvent, SeriesHoverEvent, ZoomEndEvent, ZoomEvent, ZoomStartEvent, WeekStartDay, NavigatorFilterEvent, StockChartComponent, STOCK_CHART_DIRECTIVES, SparklineComponent, SPARKLINE_DIRECTIVES };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VzIjpbImluZGV4LmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Z3BDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d0pBQUU7QUFDRixtQ0FFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NEhBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzZKQUFFO0FBQ0YsMkNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OytJQUFFO0FBQ0YsZ0NBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvSUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzRqRUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt3SEFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswU0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O29MQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O29PQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FPRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Z0lBQUU7QUFDRiwyQkFFRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzhKQUcyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O21LQUFFO0FBQ0YsNkNBSUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzttS0FBRTtBQUNGLDZDQUlHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7bUVBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O2lNQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQXlDRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7MkRBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FlRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7c0ZBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdGQVN3QztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7K01BQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBMkJHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2toQkFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MlNBQUU7QUFDRixvQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3dTQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztnVkFBRTtBQUNGLDZDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d1VBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzZXQUFFO0FBQ0Ysb0RBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvWEFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvVUFBRTtBQUNGLDBDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OFhBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Z1VBQUU7QUFDRix5Q0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7bUZBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswNEJBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3VaQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FPRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OzswREFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MlZBQUU7QUFDRixvQ0FPRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d1NBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3FWQUFFO0FBQ0YsNkNBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt3VUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2tYQUFFO0FBQ0Ysb0RBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsycEJBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OFZBQUU7QUFDRiwrQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2dSQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7cVVBQUU7QUFDRix5Q0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2tSQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3NWQUFFO0FBQ0YsNkNBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt3V0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBWQUFFO0FBQ0YsOENBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswUEFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7eVVBQUU7QUFDRiwwQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzhYQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3FVQUFFO0FBQ0YseUNBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztrUkFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt5UkFBRTtBQUNGLGlDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c2hCQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7a1JBQUU7QUFDRiw4QkFNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O29NQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3dVQUFFO0FBQ0YsMkNBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvTUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O21TQUFFO0FBQ0Ysa0NBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O29TQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7eVZBQUU7QUFDRiw0QkFPRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt5YkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvZUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OzswREFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OFRBQUU7QUFDRiw2QkFPRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c1VBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztrU0FBRTtBQUNGLGtDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7a1FBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzJSQUFFO0FBQ0YsZ0NBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7MERBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztrVUFBRTtBQUNGLDhCQU9HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzRXQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7bVRBQUU7QUFDRixzQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3dZQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs0VUFBRTtBQUNGLDRDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c1dBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzZWQUFFO0FBQ0YsZ0RBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztrV0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7cVZBQUU7QUFDRiw4Q0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2dQQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt3VUFBRTtBQUNGLDJDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c1JBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7eVZBQUU7QUFDRiwrQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzRXQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NlZBQUU7QUFDRixnREFNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBUQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2dWQUFFO0FBQ0YsNkNBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztrU0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs2VEFBRTtBQUNGLHVDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c1FBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3dUQUFFO0FBQ0Ysc0NBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswVEFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NFRBQUU7QUFDRix1Q0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBjQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Z1RBQUU7QUFDRixvQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzRXQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2lVQUFFO0FBQ0Ysd0NBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt3V0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt5VEFBRTtBQUNGLHNDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7a1VBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b1RBQUU7QUFDRixxQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3NQQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NFNBQUU7QUFDRixtQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3NRQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzZUQUFFO0FBQ0YsdUNBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs0VkFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2lVQUFFO0FBQ0Ysd0NBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzUUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d1RBQUU7QUFDRixzQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzhVQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs4UUFBRTtBQUNGLDZCQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b1VBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7MEpBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBS0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c3BCQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7bVdBQUU7QUFDRixxQ0FPRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7OzBEQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsrVUFBRTtBQUNGLGlDQU9HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs0UUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3lVQUFFO0FBQ0YsMENBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztrVUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3NXQUFFO0FBQ0YsaURBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztnY0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzZUQUFFO0FBQ0YsdUNBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswUUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3lUQUFFO0FBQ0Ysc0NBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs0UUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswVUFBRTtBQUNGLDBDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7a1dBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs4VUFBRTtBQUNGLDJDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d1hBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7eVRBQUU7QUFDRixzQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs0dEJBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3lYQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FPRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7OzswREFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OytUQUFFO0FBQ0YsNkJBT0c7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O29RQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt5VEFBRTtBQUNGLHNDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MFRBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzVkFBRTtBQUNGLDZDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7d2VBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NlNBQUU7QUFDRixtQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2tRQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt5U0FBRTtBQUNGLGtDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b1FBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MFRBQUU7QUFDRixzQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBWQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OFRBQUU7QUFDRix1Q0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2dYQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3lTQUFFO0FBQ0Ysa0NBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O29xQkFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7eVhBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQU9HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7MERBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsrVEFBRTtBQUNGLDZCQU9HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvUUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7eVRBQUU7QUFDRixzQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBUQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7c1ZBQUU7QUFDRiw2Q0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3dlQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzZTQUFFO0FBQ0YsbUNBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztrUUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7eVNBQUU7QUFDRixrQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O29RQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBUQUFFO0FBQ0Ysc0NBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzswVkFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzhUQUFFO0FBQ0YsdUNBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztnWEFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt5U0FBRTtBQUNGLGtDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OE1BQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBSQUFFO0FBQ0YsZ0NBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztvS0FHNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsySUFBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozt5SkFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBeUJHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzBLQUFFO0FBQ0YseUNBRUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs4aUJBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FPRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7eUxBQUU7QUFDRiw2Q0FhRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztxWEFBRTtBQUNGLHNEQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztrWkFBRTtBQUNGLDZEQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7eVdBQUU7QUFDRixtREFNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3FXQUFFO0FBQ0Ysa0RBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzWEFBRTtBQUNGLHNEQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7MFhBQUU7QUFDRix1REFNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3lXQUFFO0FBQ0YsbURBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztxV0FBRTtBQUNGLGtEQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztxWEFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzY0FBRTtBQUNGLHFDQU9HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7b1VBQUU7QUFDRiwwQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7cVhBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzsyWEFBRTtBQUNGLDJDQU9HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7O3NPQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FPRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztrV0FBRTtBQUNGLGdEQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NlZBQUU7QUFDRiwrQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2lXQUFFO0FBQ0YsZ0RBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3FWQUFFO0FBQ0YsNkNBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O3NXQUFFO0FBQ0YsaURBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OzhWQUFFO0FBQ0YsK0NBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzt5VkFBRTtBQUNGLDhDQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7aVZBQUU7QUFDRiw0Q0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2tXQUFFO0FBQ0YsZ0RBTUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztzV0FBRTtBQUNGLGlEQU1HO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7NlZBQUU7QUFDRiwrQ0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7eVZBQUU7QUFDRiw4Q0FNRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O3lKQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQXlCRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztxRUFVZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7bU9BT3FCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O2dPQU9vQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7cUhBS2lCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXNDb250ZW50IjpbIi8qKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG4qIENvcHlyaWdodCDCqSAyMDIxIFByb2dyZXNzIFNvZnR3YXJlIENvcnBvcmF0aW9uLiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuKiBMaWNlbnNlZCB1bmRlciBjb21tZXJjaWFsIGxpY2Vuc2UuIFNlZSBMSUNFTlNFLm1kIGluIHRoZSBwcm9qZWN0IHJvb3QgZm9yIG1vcmUgaW5mb3JtYXRpb25cbiotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cbmltcG9ydCB7IF9fZGVjb3JhdGUsIF9fbWV0YWRhdGEsIF9fcGFyYW0gfSBmcm9tICd0c2xpYic7XG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIEluamVjdGFibGUsIE5nWm9uZSwgRGlyZWN0aXZlLCBPcHRpb25hbCwgVGVtcGxhdGVSZWYsIFNpbXBsZUNoYW5nZSwgQ29udGVudENoaWxkLCBDb21wb25lbnQsIENoYW5nZURldGVjdGlvblN0cmF0ZWd5LCBFbGVtZW50UmVmLCBWaWV3Q2hpbGQsIFZpZXdDaGlsZHJlbiwgUXVlcnlMaXN0LCBpc0Rldk1vZGUsIENvbnRlbnRDaGlsZHJlbiwgQ2hhbmdlRGV0ZWN0b3JSZWYsIFJlbmRlcmVyMiwgSW5qZWN0LCBMT0NBTEVfSUQsIEluamVjdGlvblRva2VuLCBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQmVoYXZpb3JTdWJqZWN0LCBTdWJqZWN0LCBjb21iaW5lTGF0ZXN0IH0gZnJvbSAncnhqcyc7XG5pbXBvcnQgeyBhdWRpdFRpbWUsIHRhcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IHZhbGlkYXRlUGFja2FnZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1saWNlbnNpbmcnO1xuaW1wb3J0IHsgY2hhcnRCYXNlVGhlbWUsIEluc3RhbmNlT2JzZXJ2ZXIsIERhdGVDYXRlZ29yeUF4aXMsIERhdGVWYWx1ZUF4aXMsIERvbUV2ZW50c0J1aWxkZXIsIENoYXJ0LCBTdG9ja0NoYXJ0LCBTcGFya2xpbmUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tY2hhcnRzJztcbmltcG9ydCB7IGlzRG9jdW1lbnRBdmFpbGFibGUsIFJlc2l6ZVNlbnNvck1vZHVsZSB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWNvbW1vbic7XG5leHBvcnQgeyBSZXNpemVTZW5zb3JDb21wb25lbnQgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1jb21tb24nO1xuaW1wb3J0IHsgUG9wdXBTZXJ2aWNlLCBQT1BVUF9DT05UQUlORVIsIFBvcHVwTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItcG9wdXAnO1xuZXhwb3J0IHsgUG9wdXBDb21wb25lbnQgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1wb3B1cCc7XG5pbXBvcnQgeyBMb2NhbGl6YXRpb25TZXJ2aWNlLCBMMTBOX1BSRUZJWCB9IGZyb20gJ0Bwcm9ncmVzcy9rZW5kby1hbmd1bGFyLWwxMG4nO1xuaW1wb3J0IHsgSW50bFNlcnZpY2UgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1pbnRsJztcbmltcG9ydCB7IGV4cG9ydEltYWdlLCBleHBvcnRTVkcgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tZHJhd2luZyc7XG5pbXBvcnQgeyBDb21tb25Nb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgcGFja2FnZU1ldGFkYXRhID0ge1xuICAgIG5hbWU6ICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1jaGFydHMnLFxuICAgIHByb2R1Y3ROYW1lOiAnS2VuZG8gVUkgZm9yIEFuZ3VsYXInLFxuICAgIHByb2R1Y3RDb2RlczogWydLRU5ET1VJQU5HVUxBUicsICdLRU5ET1VJQ09NUExFVEUnXSxcbiAgICBwdWJsaXNoRGF0ZTogMTYzODE2NjI3MyxcbiAgICB2ZXJzaW9uOiAnJyxcbiAgICBsaWNlbnNpbmdEb2NzVXJsOiAnaHR0cHM6Ly93d3cudGVsZXJpay5jb20va2VuZG8tYW5ndWxhci11aS9teS1saWNlbnNlLz91dG1fbWVkaXVtPXByb2R1Y3QmdXRtX3NvdXJjZT1rZW5kb2FuZ3VsYXImdXRtX2NhbXBhaWduPWtlbmRvLXVpLWFuZ3VsYXItcHVyY2hhc2UtbGljZW5zZS1rZXlzLXdhcm5pbmcnXG59O1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgY2xpY2tzIGFuIGF4aXMgbGFiZWwgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19jaGFydF9jaGFydHMgJX0jdG9jLWV2ZW50cykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5heGlzTGFiZWxDbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGFzIGxvbmcgYXMgdGhlIHVzZXIgaXMgZHJhZ2dpbmcgdGhlIENoYXJ0IHdpdGggdGhlIG1vdXNlIG9yIHRocm91Z2ggc3dpcGUgZ2VzdHVyZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmRyYWcgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIHN0b3BzIGRyYWdnaW5nIHRoZSBDaGFydC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHJhZ0VuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgc3RhcnRzIGRyYWdnaW5nIHRoZSBDaGFydC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuZHJhZ1N0YXJ0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBob3ZlcnMgb3ZlciBhIGxlZ2VuZCBpdGVtIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfY2hhcnRfY2hhcnRzICV9I3RvYy1ldmVudHMpKS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubGVnZW5kSXRlbUhvdmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgY3Vyc29yIGxlYXZlcyBhIGxlZ2VuZCBpdGVtLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sZWdlbmRJdGVtTGVhdmUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGNsaWNrcyBhIG5vdGUuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5vdGVDbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgaG92ZXJzIG92ZXIgYSBub3RlLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5ub3RlSG92ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBjdXJzb3IgbGVhdmVzIGEgbm90ZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMubm90ZUxlYXZlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiBhIHBhbmUgaXMgcmVuZGVyZWQgYmVjYXVzZSB0aGUgQ2hhcnQ6XG4gICAgICAgICAqICogSXMgcmVuZGVyZWQuXG4gICAgICAgICAqICogUGVyZm9ybXMgcGFubmluZyBvciB6b29taW5nLlxuICAgICAgICAgKiAqIElzIGV4cG9ydGVkIHdpdGggZGlmZmVyZW50IG9wdGlvbnMuXG4gICAgICAgICAqIFRoZSBldmVudCBpcyB1c2VkIHRvIHJlbmRlciBjdXN0b20gdmlzdWFscyBpbiB0aGUgcGFuZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnBhbmVSZW5kZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgcGxvdCBhcmVhIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfY2hhcnRfY2hhcnRzICV9I3RvYy1ldmVudHMpKS5cbiAgICAgICAgICogVGhlIGBjbGlja2AgZXZlbnQgaXMgdHJpZ2dlcmVkIGJ5IHRoZSBgdGFwYCBhbmQgYGNvbnRleHRtZW51YCBldmVudHMuXG4gICAgICAgICAqIFRvIGRpc3Rpbmd1aXNoIGJldHdlZW4gdGhlIG9yaWdpbmFsIGV2ZW50cywgaW5zcGVjdCB0aGUgYGUub3JpZ2luYWxFdmVudC50eXBlYCBmaWVsZC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMucGxvdEFyZWFDbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgaG92ZXJzIHRoZSBwbG90IGFyZWEgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19jaGFydF9jaGFydHMgJX0jdG9jLWV2ZW50cykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wbG90QXJlYUhvdmVyID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgY3Vyc29yIGxlYXZlcyB0aGUgcGxvdCBhcmVhLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5wbG90QXJlYUxlYXZlID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgQ2hhcnQgaXMgcmVhZHkgdG8gcmVuZGVyIG9uIHNjcmVlbiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X2NoYXJ0X2NoYXJ0cyAlfSN0b2MtZXZlbnRzKSkuXG4gICAgICAgICAqIEZvciBleGFtcGxlLCB5b3UgY2FuIHVzZSBpdCB0byByZW1vdmUgbG9hZGluZyBpbmRpY2F0b3JzLlxuICAgICAgICAgKiBBbnkgY2hhbmdlcyBtYWRlIHRvIHRoZSBvcHRpb25zIGFyZSBpZ25vcmVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5yZW5kZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIG1vZGlmaWVzIHRoZSBzZWxlY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSByYW5nZSB1bml0cyBhcmU6XG4gICAgICAgICAqIC0gR2VuZXJpYyBheGlzJm1kYXNoO0NhdGVnb3J5IGluZGV4ICgwLWJhc2VkKS5cbiAgICAgICAgICogLSBEYXRlIGF4aXMmbWRhc2g7RGF0ZSBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBjb21wbGV0ZXMgdGhlIG1vZGlmaWNhdGlvbiBvZiB0aGUgc2VsZWN0aW9uLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgcmFuZ2UgdW5pdHMgYXJlOlxuICAgICAgICAgKiAtIEdlbmVyaWMgYXhpcyZtZGFzaDtDYXRlZ29yeSBpbmRleCAoMC1iYXNlZCkuXG4gICAgICAgICAqIC0gRGF0ZSBheGlzJm1kYXNoO0RhdGUgaW5zdGFuY2UuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlbGVjdEVuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgc3RhcnRzIG1vZGlmeWluZyB0aGUgYXhpcyBzZWxlY3Rpb24uXG4gICAgICAgICAqXG4gICAgICAgICAqIFRoZSByYW5nZSB1bml0cyBhcmU6XG4gICAgICAgICAqIC0gR2VuZXJpYyBheGlzJm1kYXNoO0NhdGVnb3J5IGluZGV4ICgwLWJhc2VkKS5cbiAgICAgICAgICogLSBEYXRlIGF4aXMmbWRhc2g7RGF0ZSBpbnN0YW5jZS5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2VsZWN0U3RhcnQgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSB1c2VyIGNsaWNrcyB0aGUgQ2hhcnQgc2VyaWVzLlxuICAgICAgICAgKlxuICAgICAgICAgKiBUaGUgYGNsaWNrYCBldmVudCB3aWxsIGJlIHRyaWdnZXJlZCBieSB0aGUgYHRhcGAgYW5kIGBjb250ZXh0bWVudWAgZXZlbnRzIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfY2hhcnRfY2hhcnRzICV9I3RvYy1ldmVudHMpKS5cbiAgICAgICAgICogVG8gZGlzdGluZ3Vpc2ggYmV0d2VlbiB0aGUgb3JpZ2luYWwgZXZlbnRzLCBpbnNwZWN0IHRoZSBgZS5vcmlnaW5hbEV2ZW50LnR5cGVgIGZpZWxkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXJpZXNDbGljayA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgaG92ZXJzIHRoZSBDaGFydCBzZXJpZXMgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBvdmVydmlld19jaGFydF9jaGFydHMgJX0jdG9jLWV2ZW50cykpLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXJpZXNIb3ZlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIGN1cnNvciBlbnRlcnMgYSBzZXJpZXMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnNlcmllc092ZXIgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaXJlcyB3aGVuIHRoZSBjdXJzb3IgbGVhdmVzIGEgc2VyaWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5zZXJpZXNMZWF2ZSA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIGFzIGxvbmcgYXMgdGhlIHVzZXIgaXMgem9vbWluZyB0aGUgQ2hhcnQgYnkgdXNpbmcgdGhlIG1vdXNld2hlZWwgb3BlcmF0aW9uLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy56b29tID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgdXNlciBzdG9wcyB6b29taW5nIHRoZSBDaGFydC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuem9vbUVuZCA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEZpcmVzIHdoZW4gdGhlIHVzZXIgdXNlcyB0aGUgbW91c2V3aGVlbCB0byB6b29tIHRoZSBDaGFydC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuem9vbVN0YXJ0ID0gbmV3IEV2ZW50RW1pdHRlcigpO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwYW5uYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInJlbmRlckFzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzZXJpZXNDb2xvcnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0cmFuc2l0aW9uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInpvb21hYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYXhpc0RlZmF1bHRzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY2F0ZWdvcnlBeGlzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY2hhcnRBcmVhXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibGVnZW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwYW5lc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhbmVEZWZhdWx0c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBsb3RBcmVhXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzZXJpZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzZXJpZXNEZWZhdWx0c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInRvb2x0aXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2YWx1ZUF4aXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ4QXhpc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInlBeGlzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImF4aXNMYWJlbENsaWNrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImRyYWdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZHJhZ0VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJkcmFnU3RhcnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibGVnZW5kSXRlbUhvdmVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxlZ2VuZEl0ZW1MZWF2ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJub3RlQ2xpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibm90ZUhvdmVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm5vdGVMZWF2ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwYW5lUmVuZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBsb3RBcmVhQ2xpY2tcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGxvdEFyZWFIb3ZlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwbG90QXJlYUxlYXZlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInJlbmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzZWxlY3RcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic2VsZWN0RW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInNlbGVjdFN0YXJ0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInNlcmllc0NsaWNrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInNlcmllc0hvdmVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInNlcmllc092ZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic2VyaWVzTGVhdmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBDaGFydENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiem9vbVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIENoYXJ0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ6b29tRW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInpvb21TdGFydFwiLCB2b2lkIDApO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY29uc3QgVEhST1RUTEVfTVMgPSAxMDAwIC8gNjA7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ2hhbmdlIHtcbiAgICBjb25zdHJ1Y3RvcihrZXksIHZhbHVlKSB7XG4gICAgICAgIHRoaXMua2V5ID0ga2V5O1xuICAgICAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gICAgfVxufVxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmxldCBDb25maWd1cmF0aW9uU2VydmljZSA9IGNsYXNzIENvbmZpZ3VyYXRpb25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihuZ1pvbmUpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMuc3RvcmUgPSB7fTtcbiAgICAgICAgdGhpcy5zb3VyY2UgPSBuZXcgQmVoYXZpb3JTdWJqZWN0KHt9KTtcbiAgICAgICAgdGhpcy5pbml0U291cmNlKCk7XG4gICAgfVxuICAgIGluaXRTb3VyY2UoKSB7XG4gICAgICAgIHRoaXMub25GYXN0Q2hhbmdlJCA9IHRoaXMuc291cmNlLmFzT2JzZXJ2YWJsZSgpO1xuICAgICAgICB0aGlzLm9uQ2hhbmdlJCA9IHRoaXMub25GYXN0Q2hhbmdlJC5waXBlKGF1ZGl0VGltZShUSFJPVFRMRV9NUykpO1xuICAgIH1cbiAgICBwdXNoKHN0b3JlKSB7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBzdG9yZTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIG5vdGlmeShjaGFuZ2UpIHtcbiAgICAgICAgdGhpcy5zZXQoY2hhbmdlLmtleSwgY2hhbmdlLnZhbHVlKTtcbiAgICAgICAgdGhpcy5uZXh0KCk7XG4gICAgfVxuICAgIHNldChmaWVsZCwgdmFsdWUpIHtcbiAgICAgICAgbGV0IHN0b3JlID0gdGhpcy5zdG9yZTtcbiAgICAgICAgY29uc3QgcGFydHMgPSBmaWVsZC5zcGxpdCgnLicpO1xuICAgICAgICBsZXQga2V5ID0gcGFydHMuc2hpZnQoKTtcbiAgICAgICAgd2hpbGUgKHBhcnRzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHN0b3JlID0gc3RvcmVba2V5XSA9IHN0b3JlW2tleV0gfHwge307XG4gICAgICAgICAgICBrZXkgPSBwYXJ0cy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JlW2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgbmV4dCgpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zb3VyY2UubmV4dCh0aGlzLnN0b3JlKTtcbiAgICAgICAgfSk7XG4gICAgfVxufTtcbkNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmdab25lXSlcbl0sIENvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEJhc2VFdmVudCB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHNlbmRlcikge1xuICAgICAgICB0aGlzLnNlbmRlciA9IHNlbmRlcjtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBQcmV2ZW50YWJsZUV2ZW50IGV4dGVuZHMgQmFzZUV2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoLi4uYXJndW1lbnRzKTtcbiAgICAgICAgdGhpcy5wcmV2ZW50ZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUHJldmVudHMgdGhlIGRlZmF1bHQgYWN0aW9uIGZvciBhIHNwZWNpZmllZCBldmVudC5cbiAgICAgKiBJbiB0aGlzIHdheSwgdGhlIHNvdXJjZSBjb21wb25lbnQgc3VwcHJlc3Nlc1xuICAgICAqIHRoZSBidWlsdC1pbiBiZWhhdmlvciB0aGF0IGZvbGxvd3MgdGhlIGV2ZW50LlxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICB0aGlzLnByZXZlbnRlZCA9IHRydWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybnMgYHRydWVgIGlmIHRoZSBldmVudCB3YXMgcHJldmVudGVkXG4gICAgICogYnkgYW55IG9mIGl0cyBzdWJzY3JpYmVycy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIGB0cnVlYCBpZiB0aGUgZGVmYXVsdCBhY3Rpb24gd2FzIHByZXZlbnRlZC5cbiAgICAgKiBPdGhlcndpc2UsIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBpc0RlZmF1bHRQcmV2ZW50ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnByZXZlbnRlZDtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBMZWdlbmRFdmVudCBleHRlbmRzIFByZXZlbnRhYmxlRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlLCBzZW5kZXIpIHtcbiAgICAgICAgc3VwZXIoc2VuZGVyKTtcbiAgICAgICAgdGhpcy5zZXJpZXMgPSBlLnNlcmllcztcbiAgICAgICAgdGhpcy5zZXJpZXNJbmRleCA9IGUuc2VyaWVzSW5kZXg7XG4gICAgICAgIHRoaXMucG9pbnRJbmRleCA9IGUucG9pbnRJbmRleDtcbiAgICAgICAgdGhpcy50ZXh0ID0gZS50ZXh0O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgbGVnZW5kSXRlbUNsaWNrYCBldmVudC5cbiAqL1xuY2xhc3MgTGVnZW5kSXRlbUNsaWNrRXZlbnQgZXh0ZW5kcyBMZWdlbmRFdmVudCB7XG4gICAgLyoqXG4gICAgICogSWYgY2FsbGVkLCB0aGUgc2VyaWVzIHZpc2liaWxpdHkgaXMgbm90IHRvZ2dsZWQgYXMgYSByZXN1bHQgb2YgY2xpY2tpbmcgdGhlIGxlZ2VuZCBpdGVtLlxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgICAgICBzdXBlci5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgYXhpc0xhYmVsQ2xpY2tgIGV2ZW50LlxuICovXG5jbGFzcyBBeGlzTGFiZWxDbGlja0V2ZW50IGV4dGVuZHMgQmFzZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZSwgc2VuZGVyKSB7XG4gICAgICAgIHN1cGVyKHNlbmRlcik7XG4gICAgICAgIHRoaXMuYXhpcyA9IGUuYXhpcztcbiAgICAgICAgdGhpcy5kYXRhSXRlbSA9IGUuZGF0YUl0ZW07XG4gICAgICAgIHRoaXMuaW5kZXggPSBlLmluZGV4O1xuICAgICAgICB0aGlzLnRleHQgPSBlLnRleHQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSBlLnZhbHVlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgZHJhZ2AgZXZlbnQuXG4gKi9cbmNsYXNzIERyYWdFdmVudCBleHRlbmRzIFByZXZlbnRhYmxlRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlLCBzZW5kZXIpIHtcbiAgICAgICAgc3VwZXIoc2VuZGVyKTtcbiAgICAgICAgdGhpcy5heGlzUmFuZ2VzID0gZS5heGlzUmFuZ2VzO1xuICAgICAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBlLm9yaWdpbmFsRXZlbnQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBkcmFnRW5kYCBldmVudC5cbiAqL1xuY2xhc3MgRHJhZ0VuZEV2ZW50IGV4dGVuZHMgQmFzZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZSwgc2VuZGVyKSB7XG4gICAgICAgIHN1cGVyKHNlbmRlcik7XG4gICAgICAgIHRoaXMuYXhpc1JhbmdlcyA9IGUuYXhpc1JhbmdlcztcbiAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gZS5vcmlnaW5hbEV2ZW50O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgZHJhZ1N0YXJ0YCBldmVudC5cbiAqL1xuY2xhc3MgRHJhZ1N0YXJ0RXZlbnQgZXh0ZW5kcyBQcmV2ZW50YWJsZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZSwgc2VuZGVyKSB7XG4gICAgICAgIHN1cGVyKHNlbmRlcik7XG4gICAgICAgIHRoaXMuYXhpc1JhbmdlcyA9IGUuYXhpc1JhbmdlcztcbiAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gZS5vcmlnaW5hbEV2ZW50O1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgbGVnZW5kSXRlbUhvdmVyYCBldmVudC5cbiAqL1xuY2xhc3MgTGVnZW5kSXRlbUhvdmVyRXZlbnQgZXh0ZW5kcyBMZWdlbmRFdmVudCB7XG4gICAgLyoqXG4gICAgICogSWYgY2FsbGVkLCB0aGUgc2VyaWVzIGhpZ2hsaWdodCBpcyBub3Qgc2hvd24gYXMgYSByZXN1bHQgb2YgaG92ZXJpbmcgb3ZlciB0aGUgbGVnZW5kIGl0ZW0uXG4gICAgICovXG4gICAgcHJldmVudERlZmF1bHQoKSB7XG4gICAgICAgIHN1cGVyLnByZXZlbnREZWZhdWx0KCk7XG4gICAgfVxufVxuXG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby1lbXB0eSAqL1xuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgbGVnZW5kSXRlbUxlYXZlYCBldmVudC5cbiAqL1xuY2xhc3MgTGVnZW5kSXRlbUxlYXZlRXZlbnQgZXh0ZW5kcyBMZWdlbmRFdmVudCB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIHByZXZlbnREZWZhdWx0KCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgaXNEZWZhdWx0UHJldmVudGVkKCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgTm90ZUV2ZW50IGV4dGVuZHMgQmFzZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZSwgc2VuZGVyKSB7XG4gICAgICAgIHN1cGVyKHNlbmRlcik7XG4gICAgICAgIHRoaXMuY2F0ZWdvcnkgPSBlLmNhdGVnb3J5O1xuICAgICAgICB0aGlzLmRhdGFJdGVtID0gZS5kYXRhSXRlbTtcbiAgICAgICAgdGhpcy5zZXJpZXMgPSBlLnNlcmllcztcbiAgICAgICAgdGhpcy52YWx1ZSA9IGUudmFsdWU7XG4gICAgICAgIHRoaXMudmlzdWFsID0gZS52aXN1YWw7XG4gICAgfVxufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBub3RlQ2xpY2tgIGV2ZW50LlxuICovXG5jbGFzcyBOb3RlQ2xpY2tFdmVudCBleHRlbmRzIE5vdGVFdmVudCB7XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYG5vdGVIb3ZlcmAgZXZlbnQuXG4gKi9cbmNsYXNzIE5vdGVIb3ZlckV2ZW50IGV4dGVuZHMgTm90ZUV2ZW50IHtcbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgbm90ZUxlYXZlYCBldmVudC5cbiAqL1xuY2xhc3MgTm90ZUxlYXZlRXZlbnQgZXh0ZW5kcyBOb3RlRXZlbnQge1xufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBwYW5lUmVuZGVyYCBldmVudC5cbiAqL1xuY2xhc3MgUGFuZVJlbmRlckV2ZW50IGV4dGVuZHMgQmFzZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoYXJncywgc2VuZGVyKSB7XG4gICAgICAgIHN1cGVyKHNlbmRlcik7XG4gICAgICAgIE9iamVjdC5hc3NpZ24odGhpcywgYXJncyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBwbG90QXJlYUNsaWNrYCBldmVudC5cbiAqL1xuY2xhc3MgUGxvdEFyZWFDbGlja0V2ZW50IGV4dGVuZHMgQmFzZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZSwgc2VuZGVyKSB7XG4gICAgICAgIHN1cGVyKHNlbmRlcik7XG4gICAgICAgIHRoaXMuY2F0ZWdvcnkgPSBlLmNhdGVnb3J5O1xuICAgICAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBlLm9yaWdpbmFsRXZlbnQ7XG4gICAgICAgIHRoaXMudmFsdWUgPSBlLnZhbHVlO1xuICAgICAgICB0aGlzLnggPSBlLng7XG4gICAgICAgIHRoaXMueSA9IGUueTtcbiAgICB9XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYHBsb3RBcmVhSG92ZXJgIGV2ZW50LlxuICovXG5jbGFzcyBQbG90QXJlYUhvdmVyRXZlbnQgZXh0ZW5kcyBCYXNlRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlLCBzZW5kZXIpIHtcbiAgICAgICAgc3VwZXIoc2VuZGVyKTtcbiAgICAgICAgdGhpcy5jYXRlZ29yeSA9IGUuY2F0ZWdvcnk7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IGUub3JpZ2luYWxFdmVudDtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGUudmFsdWU7XG4gICAgICAgIHRoaXMueCA9IGUueDtcbiAgICAgICAgdGhpcy55ID0gZS55O1xuICAgIH1cbn1cblxuY2xhc3MgUGxvdEFyZWFMZWF2ZUV2ZW50IGV4dGVuZHMgQmFzZUV2ZW50IHtcbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgcmVuZGVyYCBldmVudC5cbiAqL1xuY2xhc3MgUmVuZGVyRXZlbnQgZXh0ZW5kcyBCYXNlRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihfZSwgc2VuZGVyKSB7XG4gICAgICAgIHN1cGVyKHNlbmRlcik7XG4gICAgfVxufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBzZWxlY3RgIGV2ZW50LlxuICovXG5jbGFzcyBTZWxlY3RFdmVudCBleHRlbmRzIFByZXZlbnRhYmxlRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlLCBzZW5kZXIpIHtcbiAgICAgICAgc3VwZXIoc2VuZGVyKTtcbiAgICAgICAgdGhpcy5heGlzID0gZS5heGlzO1xuICAgICAgICB0aGlzLmZyb20gPSBlLmZyb207XG4gICAgICAgIHRoaXMudG8gPSBlLnRvO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgc2VsZWN0RW5kYCBldmVudC5cbiAqL1xuY2xhc3MgU2VsZWN0RW5kRXZlbnQgZXh0ZW5kcyBCYXNlRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlLCBzZW5kZXIpIHtcbiAgICAgICAgc3VwZXIoc2VuZGVyKTtcbiAgICAgICAgdGhpcy5heGlzID0gZS5heGlzO1xuICAgICAgICB0aGlzLmZyb20gPSBlLmZyb207XG4gICAgICAgIHRoaXMudG8gPSBlLnRvO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgc2VsZWN0U3RhcnRgIGV2ZW50LlxuICovXG5jbGFzcyBTZWxlY3RTdGFydEV2ZW50IGV4dGVuZHMgUHJldmVudGFibGVFdmVudCB7XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGUsIHNlbmRlcikge1xuICAgICAgICBzdXBlcihzZW5kZXIpO1xuICAgICAgICB0aGlzLmF4aXMgPSBlLmF4aXM7XG4gICAgICAgIHRoaXMuZnJvbSA9IGUuZnJvbTtcbiAgICAgICAgdGhpcy50byA9IGUudG87XG4gICAgfVxufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBzZXJpZXNDbGlja2AgZXZlbnQuXG4gKi9cbmNsYXNzIFNlcmllc0NsaWNrRXZlbnQgZXh0ZW5kcyBCYXNlRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlLCBzZW5kZXIpIHtcbiAgICAgICAgc3VwZXIoc2VuZGVyKTtcbiAgICAgICAgdGhpcy5jYXRlZ29yeSA9IGUuY2F0ZWdvcnk7XG4gICAgICAgIHRoaXMuZGF0YUl0ZW0gPSBlLmRhdGFJdGVtO1xuICAgICAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBlLm9yaWdpbmFsRXZlbnQ7XG4gICAgICAgIHRoaXMucGVyY2VudGFnZSA9IGUucGVyY2VudGFnZTtcbiAgICAgICAgdGhpcy5wb2ludCA9IGUucG9pbnQ7XG4gICAgICAgIHRoaXMuc2VyaWVzID0gZS5zZXJpZXM7XG4gICAgICAgIHRoaXMuc3RhY2tWYWx1ZSA9IGUuc3RhY2tWYWx1ZTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGUudmFsdWU7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2VyaWVzRXZlbnQgZXh0ZW5kcyBQcmV2ZW50YWJsZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZSwgc2VuZGVyKSB7XG4gICAgICAgIHN1cGVyKHNlbmRlcik7XG4gICAgICAgIHRoaXMuY2F0ZWdvcnkgPSBlLmNhdGVnb3J5O1xuICAgICAgICB0aGlzLmRhdGFJdGVtID0gZS5kYXRhSXRlbTtcbiAgICAgICAgdGhpcy5vcmlnaW5hbEV2ZW50ID0gZS5vcmlnaW5hbEV2ZW50O1xuICAgICAgICB0aGlzLnBlcmNlbnRhZ2UgPSBlLnBlcmNlbnRhZ2U7XG4gICAgICAgIHRoaXMucG9pbnQgPSBlLnBvaW50O1xuICAgICAgICB0aGlzLnNlcmllcyA9IGUuc2VyaWVzO1xuICAgICAgICB0aGlzLnN0YWNrVmFsdWUgPSBlLnN0YWNrVmFsdWU7XG4gICAgICAgIHRoaXMudmFsdWUgPSBlLnZhbHVlO1xuICAgIH1cbn1cblxuLyoqXG4gKiBBcmd1bWVudHMgZm9yIHRoZSBgc2VyaWVzSG92ZXJgIGV2ZW50LlxuICovXG5jbGFzcyBTZXJpZXNIb3ZlckV2ZW50IGV4dGVuZHMgU2VyaWVzRXZlbnQge1xufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBzZXJpZXNPdmVyYCBldmVudC5cbiAqL1xuY2xhc3MgU2VyaWVzT3ZlckV2ZW50IGV4dGVuZHMgU2VyaWVzRXZlbnQge1xufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGBzZXJpZXNMZWF2ZWAgZXZlbnQuXG4gKi9cbmNsYXNzIFNlcmllc0xlYXZlRXZlbnQgZXh0ZW5kcyBTZXJpZXNFdmVudCB7XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYHpvb21gIGV2ZW50LlxuICovXG5jbGFzcyBab29tRXZlbnQgZXh0ZW5kcyBQcmV2ZW50YWJsZUV2ZW50IHtcbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoZSwgc2VuZGVyKSB7XG4gICAgICAgIHN1cGVyKHNlbmRlcik7XG4gICAgICAgIHRoaXMuYXhpc1JhbmdlcyA9IGUuYXhpc1JhbmdlcztcbiAgICAgICAgdGhpcy5kZWx0YSA9IGUuZGVsdGE7XG4gICAgICAgIHRoaXMub3JpZ2luYWxFdmVudCA9IGUub3JpZ2luYWxFdmVudDtcbiAgICB9XG59XG5cbi8qKlxuICogQXJndW1lbnRzIGZvciB0aGUgYHpvb21FbmRgIGV2ZW50LlxuICovXG5jbGFzcyBab29tRW5kRXZlbnQgZXh0ZW5kcyBCYXNlRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlLCBzZW5kZXIpIHtcbiAgICAgICAgc3VwZXIoc2VuZGVyKTtcbiAgICAgICAgdGhpcy5heGlzUmFuZ2VzID0gZS5heGlzUmFuZ2VzO1xuICAgICAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBlLm9yaWdpbmFsRXZlbnQ7XG4gICAgfVxufVxuXG4vKipcbiAqIEFyZ3VtZW50cyBmb3IgdGhlIGB6b29tU3RhcnRgIGV2ZW50LlxuICovXG5jbGFzcyBab29tU3RhcnRFdmVudCBleHRlbmRzIFByZXZlbnRhYmxlRXZlbnQge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihlLCBzZW5kZXIpIHtcbiAgICAgICAgc3VwZXIoc2VuZGVyKTtcbiAgICAgICAgdGhpcy5heGlzUmFuZ2VzID0gZS5heGlzUmFuZ2VzO1xuICAgICAgICB0aGlzLm9yaWdpbmFsRXZlbnQgPSBlLm9yaWdpbmFsRXZlbnQ7XG4gICAgfVxufVxuXG5jb25zdCBFVkVOVF9NQVAgPSB7XG4gICAgYXhpc0xhYmVsQ2xpY2s6IEF4aXNMYWJlbENsaWNrRXZlbnQsXG4gICAgZHJhZzogRHJhZ0V2ZW50LFxuICAgIGRyYWdFbmQ6IERyYWdFbmRFdmVudCxcbiAgICBkcmFnU3RhcnQ6IERyYWdTdGFydEV2ZW50LFxuICAgIGxlZ2VuZEl0ZW1Ib3ZlcjogTGVnZW5kSXRlbUhvdmVyRXZlbnQsXG4gICAgbGVnZW5kSXRlbUxlYXZlOiBMZWdlbmRJdGVtTGVhdmVFdmVudCxcbiAgICBub3RlQ2xpY2s6IE5vdGVDbGlja0V2ZW50LFxuICAgIG5vdGVIb3ZlcjogTm90ZUhvdmVyRXZlbnQsXG4gICAgbm90ZUxlYXZlOiBOb3RlTGVhdmVFdmVudCxcbiAgICBwYW5lUmVuZGVyOiBQYW5lUmVuZGVyRXZlbnQsXG4gICAgcGxvdEFyZWFDbGljazogUGxvdEFyZWFDbGlja0V2ZW50LFxuICAgIHBsb3RBcmVhSG92ZXI6IFBsb3RBcmVhSG92ZXJFdmVudCxcbiAgICBwbG90QXJlYUxlYXZlOiBQbG90QXJlYUxlYXZlRXZlbnQsXG4gICAgcmVuZGVyOiBSZW5kZXJFdmVudCxcbiAgICBzZWxlY3Q6IFNlbGVjdEV2ZW50LFxuICAgIHNlbGVjdEVuZDogU2VsZWN0RW5kRXZlbnQsXG4gICAgc2VsZWN0U3RhcnQ6IFNlbGVjdFN0YXJ0RXZlbnQsXG4gICAgc2VyaWVzQ2xpY2s6IFNlcmllc0NsaWNrRXZlbnQsXG4gICAgc2VyaWVzSG92ZXI6IFNlcmllc0hvdmVyRXZlbnQsXG4gICAgc2VyaWVzT3ZlcjogU2VyaWVzT3ZlckV2ZW50LFxuICAgIHNlcmllc0xlYXZlOiBTZXJpZXNMZWF2ZUV2ZW50LFxuICAgIHpvb206IFpvb21FdmVudCxcbiAgICB6b29tRW5kOiBab29tRW5kRXZlbnQsXG4gICAgem9vbVN0YXJ0OiBab29tU3RhcnRFdmVudFxufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBJbnN0YW5jZUV2ZW50U2VydmljZSB7XG4gICAgY3JlYXRlKG5hbWUsIGFyZ3MsIHNlbmRlcikge1xuICAgICAgICBpZiAoRVZFTlRfTUFQW25hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVWRU5UX01BUFtuYW1lXShhcmdzLCBzZW5kZXIpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHdoaWNoIHNlbGVjdHMgYSBbdGVtcGxhdGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ3RlbXBsYXRlc3ludGF4J10gfX0pXG4gKiB3aXRoaW4gdGhlIGA8a2VuZG8tY2hhcnQ+YCBjb21wb25lbnQgZm9yIHRoZVxuICogW0RvbnV0IGNlbnRlciB0ZW1wbGF0ZV0oeyUgc2x1ZyBkb251dF9zZXJpZXN0eXBlc19jaGFydHMgJX0pLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgPGtlbmRvLWNoYXJ0IHN0eWxlPVwiaGVpZ2h0OiA0NTBweDtcIj5cbiAqICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0NoYXJ0RG9udXRDZW50ZXJUZW1wbGF0ZT5cbiAqICAgICAgICAgPGgzPjIyLjUlPC9oMz5cbiAqICAgICAgICAgb2Ygd2hpY2ggcmVuZXdhYmxlc1xuICogICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgIDxrZW5kby1jaGFydC1zZXJpZXM+XG4gKiAgICAgICAgIDxrZW5kby1jaGFydC1zZXJpZXMtaXRlbVxuICogICAgICAgICAgICAgdHlwZT1cImRvbnV0XCIgW2RhdGFdPVwiZGF0YVwiXG4gKiAgICAgICAgICAgICBjYXRlZ29yeUZpZWxkPVwia2luZFwiIGZpZWxkPVwic2hhcmVcIj5cbiAqICAgICAgICAgPC9rZW5kby1jaGFydC1zZXJpZXMtaXRlbT5cbiAqICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzPlxuICogICAgICAgPGtlbmRvLWNoYXJ0LWxlZ2VuZCBbdmlzaWJsZV09XCJmYWxzZVwiPjwva2VuZG8tY2hhcnQtbGVnZW5kPlxuICogICAgIDwva2VuZG8tY2hhcnQ+XG4gKiAgIGBcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgcHVibGljIGRhdGE6IGFueVtdID0gW3tcbiAqICAgICBraW5kOiAnSHlkcm9lbGVjdHJpYycsIHNoYXJlOiAwLjE3NVxuICogICB9LCB7XG4gKiAgICAga2luZDogJ051Y2xlYXInLCBzaGFyZTogMC4yMzhcbiAqICAgfSwge1xuICogICAgIGtpbmQ6ICdDb2FsJywgc2hhcmU6IDAuMTE4XG4gKiAgIH0sIHtcbiAqICAgICBraW5kOiAnU29sYXInLCBzaGFyZTogMC4wNTJcbiAqICAgfSwge1xuICogICAgIGtpbmQ6ICdXaW5kJywgc2hhcmU6IDAuMjI1XG4gKiAgIH0sIHtcbiAqICAgICBraW5kOiAnT3RoZXInLCBzaGFyZTogMC4xOTJcbiAqICAgfV07XG4gKiB9XG4gKlxuICogYGBgXG4gKi9cbmxldCBEb251dENlbnRlclRlbXBsYXRlRGlyZWN0aXZlID0gY2xhc3MgRG9udXRDZW50ZXJUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn07XG5Eb251dENlbnRlclRlbXBsYXRlRGlyZWN0aXZlID0gX19kZWNvcmF0ZShbXG4gICAgRGlyZWN0aXZlKHtcbiAgICAgICAgc2VsZWN0b3I6ICdba2VuZG9DaGFydERvbnV0Q2VudGVyVGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBEb251dENlbnRlclRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEl0ZW1DaGFuZ2Uge1xuICAgIGNvbnN0cnVjdG9yKHNlbmRlciwgb3B0aW9ucykge1xuICAgICAgICB0aGlzLnNlbmRlciA9IHNlbmRlcjtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICB9XG59XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IENvbGxlY3Rpb25TZXJ2aWNlID0gY2xhc3MgQ29sbGVjdGlvblNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnNvdXJjZSA9IG5ldyBTdWJqZWN0KCk7XG4gICAgICAgIHRoaXMub25JdGVtQ2hhbmdlJCA9IHRoaXMuc291cmNlLmFzT2JzZXJ2YWJsZSgpO1xuICAgIH1cbiAgICBub3RpZnkoY2hhbmdlKSB7XG4gICAgICAgIHRoaXMuc291cmNlLm5leHQoY2hhbmdlKTtcbiAgICB9XG59O1xuQ29sbGVjdGlvblNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtdKVxuXSwgQ29sbGVjdGlvblNlcnZpY2UpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gY29weUNoYW5nZXMoY2hhbmdlcywgb3B0aW9ucykge1xuICAgIGZvciAoY29uc3QgcHJvcGVydHlOYW1lIGluIGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKCFjaGFuZ2VzLmhhc093blByb3BlcnR5KHByb3BlcnR5TmFtZSkpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZhbHVlID0gY2hhbmdlc1twcm9wZXJ0eU5hbWVdLmN1cnJlbnRWYWx1ZTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGRlbGV0ZSBvcHRpb25zW3Byb3BlcnR5TmFtZV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvcHRpb25zW3Byb3BlcnR5TmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIHRvU2ltcGxlQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWUgaW4gY2hhbmdlcykge1xuICAgICAgICBpZiAoIWNoYW5nZXMuaGFzT3duUHJvcGVydHkocHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W3Byb3BlcnR5TmFtZV0gPSBuZXcgU2ltcGxlQ2hhbmdlKG51bGwsIGNoYW5nZXNbcHJvcGVydHlOYW1lXSwgZmFsc2UpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ29sbGVjdGlvbkl0ZW1Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSkge1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvblNlcnZpY2UgPSBjb2xsZWN0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5vcHRpb25zID0ge307XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uID0gY29uZmlndXJhdGlvblNlcnZpY2Uub25GYXN0Q2hhbmdlJC5zdWJzY3JpYmUoc3RvcmUgPT4ge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zID0gc3RvcmU7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbmdPbkNoYW5nZXMoY2hhbmdlcykge1xuICAgICAgICBjb25zdCBzdG9yZSA9IHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2Uuc3RvcmU7XG4gICAgICAgIGNvcHlDaGFuZ2VzKGNoYW5nZXMsIHN0b3JlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZS5wdXNoKHN0b3JlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVXBkYXRlcyB0aGUgY29tcG9uZW50IGZpZWxkcyB3aXRoIHRoZSBzcGVjaWZpZWQgdmFsdWVzIGFuZCByZWZyZXNoZXMgdGhlIENoYXJ0LlxuICAgICAqXG4gICAgICogVXNlIHRoaXMgbWV0aG9kIHdoZW4gdGhlIGNvbmZpZ3VyYXRpb24gdmFsdWVzIGNhbm5vdCBiZSBzZXQgdGhyb3VnaCB0aGUgdGVtcGxhdGUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYHRzLW5vLXJ1blxuICAgICAqIGl0ZW0ubm90aWZ5Q2hhbmdlcyh7IHZpc2libGU6IHRydWUgfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbmdlcyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgdXBkYXRlZCBpbnB1dCBmaWVsZHMuXG4gICAgICovXG4gICAgbm90aWZ5Q2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMubmdPbkNoYW5nZXModG9TaW1wbGVDaGFuZ2VzKGNoYW5nZXMpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uLnVuc3Vic2NyaWJlKCk7XG4gICAgfVxuICAgIG5vdGlmeSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uU2VydmljZS5ub3RpZnkobmV3IEl0ZW1DaGFuZ2UodGhpcywgdGhpcy5vcHRpb25zKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIENvbGxlY3Rpb25JdGVtQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYWdncmVnYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYXV0b0ZpdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYXhpc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjYXRlZ29yeUF4aXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNhdGVnb3J5RmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNsb3NlRmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb2xvckZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb25uZWN0b3JzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjdXJyZW50RmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImRhc2hUeXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImRvd25Db2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZG93bkNvbG9yRmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJkeW5hbWljSGVpZ2h0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZHluYW1pY1Nsb3BlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJlcnJvckhpZ2hGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZXJyb3JMb3dGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZXhwbG9kZUZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZnJvbUZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJnYXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImhpZ2hGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiaG9sZVNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxpbmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxvd0ZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJsb3dlckZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYXJnaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1heFNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1lYW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1lYW5GaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWVkaWFuXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtZWRpYW5GaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWluU2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWlzc2luZ1ZhbHVlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibmVja1JhdGlvXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJuZWdhdGl2ZUNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJuZWdhdGl2ZVZhbHVlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibm90ZVRleHRGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwib3BhY2l0eVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwib3BlbkZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJvdXRsaWVyc0ZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJvdmVybGF5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJxMUZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJxM0ZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzZWdtZW50U3BhY2luZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic2l6ZUZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzcGFjaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzdGFja1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic3RhcnRBbmdsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic3R5bGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInN1bW1hcnlGaWVsZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidGFyZ2V0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0b0ZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ1cHBlckZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVJbkxlZ2VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZUluTGVnZW5kRmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzdWFsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwid2hpc2tlcnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInhBeGlzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ4RXJyb3JIaWdoRmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInhFcnJvckxvd0ZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ4RmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInlBeGlzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ5RXJyb3JIaWdoRmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInlFcnJvckxvd0ZpZWxkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ5RmllbGRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInpJbmRleFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZXJyb3JCYXJzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJleHRyZW1lc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiaGlnaGxpZ2h0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJsYWJlbHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1hcmtlcnNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm5vdGVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJvdXRsaWVyc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCB2b2lkIDApO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ0tleSwgY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5jb25maWdLZXkgPSBjb25maWdLZXk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5zdG9yZSA9IHt9O1xuICAgICAgICBpZiAoY29uZmlnS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29uZmlndXJhdGlvbiBrZXkgbm90IHNldCcpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN0b3JlID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLm5vdGlmeSgpO1xuICAgIH1cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIGNvcHlDaGFuZ2VzKGNoYW5nZXMsIHRoaXMuc3RvcmUpO1xuICAgICAgICB0aGlzLm5vdGlmeSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQgZmllbGRzIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZXMgYW5kIHJlZnJlc2hlcyB0aGUgQ2hhcnQuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBtZXRob2Qgd2hlbiB0aGUgY29uZmlndXJhdGlvbiB2YWx1ZXMgY2Fubm90IGJlIHNldCB0aHJvdWdoIHRoZSB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHMtbm8tcnVuXG4gICAgICogaXRlbS5ub3RpZnlDaGFuZ2VzKHsgdmlzaWJsZTogdHJ1ZSB9KTtcbiAgICAgKiBgYGBcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjaGFuZ2VzIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSB1cGRhdGVkIGlucHV0IGZpZWxkcy5cbiAgICAgKi9cbiAgICBub3RpZnlDaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgdGhpcy5uZ09uQ2hhbmdlcyh0b1NpbXBsZUNoYW5nZXMoY2hhbmdlcykpO1xuICAgIH1cbiAgICBtYXJrQXNWaXNpYmxlKCkge1xuICAgICAgICB0aGlzLnN0b3JlLnZpc2libGUgPSB0cnVlO1xuICAgICAgICB0aGlzLm5vdGlmeSgpO1xuICAgIH1cbiAgICBub3RpZnkoKSB7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2Uubm90aWZ5KG5ldyBDaGFuZ2UodGhpcy5jb25maWdLZXksIHRoaXMuc3RvcmUpKTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTZXJpZXNUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCd0b29sdGlwJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9udFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2VyaWVzVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb2YgdGhlIENoYXJ0IHNlcmllcyB0b29sdGlwXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRvb2x0aXBzX2NoYXJ0X2NoYXJ0cyAlfSkpLlxuICovXG5sZXQgU2VyaWVzVG9vbHRpcENvbXBvbmVudCA9IGNsYXNzIFNlcmllc1Rvb2x0aXBDb21wb25lbnQgZXh0ZW5kcyBTZXJpZXNUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5tYXJrQXNWaXNpYmxlKCk7XG4gICAgfVxuICAgIGdldCBzZXJpZXNUb29sdGlwVGVtcGxhdGVSZWYoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnNlcmllc1Rvb2x0aXBUZW1wbGF0ZTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKFRlbXBsYXRlUmVmLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRlbXBsYXRlUmVmKVxuXSwgU2VyaWVzVG9vbHRpcENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VyaWVzVG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5TZXJpZXNUb29sdGlwQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0tdG9vbHRpcCcsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgU2VyaWVzVG9vbHRpcENvbXBvbmVudCk7XG5cbmNvbnN0IHRvZ2dsZSA9IChmbGFnKSA9PiBmbGFnID09PSB1bmRlZmluZWQgPyBmYWxzZSA6ICFmbGFnO1xuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBjb21wb25lbnQgZm9yIGEgc2VyaWVzIGl0ZW0uXG4gKi9cbmxldCBTZXJpZXNJdGVtQ29tcG9uZW50ID0gY2xhc3MgU2VyaWVzSXRlbUNvbXBvbmVudCBleHRlbmRzIFNlcmllc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvblNlcnZpY2UgPSBjb2xsZWN0aW9uU2VydmljZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVG9nZ2xlcyB0aGUgc2VyaWVzIHZpc2liaWxpdHkgYW5kIHVwZGF0ZXMgdGhlIHBhcmVudCBDaGFydFxuICAgICAqIHdpdGhvdXQgYW5pbWF0ZWQgdHJhbnNpdGlvbnMuXG4gICAgICovXG4gICAgdG9nZ2xlVmlzaWJpbGl0eSgpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLnZpc2libGUgPSB0b2dnbGUodGhpcy5vcHRpb25zLnZpc2libGUpO1xuICAgICAgICB0aGlzLm5vdGlmeSgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUb2dnbGVzIHRoZSB2aXNpYmlsaXR5IG9mIGEgcG9pbnQgd2l0aCB0aGUgZ2l2ZW4gaW5kZXguXG4gICAgICogQXBwbGljYWJsZSBmb3IgdGhlIFBpZSwgRG9udXQsIGFuZCBGdW5uZWwgc2VyaWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHBvaW50SW5kZXggLSBUaGUgemVyby1iYXNlZCBpbmRleCBvZiB0aGUgcG9pbnQgdG8gdG9nZ2xlLlxuICAgICAqL1xuICAgIHRvZ2dsZVBvaW50VmlzaWJpbGl0eShwb2ludEluZGV4KSB7XG4gICAgICAgIGNvbnN0IHB2ID0gdGhpcy5vcHRpb25zLnBvaW50VmlzaWJpbGl0eSA9IHRoaXMub3B0aW9ucy5wb2ludFZpc2liaWxpdHkgfHwge307XG4gICAgICAgIHB2W3BvaW50SW5kZXhdID0gdG9nZ2xlKHB2W3BvaW50SW5kZXhdKTtcbiAgICAgICAgdGhpcy5ub3RpZnkoKTtcbiAgICB9XG4gICAgZ2V0IHNlcmllc1Rvb2x0aXBUZW1wbGF0ZVJlZigpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VyaWVzVG9vbHRpcCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWVzVG9vbHRpcC5zZXJpZXNUb29sdGlwVGVtcGxhdGVSZWY7XG4gICAgICAgIH1cbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkKFNlcmllc1Rvb2x0aXBDb21wb25lbnQsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU2VyaWVzVG9vbHRpcENvbXBvbmVudClcbl0sIFNlcmllc0l0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcInNlcmllc1Rvb2x0aXBcIiwgdm9pZCAwKTtcblNlcmllc0l0ZW1Db21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgcHJvdmlkZXJzOiBbQ29uZmlndXJhdGlvblNlcnZpY2VdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZSxcbiAgICAgICAgQ29sbGVjdGlvblNlcnZpY2VdKVxuXSwgU2VyaWVzSXRlbUNvbXBvbmVudCk7XG5cbi8qKlxuICogRmFsbGJhY2sgdGhlbWUgaW4gY2FzZSB0aGUgVGhlbWUgU2VydmljZSBmYWlsc1xuICogdG8gcmVhZCB0aGUgdmFyaWFibGVzIGZyb20gdGhlIG1haW4gdGhlbWUuXG4gKlxuICogQGhpZGRlblxuICovXG5jb25zdCBjaGFydERlZmF1bHRUaGVtZSA9ICgpID0+IE9iamVjdC5hc3NpZ24oe30sIGNoYXJ0QmFzZVRoZW1lKCksIHtcbiAgICBheGlzRGVmYXVsdHM6IHtcbiAgICAgICAgY3Jvc3NoYWlyOiB7XG4gICAgICAgICAgICBjb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC41KSdcbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICBjb2xvcjogJ3JnYigxMDEsIDEwMSwgMTAxKScsXG4gICAgICAgICAgICBmb250OiAnMTJweCBzZXJpZidcbiAgICAgICAgfSxcbiAgICAgICAgbGluZToge1xuICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMDgpJ1xuICAgICAgICB9LFxuICAgICAgICBtYWpvckdyaWRMaW5lczoge1xuICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMDgpJ1xuICAgICAgICB9LFxuICAgICAgICBtaW5vckdyaWRMaW5lczoge1xuICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMDQpJ1xuICAgICAgICB9LFxuICAgICAgICBub3Rlczoge1xuICAgICAgICAgICAgaWNvbjoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICdyZ2JhKDAsIDAsIDAsIDAuNSknLFxuICAgICAgICAgICAgICAgIGJvcmRlcjoge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC41KSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjUpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgZm9udDogJzE0cHggc2VyaWYnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgICBjb2xvcjogJ3JnYigxMDEsIDEwMSwgMTAxKScsXG4gICAgICAgICAgICBmb250OiAnMTRweCBzZXJpZidcbiAgICAgICAgfVxuICAgIH0sXG4gICAgY2hhcnRBcmVhOiB7XG4gICAgICAgIGJhY2tncm91bmQ6ICdyZ2IoMjU1LCAyNTUsIDI1NSknXG4gICAgfSxcbiAgICBsZWdlbmQ6IHtcbiAgICAgICAgaW5hY3RpdmVJdGVtczoge1xuICAgICAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDEwMiwgMTAyLCAxMDIsIDAuNSknXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWFya2Vyczoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAncmdiYSgxMDIsIDEwMiwgMTAyLCAwLjUpJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBsYWJlbHM6IHtcbiAgICAgICAgICAgIGNvbG9yOiAncmdiKDEwMSwgMTAxLCAxMDEpJyxcbiAgICAgICAgICAgIGZvbnQ6ICcxNHB4IHNlcmlmJ1xuICAgICAgICB9XG4gICAgfSxcbiAgICBzZXJpZXNEZWZhdWx0czoge1xuICAgICAgICBib3hQbG90OiB7XG4gICAgICAgICAgICBkb3duQ29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuMDgpJyxcbiAgICAgICAgICAgIG1lYW46IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYigyNDYsIDI0NiwgMjQ2KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZWRpYW46IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYigyNDYsIDI0NiwgMjQ2KSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB3aGlza2Vyczoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAncmdiKDI1NSwgOTksIDg4KSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYnVsbGV0OiB7XG4gICAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYigxMDEsIDEwMSwgMTAxKSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgY2FuZGxlc3RpY2s6IHtcbiAgICAgICAgICAgIGRvd25Db2xvcjogJ3JnYigxMDEsIDEwMSwgMTAxKScsXG4gICAgICAgICAgICBsaW5lOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICdyZ2IoMTAxLCAxMDEsIDEwMSknXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yQmFyczoge1xuICAgICAgICAgICAgY29sb3I6ICdyZ2JhKDAsIDAsIDAsIDAuNSknXG4gICAgICAgIH0sXG4gICAgICAgIGhvcml6b250YWxXYXRlcmZhbGw6IHtcbiAgICAgICAgICAgIGxpbmU6IHtcbiAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4wOCknXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGljb246IHtcbiAgICAgICAgICAgIGJvcmRlcjoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjA4KSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgbGFiZWxzOiB7XG4gICAgICAgICAgICBiYWNrZ3JvdW5kOiAncmdiKDI1NSwgMjU1LCAyNTUpJyxcbiAgICAgICAgICAgIGNvbG9yOiAncmdiKDEwMSwgMTAxLCAxMDEpJyxcbiAgICAgICAgICAgIG9wYWNpdHk6IDAuOCxcbiAgICAgICAgICAgIGZvbnQ6ICcxMnB4IHNlcmlmJ1xuICAgICAgICB9LFxuICAgICAgICBub3Rlczoge1xuICAgICAgICAgICAgaWNvbjoge1xuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICdyZ2JhKDAsIDAsIDAsIDAuNSknLFxuICAgICAgICAgICAgICAgIGJvcmRlcjoge1xuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ3JnYmEoMCwgMCwgMCwgMC41KSdcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbGluZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjUpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGxhYmVsOiB7XG4gICAgICAgICAgICAgICAgZm9udDogJzE0cHggc2VyaWYnXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG92ZXJsYXk6IHtcbiAgICAgICAgICAgIGdyYWRpZW50OiBcIm5vbmVcIlxuICAgICAgICB9LFxuICAgICAgICB2ZXJ0aWNhbEJveFBsb3Q6IHtcbiAgICAgICAgICAgIGRvd25Db2xvcjogJ3JnYmEoMCwgMCwgMCwgMC4wOCknLFxuICAgICAgICAgICAgbWVhbjoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAncmdiKDI0NiwgMjQ2LCAyNDYpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG1lZGlhbjoge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAncmdiKDI0NiwgMjQ2LCAyNDYpJ1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHdoaXNrZXJzOiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICdyZ2IoMjU1LCA5OSwgODgpJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICB2ZXJ0aWNhbEJ1bGxldDoge1xuICAgICAgICAgICAgdGFyZ2V0OiB7XG4gICAgICAgICAgICAgICAgY29sb3I6ICdyZ2IoMTAxLCAxMDEsIDEwMSknXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHdhdGVyZmFsbDoge1xuICAgICAgICAgICAgbGluZToge1xuICAgICAgICAgICAgICAgIGNvbG9yOiAncmdiYSgwLCAwLCAwLCAwLjA4KSdcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYXJlYToge1xuICAgICAgICAgICAgb3BhY2l0eTogMC44XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHRpdGxlOiB7XG4gICAgICAgIGNvbG9yOiAncmdiKDEwMSwgMTAxLCAxMDEpJyxcbiAgICAgICAgZm9udDogJzE2cHggc2VyaWYnXG4gICAgfSxcbiAgICBzZXJpZXNDb2xvcnM6IFtcbiAgICAgICAgJ3JnYigyNTUsIDk5LCA4OCknLFxuICAgICAgICAncmdiKDI1NSwgMjEwLCA3MCknLFxuICAgICAgICAncmdiKDEyMCwgMjEwLCA1NSknLFxuICAgICAgICAncmdiKDQwLCAxODAsIDIwMCknLFxuICAgICAgICAncmdiKDQ1LCAxMTUsIDI0NSknLFxuICAgICAgICAncmdiKDE3MCwgNzAsIDE5MCknXG4gICAgXVxufSk7XG5cbmNvbnN0IGZvbnQgPSAoc3R5bGUpID0+IGAke3N0eWxlLmZvbnRXZWlnaHR9ICR7c3R5bGUuZm9udFNpemV9ICR7c3R5bGUuZm9udEZhbWlseX1gO1xuY29uc3QgY29tcHV0ZWRCYWNrZ3JvdW5kQ29sb3IgPSAoZWxlbWVudCkgPT4gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWxlbWVudCkuYmFja2dyb3VuZENvbG9yO1xuY29uc3QgbGV0dGVyUG9zID0gKGxldHRlcikgPT4gbGV0dGVyLnRvTG93ZXJDYXNlKCkuY2hhckNvZGVBdCgwKSAtICdhJy5jaGFyQ29kZUF0KDApO1xuY29uc3Qgc2VyaWVzUG9zID0gKG5hbWUpID0+IHtcbiAgICBjb25zdCBhbHBoYSA9IG5hbWUubWF0Y2goL3Nlcmllcy0oW2Etel0pJC8pO1xuICAgIGlmIChhbHBoYSAhPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbGV0dGVyUG9zKGFscGhhWzFdKTtcbiAgICB9XG4gICAgY29uc3QgbnVtID0gbmFtZS5zcGxpdCgnLS1zZXJpZXMtJylbMV07XG4gICAgcmV0dXJuIHBhcnNlSW50KG51bSwgMTApIC0gMTtcbn07XG5jb25zdCBTRVJJRVNfQ09MT1JTID0gMzA7XG5jb25zdCBzZXJpZXNUZW1wbGF0ZSA9ICgpID0+IHtcbiAgICBsZXQgdGVtcGxhdGUgPSBgXG4gICAgICA8ZGl2IGNsYXNzPVwiay12YXItLXNlcmllcy1hXCI+PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiay12YXItLXNlcmllcy1iXCI+PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiay12YXItLXNlcmllcy1jXCI+PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiay12YXItLXNlcmllcy1kXCI+PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiay12YXItLXNlcmllcy1lXCI+PC9kaXY+XG4gICAgICA8ZGl2IGNsYXNzPVwiay12YXItLXNlcmllcy1mXCI+PC9kaXY+XG4gIGA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBTRVJJRVNfQ09MT1JTOyBpKyspIHtcbiAgICAgICAgdGVtcGxhdGUgKz0gYFxuICAgICAgPGRpdiBjbGFzcz1cImstdmFyLS1zZXJpZXMtJHtpICsgMX1cIj48L2Rpdj5gO1xuICAgIH1cbiAgICByZXR1cm4gdGVtcGxhdGU7XG59O1xuY29uc3QgdGVtcGxhdGUgPSAoKSA9PiBgXG4gICAgPGRpdiBjbGFzcz1cImstdmFyLS1hY2NlbnRcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiay12YXItLWFjY2VudC1jb250cmFzdFwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJrLXZhci0tYmFzZVwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJrLXZhci0tYmFja2dyb3VuZFwiPjwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImstdmFyLS1ub3JtYWwtYmFja2dyb3VuZFwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJrLXZhci0tbm9ybWFsLXRleHQtY29sb3JcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiay12YXItLWhvdmVyLWJhY2tncm91bmRcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiay12YXItLWhvdmVyLXRleHQtY29sb3JcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiay12YXItLXNlbGVjdGVkLWJhY2tncm91bmRcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiay12YXItLXNlbGVjdGVkLXRleHQtY29sb3JcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiay12YXItLWNoYXJ0LWVycm9yLWJhcnMtYmFja2dyb3VuZFwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJrLXZhci0tY2hhcnQtbm90ZXMtYmFja2dyb3VuZFwiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJrLXZhci0tY2hhcnQtbm90ZXMtYm9yZGVyXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImstdmFyLS1jaGFydC1ub3Rlcy1saW5lc1wiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJrLXZhci0tY2hhcnQtY3Jvc3NoYWlyLWJhY2tncm91bmRcIj48L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJrLXZhci0tY2hhcnQtaW5hY3RpdmVcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiay12YXItLWNoYXJ0LW1ham9yLWxpbmVzXCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImstdmFyLS1jaGFydC1taW5vci1saW5lc1wiPjwvZGl2PlxuICAgIDxkaXYgY2xhc3M9XCJrLXZhci0tY2hhcnQtYXJlYS1vcGFjaXR5XCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImstdmFyLS1jaGFydC1hcmVhLWluYWN0aXZlLW9wYWNpdHlcIj48L2Rpdj5cbiAgICA8ZGl2IGNsYXNzPVwiay12YXItLWNoYXJ0LWxpbmUtaW5hY3RpdmUtb3BhY2l0eVwiPjwvZGl2PlxuXG4gICAgPGRpdiBjbGFzcz1cImstd2lkZ2V0IGstY2hhcnRcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImstdmFyLS1jaGFydC1mb250XCI+PC9kaXY+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJrLXZhci0tY2hhcnQtdGl0bGUtZm9udFwiPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiay12YXItLWNoYXJ0LXBhbmUtdGl0bGUtZm9udFwiPjwvZGl2PlxuICAgICAgICA8ZGl2IGNsYXNzPVwiay12YXItLWNoYXJ0LWxhYmVsLWZvbnRcIj48L2Rpdj5cbiAgICA8L2Rpdj5cblxuICAgIDxkaXYgY2xhc3M9XCJrLXZhci0tc2VyaWVzLXVuc2V0XCI+PC9kaXY+XG4gICAgPGRpdiBjbGFzcz1cImstdmFyLS1zZXJpZXNcIj5cbiAgICAgICR7c2VyaWVzVGVtcGxhdGUoKX1cbiAgICA8L2Rpdj5cbmA7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFRoZW1lU2VydmljZSA9IGNsYXNzIFRoZW1lU2VydmljZSBleHRlbmRzIENvbmZpZ3VyYXRpb25TZXJ2aWNlIHtcbiAgICBjb25zdHJ1Y3RvcihuZ1pvbmUpIHtcbiAgICAgICAgc3VwZXIobmdab25lKTtcbiAgICAgICAgdGhpcy5sb2FkZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgbG9hZFRoZW1lKCkge1xuICAgICAgICBpZiAodGhpcy5sb2FkZWQgfHwgIWlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5yZWFkVGhlbWUoKSkge1xuICAgICAgICAgICAgdGhpcy5yZWFkRGVmYXVsdFRoZW1lKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sb2FkZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm5leHQoKTtcbiAgICB9XG4gICAgcmVhZFRoZW1lKCkge1xuICAgICAgICB0aGlzLmNyZWF0ZUVsZW1lbnQoKTtcbiAgICAgICAgY29uc3QgYXZhaWxhYmxlID0gdGhpcy5xdWVyeUNvbG9yKCdhY2NlbnQnKSAhPT1cbiAgICAgICAgICAgIHRoaXMucXVlcnlDb2xvcignYWNjZW50LWNvbnRyYXN0Jyk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAoYXZhaWxhYmxlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5wdXNoKGNoYXJ0QmFzZVRoZW1lKCkpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0Q29sb3JzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRGb250cygpO1xuICAgICAgICAgICAgICAgIHRoaXMuc2V0U2VyaWVzQ29sb3JzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZmluYWxseSB7XG4gICAgICAgICAgICB0aGlzLmRlc3Ryb3lFbGVtZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGF2YWlsYWJsZTtcbiAgICB9XG4gICAgcmVhZERlZmF1bHRUaGVtZSgpIHtcbiAgICAgICAgdGhpcy5wdXNoKGNoYXJ0RGVmYXVsdFRoZW1lKCkpO1xuICAgIH1cbiAgICBjcmVhdGVFbGVtZW50KCkge1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSB0aGlzLmVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgY29udGFpbmVyLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgICAgIGNvbnRhaW5lci5pbm5lckhUTUwgPSB0ZW1wbGF0ZSgpO1xuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG4gICAgfVxuICAgIGRlc3Ryb3lFbGVtZW50KCkge1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICBkb2N1bWVudC5ib2R5LnJlbW92ZUNoaWxkKHRoaXMuZWxlbWVudCk7XG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0U3R5bGUoa2V5LCB2YWx1ZSkge1xuICAgICAgICB0aGlzLnNldChrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgc2V0Q29sb3JzKCkge1xuICAgICAgICB0aGlzLm1hcENvbG9yKCdheGlzRGVmYXVsdHMuY3Jvc3NoYWlyLmNvbG9yJywgJ2NoYXJ0LWNyb3NzaGFpci1iYWNrZ3JvdW5kJyk7XG4gICAgICAgIHRoaXMubWFwQ29sb3IoJ2F4aXNEZWZhdWx0cy5sYWJlbHMuY29sb3InLCAnbm9ybWFsLXRleHQtY29sb3InKTtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignYXhpc0RlZmF1bHRzLmxpbmUuY29sb3InLCAnY2hhcnQtbWFqb3ItbGluZXMnKTtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignYXhpc0RlZmF1bHRzLm1ham9yR3JpZExpbmVzLmNvbG9yJywgJ2NoYXJ0LW1ham9yLWxpbmVzJyk7XG4gICAgICAgIHRoaXMubWFwQ29sb3IoJ2F4aXNEZWZhdWx0cy5taW5vckdyaWRMaW5lcy5jb2xvcicsICdjaGFydC1taW5vci1saW5lcycpO1xuICAgICAgICB0aGlzLm1hcENvbG9yKCdheGlzRGVmYXVsdHMubm90ZXMuaWNvbi5iYWNrZ3JvdW5kJywgJ2NoYXJ0LW5vdGVzLWJhY2tncm91bmQnKTtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignYXhpc0RlZmF1bHRzLm5vdGVzLmljb24uYm9yZGVyLmNvbG9yJywgJ2NoYXJ0LW5vdGVzLWJvcmRlcicpO1xuICAgICAgICB0aGlzLm1hcENvbG9yKCdheGlzRGVmYXVsdHMubm90ZXMubGluZS5jb2xvcicsICdjaGFydC1ub3Rlcy1saW5lcycpO1xuICAgICAgICB0aGlzLm1hcENvbG9yKCdheGlzRGVmYXVsdHMudGl0bGUuY29sb3InLCAnbm9ybWFsLXRleHQtY29sb3InKTtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignY2hhcnRBcmVhLmJhY2tncm91bmQnLCAnYmFja2dyb3VuZCcpO1xuICAgICAgICB0aGlzLm1hcENvbG9yKCdsZWdlbmQuaW5hY3RpdmVJdGVtcy5sYWJlbHMuY29sb3InLCAnY2hhcnQtaW5hY3RpdmUnKTtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignbGVnZW5kLmluYWN0aXZlSXRlbXMubWFya2Vycy5jb2xvcicsICdjaGFydC1pbmFjdGl2ZScpO1xuICAgICAgICB0aGlzLm1hcENvbG9yKCdsZWdlbmQubGFiZWxzLmNvbG9yJywgJ25vcm1hbC10ZXh0LWNvbG9yJyk7XG4gICAgICAgIHRoaXMubWFwQ29sb3IoJ3Nlcmllc0RlZmF1bHRzLmJveFBsb3QuZG93bkNvbG9yJywgJ2NoYXJ0LW1ham9yLWxpbmVzJyk7XG4gICAgICAgIHRoaXMubWFwQ29sb3IoJ3Nlcmllc0RlZmF1bHRzLmJveFBsb3QubWVhbi5jb2xvcicsICdiYXNlJyk7XG4gICAgICAgIHRoaXMubWFwQ29sb3IoJ3Nlcmllc0RlZmF1bHRzLmJveFBsb3QubWVkaWFuLmNvbG9yJywgJ2Jhc2UnKTtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignc2VyaWVzRGVmYXVsdHMuYm94UGxvdC53aGlza2Vycy5jb2xvcicsICdhY2NlbnQnKTtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignc2VyaWVzRGVmYXVsdHMuYnVsbGV0LnRhcmdldC5jb2xvcicsICdub3JtYWwtdGV4dC1jb2xvcicpO1xuICAgICAgICB0aGlzLm1hcENvbG9yKCdzZXJpZXNEZWZhdWx0cy5jYW5kbGVzdGljay5kb3duQ29sb3InLCAnbm9ybWFsLXRleHQtY29sb3InKTtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignc2VyaWVzRGVmYXVsdHMuY2FuZGxlc3RpY2subGluZS5jb2xvcicsICdub3JtYWwtdGV4dC1jb2xvcicpO1xuICAgICAgICB0aGlzLm1hcENvbG9yKCdzZXJpZXNEZWZhdWx0cy5lcnJvckJhcnMuY29sb3InLCAnY2hhcnQtZXJyb3ItYmFycy1iYWNrZ3JvdW5kJyk7XG4gICAgICAgIHRoaXMubWFwQ29sb3IoJ3Nlcmllc0RlZmF1bHRzLmhvcml6b250YWxXYXRlcmZhbGwubGluZS5jb2xvcicsICdjaGFydC1tYWpvci1saW5lcycpO1xuICAgICAgICB0aGlzLm1hcENvbG9yKCdzZXJpZXNEZWZhdWx0cy5pY29uLmJvcmRlci5jb2xvcicsICdjaGFydC1tYWpvci1saW5lcycpO1xuICAgICAgICB0aGlzLm1hcENvbG9yKCdzZXJpZXNEZWZhdWx0cy5sYWJlbHMuYmFja2dyb3VuZCcsICdiYWNrZ3JvdW5kJyk7XG4gICAgICAgIHRoaXMubWFwQ29sb3IoJ3Nlcmllc0RlZmF1bHRzLmxhYmVscy5jb2xvcicsICdub3JtYWwtdGV4dC1jb2xvcicpO1xuICAgICAgICB0aGlzLm1hcENvbG9yKCdzZXJpZXNEZWZhdWx0cy5ub3Rlcy5pY29uLmJhY2tncm91bmQnLCAnY2hhcnQtbm90ZXMtYmFja2dyb3VuZCcpO1xuICAgICAgICB0aGlzLm1hcENvbG9yKCdzZXJpZXNEZWZhdWx0cy5ub3Rlcy5pY29uLmJvcmRlci5jb2xvcicsICdjaGFydC1ub3Rlcy1ib3JkZXInKTtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignc2VyaWVzRGVmYXVsdHMubm90ZXMubGluZS5jb2xvcicsICdjaGFydC1ub3Rlcy1saW5lcycpO1xuICAgICAgICB0aGlzLm1hcENvbG9yKCdzZXJpZXNEZWZhdWx0cy52ZXJ0aWNhbEJveFBsb3QuZG93bkNvbG9yJywgJ2NoYXJ0LW1ham9yLWxpbmVzJyk7XG4gICAgICAgIHRoaXMubWFwQ29sb3IoJ3Nlcmllc0RlZmF1bHRzLnZlcnRpY2FsQm94UGxvdC5tZWFuLmNvbG9yJywgJ2Jhc2UnKTtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignc2VyaWVzRGVmYXVsdHMudmVydGljYWxCb3hQbG90Lm1lZGlhbi5jb2xvcicsICdiYXNlJyk7XG4gICAgICAgIHRoaXMubWFwQ29sb3IoJ3Nlcmllc0RlZmF1bHRzLnZlcnRpY2FsQm94UGxvdC53aGlza2Vycy5jb2xvcicsICdhY2NlbnQnKTtcbiAgICAgICAgdGhpcy5tYXBDb2xvcignc2VyaWVzRGVmYXVsdHMudmVydGljYWxCdWxsZXQudGFyZ2V0LmNvbG9yJywgJ25vcm1hbC10ZXh0LWNvbG9yJyk7XG4gICAgICAgIHRoaXMubWFwQ29sb3IoJ3Nlcmllc0RlZmF1bHRzLndhdGVyZmFsbC5saW5lLmNvbG9yJywgJ2NoYXJ0LW1ham9yLWxpbmVzJyk7XG4gICAgICAgIHRoaXMubWFwQ29sb3IoJ3RpdGxlLmNvbG9yJywgJ25vcm1hbC10ZXh0LWNvbG9yJyk7XG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSBwYXJzZUZsb2F0KHRoaXMucXVlcnlTdHlsZSgnY2hhcnQtYXJlYS1vcGFjaXR5Jykub3BhY2l0eSk7XG4gICAgICAgIGlmICghaXNOYU4ob3BhY2l0eSkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3R5bGUoJ3Nlcmllc0RlZmF1bHRzLmFyZWEub3BhY2l0eScsIG9wYWNpdHkpO1xuICAgICAgICAgICAgdGhpcy5zZXRTdHlsZSgnc2VyaWVzRGVmYXVsdHMucmFkYXJBcmVhLm9wYWNpdHknLCBvcGFjaXR5KTtcbiAgICAgICAgICAgIHRoaXMuc2V0U3R5bGUoJ3Nlcmllc0RlZmF1bHRzLnZlcnRpY2FsQXJlYS5vcGFjaXR5Jywgb3BhY2l0eSk7XG4gICAgICAgICAgICB0aGlzLnNldFN0eWxlKCdzZXJpZXNEZWZhdWx0cy5sYWJlbHMub3BhY2l0eScsIG9wYWNpdHkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0SW5hY3RpdmVPcGFjaXR5KFsnYXJlYScsICd2ZXJ0aWNhbEFyZWEnXSwgJ2NoYXJ0LWFyZWEtaW5hY3RpdmUtb3BhY2l0eScpO1xuICAgICAgICB0aGlzLnNldEluYWN0aXZlT3BhY2l0eShbJ2xpbmUnLCAndmVydGljYWxMaW5lJ10sICdjaGFydC1saW5lLWluYWN0aXZlLW9wYWNpdHknKTtcbiAgICB9XG4gICAgc2V0SW5hY3RpdmVPcGFjaXR5KHNlcmllc1R5cGVzLCBzZWxlY3Rvcikge1xuICAgICAgICBjb25zdCBpbmFjdGl2ZU9wYWNpdHkgPSBwYXJzZUZsb2F0KHRoaXMucXVlcnlTdHlsZShzZWxlY3Rvcikub3BhY2l0eSk7XG4gICAgICAgIGlmICghaXNOYU4oaW5hY3RpdmVPcGFjaXR5KSAmJiBpbmFjdGl2ZU9wYWNpdHkgPCAxKSB7XG4gICAgICAgICAgICBzZXJpZXNUeXBlcy5mb3JFYWNoKHR5cGUgPT4gdGhpcy5zZXRTdHlsZShgc2VyaWVzRGVmYXVsdHMuJHt0eXBlfS5oaWdobGlnaHQuaW5hY3RpdmVPcGFjaXR5YCwgaW5hY3RpdmVPcGFjaXR5KSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Rm9udHMoKSB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRGb250ID0gZm9udCh0aGlzLnF1ZXJ5U3R5bGUoJ2NoYXJ0LWZvbnQnKSk7XG4gICAgICAgIGNvbnN0IHRpdGxlRm9udCA9IGZvbnQodGhpcy5xdWVyeVN0eWxlKCdjaGFydC10aXRsZS1mb250JykpO1xuICAgICAgICBjb25zdCBwYW5lVGl0bGVGb250ID0gZm9udCh0aGlzLnF1ZXJ5U3R5bGUoJ2NoYXJ0LXBhbmUtdGl0bGUtZm9udCcpKTtcbiAgICAgICAgY29uc3QgbGFiZWxGb250ID0gZm9udCh0aGlzLnF1ZXJ5U3R5bGUoJ2NoYXJ0LWxhYmVsLWZvbnQnKSk7XG4gICAgICAgIHRoaXMuc2V0U3R5bGUoJ2F4aXNEZWZhdWx0cy5sYWJlbHMuZm9udCcsIGxhYmVsRm9udCk7XG4gICAgICAgIHRoaXMuc2V0U3R5bGUoJ2F4aXNEZWZhdWx0cy5ub3Rlcy5sYWJlbC5mb250JywgZGVmYXVsdEZvbnQpO1xuICAgICAgICB0aGlzLnNldFN0eWxlKCdheGlzRGVmYXVsdHMudGl0bGUuZm9udCcsIGRlZmF1bHRGb250KTtcbiAgICAgICAgdGhpcy5zZXRTdHlsZSgnbGVnZW5kLmxhYmVscy5mb250JywgZGVmYXVsdEZvbnQpO1xuICAgICAgICB0aGlzLnNldFN0eWxlKCdzZXJpZXNEZWZhdWx0cy5sYWJlbHMuZm9udCcsIGxhYmVsRm9udCk7XG4gICAgICAgIHRoaXMuc2V0U3R5bGUoJ3Nlcmllc0RlZmF1bHRzLm5vdGVzLmxhYmVsLmZvbnQnLCBkZWZhdWx0Rm9udCk7XG4gICAgICAgIHRoaXMuc2V0U3R5bGUoJ3RpdGxlLmZvbnQnLCB0aXRsZUZvbnQpO1xuICAgICAgICB0aGlzLnNldFN0eWxlKCdwYW5lRGVmYXVsdHMudGl0bGUuZm9udCcsIHBhbmVUaXRsZUZvbnQpO1xuICAgIH1cbiAgICBzZXRTZXJpZXNDb2xvcnMoKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IHNlcmllcyA9IFtdLnNsaWNlLmNhbGwoZWxlbWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuay12YXItLXNlcmllcyBkaXYnKSk7XG4gICAgICAgIGNvbnN0IHVuc2V0Q29sb3IgPSBjb21wdXRlZEJhY2tncm91bmRDb2xvcihlbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy5rLXZhci0tc2VyaWVzLXVuc2V0JykpO1xuICAgICAgICBjb25zdCBzZXJpZXNDb2xvcnMgPSBzZXJpZXMucmVkdWNlKChhcnIsIGVsKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwb3MgPSBzZXJpZXNQb3MoZWwuY2xhc3NOYW1lKTtcbiAgICAgICAgICAgIGNvbnN0IGNvbG9yID0gY29tcHV0ZWRCYWNrZ3JvdW5kQ29sb3IoZWwpO1xuICAgICAgICAgICAgaWYgKGNvbG9yICE9PSB1bnNldENvbG9yKSB7XG4gICAgICAgICAgICAgICAgYXJyW3Bvc10gPSBjb2xvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnI7XG4gICAgICAgIH0sIFtdIC8vIFdpbGwgcG9wdWxhdGUgdGhlIHNlcmllcyBjb2xvcnMgaW4gdGhpcyBhcnJheVxuICAgICAgICApO1xuICAgICAgICB0aGlzLnNldFN0eWxlKCdzZXJpZXNDb2xvcnMnLCBzZXJpZXNDb2xvcnMpO1xuICAgIH1cbiAgICBtYXBDb2xvcihrZXksIHZhck5hbWUpIHtcbiAgICAgICAgdGhpcy5zZXRTdHlsZShrZXksIHRoaXMucXVlcnlDb2xvcih2YXJOYW1lKSk7XG4gICAgfVxuICAgIHF1ZXJ5Q29sb3IodmFyTmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5xdWVyeVN0eWxlKHZhck5hbWUpLmJhY2tncm91bmRDb2xvcjtcbiAgICB9XG4gICAgcXVlcnlTdHlsZSh2YXJOYW1lKSB7XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLmVsZW1lbnQucXVlcnlTZWxlY3RvcihgLmstdmFyLS0ke3Zhck5hbWV9YCk7XG4gICAgICAgIHJldHVybiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgICB9XG59O1xuVGhlbWVTZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbTmdab25lXSlcbl0sIFRoZW1lU2VydmljZSk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBDaGFydEluc3RhbmNlT2JzZXJ2ZXIgZXh0ZW5kcyBJbnN0YW5jZU9ic2VydmVyIHtcbiAgICBjb25zdHJ1Y3RvcihpbnN0YW5jZSkge1xuICAgICAgICBzdXBlcihpbnN0YW5jZSk7XG4gICAgICAgIHRoaXMuaGFuZGxlck1hcCA9IHtcbiAgICAgICAgICAgIGhpZGVUb29sdGlwOiAnb25IaWRlVG9vbHRpcCcsXG4gICAgICAgICAgICBsZWdlbmRJdGVtQ2xpY2s6ICdvbkxlZ2VuZEl0ZW1DbGljaycsXG4gICAgICAgICAgICByZW5kZXI6ICdvblJlbmRlcicsXG4gICAgICAgICAgICBzaG93VG9vbHRpcDogJ29uU2hvd1Rvb2x0aXAnLFxuICAgICAgICAgICAgaW5pdDogJ29uSW5pdCdcbiAgICAgICAgfTtcbiAgICB9XG59XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgVG9vbHRpcFRlbXBsYXRlU2VydmljZSA9IGNsYXNzIFRvb2x0aXBUZW1wbGF0ZVNlcnZpY2Uge1xuICAgIHNldFRlbXBsYXRlKHRlbXBsYXRlKSB7XG4gICAgICAgIHRoaXMudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICB9XG4gICAgZ2V0VGVtcGxhdGUoc2VyaWVzSW5kZXgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2VyaWVzVGVtcGxhdGVzICYmIHRoaXMuc2VyaWVzVGVtcGxhdGVzW3Nlcmllc0luZGV4XSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VyaWVzVGVtcGxhdGVzW3Nlcmllc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZTtcbiAgICB9XG4gICAgc2V0U2VyaWVzVGVtcGxhdGVzKHNlcmllc1RlbXBsYXRlcykge1xuICAgICAgICB0aGlzLnNlcmllc1RlbXBsYXRlcyA9IHNlcmllc1RlbXBsYXRlcztcbiAgICB9XG4gICAgc2V0U2hhcmVkVGVtcGxhdGUoc2hhcmVkVGVtcGxhdGUpIHtcbiAgICAgICAgdGhpcy5zaGFyZWRUZW1wbGF0ZSA9IHNoYXJlZFRlbXBsYXRlO1xuICAgIH1cbiAgICBnZXRTaGFyZWRUZW1wbGF0ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcmVkVGVtcGxhdGU7XG4gICAgfVxufTtcblRvb2x0aXBUZW1wbGF0ZVNlcnZpY2UgPSBfX2RlY29yYXRlKFtcbiAgICBJbmplY3RhYmxlKClcbl0sIFRvb2x0aXBUZW1wbGF0ZVNlcnZpY2UpO1xuXG4vKipcbiAqIEEgZGlyZWN0aXZlIHRoYXQgc2VsZWN0cyBhIFt0ZW1wbGF0ZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsndGVtcGxhdGVzeW50YXgnXSB9fSlcbiAqIHdpdGhpbiB0aGUgYDxrZW5kby1jaGFydC10b29sdGlwPmAgY29tcG9uZW50IGZvciB0aGVcbiAqIFtzZXJpZXMgdG9vbHRpcF0oeyUgc2x1ZyB0b29sdGlwc19jaGFydF9jaGFydHMgJX0jdG9jLXNlcmllcy10b29sdGlwKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICB0ZW1wbGF0ZTogYFxuICogICAgIDxrZW5kby1jaGFydD5cbiAqICAgICAgIDxrZW5kby1jaGFydC10b29sdGlwPlxuICogICAgICAgICAgPG5nLXRlbXBsYXRlIGtlbmRvQ2hhcnRTZXJpZXNUb29sdGlwVGVtcGxhdGUgbGV0LXZhbHVlPVwidmFsdWVcIj5cbiAqICAgICAgICAgICAgIFZhbHVlIGlzIHt7dmFsdWV9fVxuICogICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gKiAgICAgICA8L2tlbmRvLWNoYXJ0LXRvb2x0aXA+XG4gKiAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzPlxuICogICAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0gW2RhdGFdPVwiWzEsIDIsIDNdXCI+XG4gKiAgICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0+XG4gKiAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICA8L2tlbmRvLWNoYXJ0PlxuICogICBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqIH1cbiAqXG4gKiBgYGBcbiAqL1xubGV0IFNlcmllc1Rvb2x0aXBUZW1wbGF0ZURpcmVjdGl2ZSA9IGNsYXNzIFNlcmllc1Rvb2x0aXBUZW1wbGF0ZURpcmVjdGl2ZSB7XG4gICAgY29uc3RydWN0b3IodGVtcGxhdGVSZWYpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVJlZiA9IHRlbXBsYXRlUmVmO1xuICAgIH1cbn07XG5TZXJpZXNUb29sdGlwVGVtcGxhdGVEaXJlY3RpdmUgPSBfX2RlY29yYXRlKFtcbiAgICBEaXJlY3RpdmUoe1xuICAgICAgICBzZWxlY3RvcjogJ1trZW5kb0NoYXJ0U2VyaWVzVG9vbHRpcFRlbXBsYXRlXSdcbiAgICB9KSxcbiAgICBfX3BhcmFtKDAsIE9wdGlvbmFsKCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbVGVtcGxhdGVSZWZdKVxuXSwgU2VyaWVzVG9vbHRpcFRlbXBsYXRlRGlyZWN0aXZlKTtcblxuLyoqXG4gKiBBIGRpcmVjdGl2ZSB0aGF0IHNlbGVjdHMgYSBbdGVtcGxhdGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ3RlbXBsYXRlc3ludGF4J10gfX0pXG4gKiB3aXRoaW4gdGhlIGA8a2VuZG8tY2hhcnQtdG9vbHRpcD5gIGNvbXBvbmVudCBmb3IgdGhlXG4gKiBbc2hhcmVkIHNlcmllcyB0b29sdGlwXSh7JSBzbHVnIHRvb2x0aXBzX2NoYXJ0X2NoYXJ0cyAlfSN0b2Mtc2hhcmVkLXRvb2x0aXApLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgPGtlbmRvLWNoYXJ0PlxuICogICAgICAgPGtlbmRvLWNoYXJ0LXRvb2x0aXAgW3NoYXJlZF09XCJ0cnVlXCI+XG4gKiAgICAgICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0NoYXJ0U2hhcmVkVG9vbHRpcFRlbXBsYXRlIGxldC1jYXRlZ29yeT1cImNhdGVnb3J5XCIgbGV0LXBvaW50cz1cInBvaW50c1wiPlxuICogICAgICAgICAgICAgPGRpdj4ge3sgY2F0ZWdvcnkgfX0gPC9kaXY+XG4gKiAgICAgICAgICAgICA8ZGl2ICpuZ0Zvcj1cImxldCBwb2ludCBvZiBwb2ludHNcIj5cbiAqICAgICAgICAgICAgICAgICB7eyBwb2ludC5zZXJpZXMubmFtZSB9fSA6IHt7IHBvaW50LnZhbHVlIH19XG4gKiAgICAgICAgICAgICA8L2Rpdj5cbiAqICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAqICAgICAgIDwva2VuZG8tY2hhcnQtdG9vbHRpcD5cbiAqICAgICAgIDxrZW5kby1jaGFydC1jYXRlZ29yeS1heGlzPlxuICogICAgICAgICA8a2VuZG8tY2hhcnQtY2F0ZWdvcnktYXhpcy1pdGVtIFtjYXRlZ29yaWVzXT1cIlsnQScsICdCJywgJ0MnXVwiPlxuICogICAgICAgICA8L2tlbmRvLWNoYXJ0LWNhdGVnb3J5LWF4aXMtaXRlbT5cbiAqICAgICAgIDwva2VuZG8tY2hhcnQtY2F0ZWdvcnktYXhpcz5cbiAqICAgICAgIDxrZW5kby1jaGFydC1zZXJpZXM+XG4gKiAgICAgICAgIDxrZW5kby1jaGFydC1zZXJpZXMtaXRlbSBuYW1lPVwiQVwiIFtkYXRhXT1cIlsxLCAyLCAzXVwiPlxuICogICAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtPlxuICogICAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0gbmFtZT1cIkJcIiBbZGF0YV09XCJbMSwgMiwgM11cIj5cbiAqICAgICAgICAgPC9rZW5kby1jaGFydC1zZXJpZXMtaXRlbT5cbiAqICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzPlxuICogICAgIDwva2VuZG8tY2hhcnQ+XG4gKiAgIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogfVxuICpcbiAqIGBgYFxuICovXG5sZXQgU2hhcmVkVG9vbHRpcFRlbXBsYXRlRGlyZWN0aXZlID0gY2xhc3MgU2hhcmVkVG9vbHRpcFRlbXBsYXRlRGlyZWN0aXZlIHtcbiAgICBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZVJlZikge1xuICAgICAgICB0aGlzLnRlbXBsYXRlUmVmID0gdGVtcGxhdGVSZWY7XG4gICAgfVxufTtcblNoYXJlZFRvb2x0aXBUZW1wbGF0ZURpcmVjdGl2ZSA9IF9fZGVjb3JhdGUoW1xuICAgIERpcmVjdGl2ZSh7XG4gICAgICAgIHNlbGVjdG9yOiAnW2tlbmRvQ2hhcnRTaGFyZWRUb29sdGlwVGVtcGxhdGVdJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMCwgT3B0aW9uYWwoKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtUZW1wbGF0ZVJlZl0pXG5dLCBTaGFyZWRUb29sdGlwVGVtcGxhdGVEaXJlY3RpdmUpO1xuXG4vKipcbiAqIFRoZSBwb2ludCB0aGF0IGlzIHBhc3NlZCB0byB0aGUgdG9vbHRpcCB0ZW1wbGF0ZS5cbiAqL1xuY2xhc3MgVG9vbHRpcFRlbXBsYXRlUG9pbnQge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihwb2ludCwgZm9ybWF0LCB0ZW1wbGF0ZSkge1xuICAgICAgICB0aGlzLnZhbHVlID0gcG9pbnQudmFsdWU7XG4gICAgICAgIHRoaXMuY2F0ZWdvcnkgPSBwb2ludC5jYXRlZ29yeTtcbiAgICAgICAgdGhpcy5jYXRlZ29yeUluZGV4ID0gcG9pbnQuY2F0ZWdvcnlJeDtcbiAgICAgICAgdGhpcy5zZXJpZXMgPSBwb2ludC5zZXJpZXM7XG4gICAgICAgIHRoaXMuZGF0YUl0ZW0gPSBwb2ludC5kYXRhSXRlbTtcbiAgICAgICAgdGhpcy5wZXJjZW50YWdlID0gcG9pbnQucGVyY2VudGFnZTtcbiAgICAgICAgdGhpcy5ydW5uaW5nVG90YWwgPSBwb2ludC5ydW5uaW5nVG90YWw7XG4gICAgICAgIHRoaXMudG90YWwgPSBwb2ludC50b3RhbDtcbiAgICAgICAgdGhpcy5sb3cgPSBwb2ludC5sb3c7XG4gICAgICAgIHRoaXMuaGlnaCA9IHBvaW50LmhpZ2g7XG4gICAgICAgIHRoaXMueExvdyA9IHBvaW50LnhMb3c7XG4gICAgICAgIHRoaXMueEhpZ2ggPSBwb2ludC54SGlnaDtcbiAgICAgICAgdGhpcy55TG93ID0gcG9pbnQueUxvdztcbiAgICAgICAgdGhpcy55SGlnaCA9IHBvaW50LnlIaWdoO1xuICAgICAgICB0aGlzLnRlbXBsYXRlID0gdGVtcGxhdGU7XG4gICAgICAgIHRoaXMucG9pbnQgPSBwb2ludDtcbiAgICAgICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBnZXQgZm9ybWF0dGVkVmFsdWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm1hdCA/IHRoaXMucG9pbnQuZm9ybWF0VmFsdWUodGhpcy5mb3JtYXQpIDogU3RyaW5nKHRoaXMudmFsdWUpO1xuICAgIH1cbn1cblxuLyogdHNsaW50OmRpc2FibGU6YWxpZ24gbm8tZW1wdHkgKi9cbmNvbnN0IFBPU0lUSU9OX01PREUgPSAnYWJzb2x1dGUnO1xuY29uc3QgQ09MTElTSU9OID0geyBob3Jpem9udGFsOiBcImZpdFwiLCB2ZXJ0aWNhbDogXCJmaXRcIiB9O1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEJhc2VUb29sdGlwIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3B1cFNlcnZpY2UsIGxvY2FsaXphdGlvblNlcnZpY2UpIHtcbiAgICAgICAgdGhpcy5wb3B1cFNlcnZpY2UgPSBwb3B1cFNlcnZpY2U7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uU2VydmljZSA9IGxvY2FsaXphdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuc3R5bGUgPSB7fTtcbiAgICAgICAgdGhpcy5wb3B1cFJlZiA9IG51bGw7XG4gICAgfVxuICAgIGdldCBhY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBvcHVwUmVmICE9PSBudWxsO1xuICAgIH1cbiAgICBzaG93KGUpIHtcbiAgICAgICAgY29uc3QgYWxpZ24gPSBlLmFuY2hvci5hbGlnbjtcbiAgICAgICAgY29uc3Qgb2Zmc2V0ID0gdGhpcy5wb3NpdGlvbihlLmFuY2hvci5wb2ludCk7XG4gICAgICAgIHRoaXMuc3R5bGUgPSBlLnN0eWxlO1xuICAgICAgICBpZiAoIXRoaXMucG9wdXBSZWYpIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXBSZWYgPSB0aGlzLnBvcHVwU2VydmljZS5vcGVuKE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgICAgIG9mZnNldDogb2Zmc2V0LFxuICAgICAgICAgICAgICAgIHBvcHVwQWxpZ246IGFsaWduLFxuICAgICAgICAgICAgICAgIGFuaW1hdGU6IHRoaXMuYW5pbWF0ZSxcbiAgICAgICAgICAgICAgICBjb250ZW50OiB0aGlzLnRlbXBsYXRlUmVmLFxuICAgICAgICAgICAgICAgIGNvbGxpc2lvbjogQ09MTElTSU9OLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uTW9kZTogUE9TSVRJT05fTU9ERVxuICAgICAgICAgICAgfSwgdGhpcy5wb3B1cFNldHRpbmdzKSk7XG4gICAgICAgICAgICBpZiAodGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlLnJ0bCkge1xuICAgICAgICAgICAgICAgIHRoaXMucG9wdXBSZWYucG9wdXBFbGVtZW50LnNldEF0dHJpYnV0ZSgnZGlyJywgJ3J0bCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5vbkluaXQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHBvcHVwID0gdGhpcy5wb3B1cFJlZi5wb3B1cC5pbnN0YW5jZTtcbiAgICAgICAgICAgIHBvcHVwLm9mZnNldCA9IG9mZnNldDtcbiAgICAgICAgICAgIHBvcHVwLnBvcHVwQWxpZ24gPSBhbGlnbjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBoaWRlKCkge1xuICAgICAgICBpZiAodGhpcy5wb3B1cFJlZikge1xuICAgICAgICAgICAgdGhpcy5wb3B1cFJlZi5jbG9zZSgpO1xuICAgICAgICAgICAgdGhpcy5wb3B1cFJlZiA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgb25Jbml0KCkge1xuICAgIH1cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5oaWRlKCk7XG4gICAgfVxuICAgIHBvc2l0aW9uKG9mZnNldCkge1xuICAgICAgICBpZiAoIXRoaXMucG9wdXBTZXR0aW5ncyB8fCAhdGhpcy5wb3B1cFNldHRpbmdzLmFwcGVuZFRvKSB7XG4gICAgICAgICAgICByZXR1cm4gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwcGVuZFRvID0gdGhpcy5wb3B1cFNldHRpbmdzLmFwcGVuZFRvLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgY29uc29sZS5sb2coJ2FwcGVuZFRvJywgYXBwZW5kVG8pO1xuICAgICAgICBjb25zdCBiYm94ID0gYXBwZW5kVG8uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IHsgc2Nyb2xsTGVmdCwgc2Nyb2xsVG9wIH0gPSB0aGlzLnNjcm9sbE9mZnNldChhcHBlbmRUbyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsZWZ0OiBvZmZzZXQubGVmdCAtIGJib3gubGVmdCAtIHNjcm9sbExlZnQsXG4gICAgICAgICAgICB0b3A6IG9mZnNldC50b3AgLSBiYm94LnRvcCAtIHNjcm9sbFRvcFxuICAgICAgICB9O1xuICAgIH1cbiAgICBzY3JvbGxPZmZzZXQoZWxlbWVudCkge1xuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzY3JvbGxMZWZ0ID0gZWxlbWVudC5zY3JvbGxMZWZ0O1xuICAgICAgICBsZXQgc2Nyb2xsVG9wID0gZWxlbWVudC5zY3JvbGxUb3A7XG4gICAgICAgIGxldCBwYXJlbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHNjcm9sbExlZnQgKz0gcGFyZW50LnNjcm9sbExlZnQ7XG4gICAgICAgICAgICBzY3JvbGxUb3AgKz0gcGFyZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IHNjcm9sbExlZnQsIHNjcm9sbFRvcCB9O1xuICAgIH1cbn1cblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmZ1bmN0aW9uIGhhc1BhcmVudChlbGVtZW50LCBwYXJlbnQpIHtcbiAgICBsZXQgY3VycmVudCA9IGVsZW1lbnQ7XG4gICAgd2hpbGUgKGN1cnJlbnQgJiYgY3VycmVudCAhPT0gcGFyZW50KSB7XG4gICAgICAgIGN1cnJlbnQgPSBjdXJyZW50LnBhcmVudE5vZGU7XG4gICAgfVxuICAgIHJldHVybiBjdXJyZW50ID8gdHJ1ZSA6IGZhbHNlO1xufVxuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuZnVuY3Rpb24gYm9keUZhY3RvcnkoKSB7XG4gICAgaWYgKGlzRG9jdW1lbnRBdmFpbGFibGUoKSkge1xuICAgICAgICByZXR1cm4gbmV3IEVsZW1lbnRSZWYoZG9jdW1lbnQuYm9keSk7XG4gICAgfVxufVxuXG5jb25zdCBTSEFSRURfVE9PTFRJUF9DTEFTUyA9ICdrLWNoYXJ0LXNoYXJlZC10b29sdGlwJztcbmNvbnN0IFRPT0xUSVBfQ0xBU1MgPSBcImstY2hhcnQtdG9vbHRpcFwiO1xuY29uc3QgybUwJDIgPSBib2R5RmFjdG9yeTtcbi8vIENvZGVseXplciAyLjAuMC1iZXRhMiBkb2Vzbid0IGhhbmRsZSBpbmhlcml0ZWQgbWVtYmVyc1xuLyogdHNsaW50OmRpc2FibGU6bm8tYWNjZXNzLW1pc3NpbmctbWVtYmVyICovXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFRvb2x0aXBQb3B1cENvbXBvbmVudCA9IGNsYXNzIFRvb2x0aXBQb3B1cENvbXBvbmVudCBleHRlbmRzIEJhc2VUb29sdGlwIHtcbiAgICBjb25zdHJ1Y3Rvcihwb3B1cFNlcnZpY2UsIHRlbXBsYXRlU2VydmljZSwgbG9jYWxpemF0aW9uU2VydmljZSwgbmdab25lKSB7XG4gICAgICAgIHN1cGVyKHBvcHVwU2VydmljZSwgbG9jYWxpemF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMucG9wdXBTZXJ2aWNlID0gcG9wdXBTZXJ2aWNlO1xuICAgICAgICB0aGlzLnRlbXBsYXRlU2VydmljZSA9IHRlbXBsYXRlU2VydmljZTtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlID0gbG9jYWxpemF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMuc2VyaWVzVG9vbHRpcENvbnRleHQgPSB7fTtcbiAgICAgICAgdGhpcy5zZXJpZXNTaGFyZWRUb29sdGlwQ29udGV4dCA9IHt9O1xuICAgICAgICB0aGlzLmFuaW1hdGUgPSB0cnVlO1xuICAgICAgICB0aGlzLndyYXBwZXJDbGFzcyA9ICdrLWNoYXJ0LXRvb2x0aXAtd3JhcHBlcic7XG4gICAgICAgIHRoaXMubGVhdmUgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIHRoaXMucG9wdXBDbGFzc2VzID0ge307XG4gICAgfVxuICAgIHNob3coZSkge1xuICAgICAgICB0aGlzLnNoYXJlZCA9IGUuc2hhcmVkO1xuICAgICAgICB0aGlzLnBvcHVwQ2xhc3NlcyA9IE9iamVjdC5hc3NpZ24oe1xuICAgICAgICAgICAgW1NIQVJFRF9UT09MVElQX0NMQVNTXTogZS5zaGFyZWQsXG4gICAgICAgICAgICBbVE9PTFRJUF9DTEFTU106IHRydWUsXG4gICAgICAgICAgICBbZS5jbGFzc05hbWVdOiAhIWUuY2xhc3NOYW1lXG4gICAgICAgIH0sIHRoaXMuY2xhc3NOYW1lcyk7XG4gICAgICAgIGlmICghZS5zaGFyZWQpIHtcbiAgICAgICAgICAgIHRoaXMuc2VyaWVzVG9vbHRpcENvbnRleHQgPSBuZXcgVG9vbHRpcFRlbXBsYXRlUG9pbnQoZS5wb2ludCwgZS5mb3JtYXQpO1xuICAgICAgICAgICAgdGhpcy5zZXJpZXNUb29sdGlwVGVtcGxhdGVSZWYgPSB0aGlzLnBvaW50VGVtcGxhdGVSZWYoZS5wb2ludCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNlcmllc1NoYXJlZFRvb2x0aXBUZW1wbGF0ZVJlZiA9IHRoaXMudGVtcGxhdGVTZXJ2aWNlLmdldFNoYXJlZFRlbXBsYXRlKClcbiAgICAgICAgICAgICAgICB8fCB0aGlzLmRlZmF1bHRTaGFyZWRUb29sdGlwVGVtcGxhdGUudGVtcGxhdGVSZWY7XG4gICAgICAgICAgICB0aGlzLnNlcmllc1NoYXJlZFRvb2x0aXBDb250ZXh0ID0gdGhpcy5zaGFyZWRUZW1wbGF0ZUNvbnRleHQoZSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuc2hvdyhlKTtcbiAgICB9XG4gICAgY29udGFpbnNFbGVtZW50KGVsZW1lbnQpIHtcbiAgICAgICAgaWYgKHRoaXMucG9wdXBSZWYpIHtcbiAgICAgICAgICAgIHJldHVybiBoYXNQYXJlbnQoZWxlbWVudCwgdGhpcy5wb3B1cFJlZi5wb3B1cEVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHNoYXJlZFRlbXBsYXRlQ29udGV4dChlKSB7XG4gICAgICAgIGNvbnN0IHBvaW50cyA9IGUucG9pbnRzO1xuICAgICAgICBjb25zdCBuYW1lQ29sdW1uID0gcG9pbnRzLmZpbHRlcigocG9pbnQpID0+IHR5cGVvZiBwb2ludC5zZXJpZXMubmFtZSAhPT0gJ3VuZGVmaW5lZCcpLmxlbmd0aCA+IDA7XG4gICAgICAgIGNvbnN0IGNvbG9yTWFya2VyID0gZS5zZXJpZXMubGVuZ3RoID4gMTtcbiAgICAgICAgbGV0IGNvbHNwYW4gPSAxO1xuICAgICAgICBpZiAobmFtZUNvbHVtbikge1xuICAgICAgICAgICAgY29sc3BhbisrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2xvck1hcmtlcikge1xuICAgICAgICAgICAgY29sc3BhbisrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjYXRlZ29yeTogZS5jYXRlZ29yeSxcbiAgICAgICAgICAgIGNhdGVnb3J5VGV4dDogZS5jYXRlZ29yeVRleHQsXG4gICAgICAgICAgICBjb2xvck1hcmtlcjogY29sb3JNYXJrZXIsXG4gICAgICAgICAgICBjb2xzcGFuOiBjb2xzcGFuLFxuICAgICAgICAgICAgbmFtZUNvbHVtbjogbmFtZUNvbHVtbixcbiAgICAgICAgICAgIHBvaW50czogdGhpcy53cmFwUG9pbnRzKGUucG9pbnRzLCBlLmZvcm1hdClcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcG9pbnRUZW1wbGF0ZVJlZihwb2ludCkge1xuICAgICAgICByZXR1cm4gdGhpcy50ZW1wbGF0ZVNlcnZpY2UuZ2V0VGVtcGxhdGUocG9pbnQuc2VyaWVzLmluZGV4KSB8fCB0aGlzLmRlZmF1bHRTZXJpZXNUb29sdGlwVGVtcGxhdGUudGVtcGxhdGVSZWY7XG4gICAgfVxuICAgIHdyYXBQb2ludHMocG9pbnRzLCBmb3JtYXQpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHBvaW50cy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBjb25zdCBwb2ludCA9IHBvaW50c1tpZHhdO1xuICAgICAgICAgICAgY29uc3QgdGVtcGxhdGUgPSB0aGlzLnBvaW50VGVtcGxhdGVSZWYocG9pbnQpO1xuICAgICAgICAgICAgY29uc3QgcG9pbnRGb3JtYXQgPSAoKHBvaW50Lm9wdGlvbnMgfHwge30pLnRvb2x0aXAgfHwge30pLmZvcm1hdCB8fCBmb3JtYXQ7XG4gICAgICAgICAgICByZXN1bHQucHVzaChuZXcgVG9vbHRpcFRlbXBsYXRlUG9pbnQocG9pbnQsIHBvaW50Rm9ybWF0LCB0ZW1wbGF0ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIG9uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5uZ1pvbmUucnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5tb3VzZWxlYXZlU3Vic2NyaXB0aW9uID0gdGhpcy5wb3B1cFJlZi5wb3B1cEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIChhcmdzKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5sZWF2ZS5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLnBvcHVwUmVmLnBvcHVwRWxlbWVudC5jbGFzc05hbWUgKz0gYCAke3RoaXMud3JhcHBlckNsYXNzfWA7XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICAgIGlmICh0aGlzLm1vdXNlbGVhdmVTdWJzY3JpcHRpb24pIHtcbiAgICAgICAgICAgIHRoaXMubW91c2VsZWF2ZVN1YnNjcmlwdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5tb3VzZWxlYXZlU3Vic2NyaXB0aW9uID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5oaWRlKCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZChTZXJpZXNUb29sdGlwVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU2VyaWVzVG9vbHRpcFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgVG9vbHRpcFBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkZWZhdWx0U2VyaWVzVG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoU2hhcmVkVG9vbHRpcFRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFNoYXJlZFRvb2x0aXBUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIFRvb2x0aXBQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwiZGVmYXVsdFNoYXJlZFRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdjb250ZW50JywgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFRlbXBsYXRlUmVmKVxuXSwgVG9vbHRpcFBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZVJlZlwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFRvb2x0aXBQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwiYW5pbWF0ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVG9vbHRpcFBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjbGFzc05hbWVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBUb29sdGlwUG9wdXBDb21wb25lbnQucHJvdG90eXBlLCBcInBvcHVwU2V0dGluZ3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRvb2x0aXBQb3B1cENvbXBvbmVudC5wcm90b3R5cGUsIFwid3JhcHBlckNsYXNzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBPdXRwdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRXZlbnRFbWl0dGVyKVxuXSwgVG9vbHRpcFBvcHVwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJsZWF2ZVwiLCB2b2lkIDApO1xuVG9vbHRpcFBvcHVwQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgcHJvdmlkZXJzOiBbUG9wdXBTZXJ2aWNlLCB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogUE9QVVBfQ09OVEFJTkVSLFxuICAgICAgICAgICAgICAgIHVzZUZhY3Rvcnk6IMm1MCQyXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC10b29sdGlwLXBvcHVwJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICA8bmctdGVtcGxhdGUgI2NvbnRlbnQ+XG4gICAgICAgIDxkaXYgW25nQ2xhc3NdPVwicG9wdXBDbGFzc2VzXCIgW25nU3R5bGVdPVwic3R5bGVcIj5cbiAgICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwic2VyaWVzVG9vbHRpcFRlbXBsYXRlUmVmXCIgKm5nSWY9XCIhc2hhcmVkXCJcbiAgICAgICAgICAgICAgICAgICAgW25nVGVtcGxhdGVPdXRsZXRDb250ZXh0XT1cInNlcmllc1Rvb2x0aXBDb250ZXh0XCI+XG4gICAgICAgICAgPC9uZy10ZW1wbGF0ZT5cbiAgICAgICAgICA8bmctdGVtcGxhdGUgW25nVGVtcGxhdGVPdXRsZXRdPVwic2VyaWVzU2hhcmVkVG9vbHRpcFRlbXBsYXRlUmVmXCIgKm5nSWY9XCJzaGFyZWRcIlxuICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwic2VyaWVzU2hhcmVkVG9vbHRpcENvbnRleHRcIj5cbiAgICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgICAgICA8L2Rpdj5cbiAgICA8L25nLXRlbXBsYXRlPlxuXG4gICAgPG5nLXRlbXBsYXRlIGtlbmRvQ2hhcnRTZXJpZXNUb29sdGlwVGVtcGxhdGUgbGV0LWZvcm1hdHRlZFZhbHVlPVwiZm9ybWF0dGVkVmFsdWVcIj5cbiAgICAgICAgPHNwYW4gW2lubmVySFRNTF09XCJmb3JtYXR0ZWRWYWx1ZVwiPjwvc3Bhbj5cbiAgICA8L25nLXRlbXBsYXRlPlxuICAgIDxuZy10ZW1wbGF0ZSBrZW5kb0NoYXJ0U2hhcmVkVG9vbHRpcFRlbXBsYXRlIGxldC1wb2ludHM9XCJwb2ludHNcIiBsZXQtY2F0ZWdvcnlUZXh0PVwiY2F0ZWdvcnlUZXh0XCIgbGV0LWNvbHNwYW49XCJjb2xzcGFuXCIgbGV0LWNvbG9yTWFya2VyPVwiY29sb3JNYXJrZXJcIiBsZXQtbmFtZUNvbHVtbj1cIm5hbWVDb2x1bW5cIiA+XG4gICAgICAgIDx0YWJsZT5cbiAgICAgICAgICAgIDx0cj48dGggW2F0dHIuY29sc3Bhbl09J2NvbHNwYW4nPiB7eyBjYXRlZ29yeVRleHQgfX0gPC90aD48L3RyPlxuICAgICAgICAgICAgPHRyICpuZ0Zvcj1cImxldCBwb2ludCBvZiBwb2ludHNcIj5cbiAgICAgICAgICAgICAgICA8dGQgKm5nSWY9XCJjb2xvck1hcmtlclwiPjxzcGFuIGNsYXNzPSdrLWNoYXJ0LXNoYXJlZC10b29sdGlwLW1hcmtlcicgW3N0eWxlLmJhY2tncm91bmQtY29sb3JdPSdwb2ludC5zZXJpZXMuY29sb3InPjwvc3Bhbj48L3RkPlxuICAgICAgICAgICAgICAgIDx0ZCAqbmdJZj1cIm5hbWVDb2x1bW5cIj5cbiAgICAgICAgICAgICAgICAgICAgPG5nLWNvbnRhaW5lciAqbmdJZj1cInBvaW50LnNlcmllcy5uYW1lICE9PSB1bmRlZmluZWRcIj57eyBwb2ludC5zZXJpZXMubmFtZSB9fTwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwicG9pbnQuc2VyaWVzLm5hbWUgPT09IHVuZGVmaW5lZFwiPiZuYnNwOzwvbmctY29udGFpbmVyPlxuICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgPHRkPlxuICAgICAgICAgICAgICAgICAgPG5nLXRlbXBsYXRlIFtuZ1RlbXBsYXRlT3V0bGV0XT1cInBvaW50LnRlbXBsYXRlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbbmdUZW1wbGF0ZU91dGxldENvbnRleHRdPVwicG9pbnRcIj5cbiAgICAgICAgICAgICAgICAgIDwvbmctdGVtcGxhdGU+XG4gICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgIDwvdHI+XG4gICAgICAgIDwvdGFibGU+XG4gICAgPC9uZy10ZW1wbGF0ZT5cbiAgICBgXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtQb3B1cFNlcnZpY2UsXG4gICAgICAgIFRvb2x0aXBUZW1wbGF0ZVNlcnZpY2UsXG4gICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgIE5nWm9uZV0pXG5dLCBUb29sdGlwUG9wdXBDb21wb25lbnQpO1xuXG5jb25zdCDJtTAkMyA9IGJvZHlGYWN0b3J5O1xuLy8gQ29kZWx5emVyIDIuMC4wLWJldGEyIGRvZXNuJ3QgaGFuZGxlIGluaGVyaXRlZCBtZW1iZXJzXG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby1hY2Nlc3MtbWlzc2luZy1tZW1iZXIgKi9cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCA9IGNsYXNzIENyb3NzaGFpclRvb2x0aXBDb21wb25lbnQgZXh0ZW5kcyBCYXNlVG9vbHRpcCB7XG4gICAgY29uc3RydWN0b3IocG9wdXBTZXJ2aWNlLCBsb2NhbGl6YXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKHBvcHVwU2VydmljZSwgbG9jYWxpemF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuYW5pbWF0ZSA9IGZhbHNlO1xuICAgIH1cbiAgICBzaG93KGUpIHtcbiAgICAgICAgc3VwZXIuc2hvdyhlKTtcbiAgICAgICAgdGhpcy52YWx1ZSA9IGUudmFsdWU7XG4gICAgICAgIHRoaXMucG9wdXBSZWYucG9wdXAuY2hhbmdlRGV0ZWN0b3JSZWYuZGV0ZWN0Q2hhbmdlcygpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoJ2NvbnRlbnQnLCB7IHN0YXRpYzogdHJ1ZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgVGVtcGxhdGVSZWYpXG5dLCBDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0ZW1wbGF0ZVJlZlwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudC5wcm90b3R5cGUsIFwia2V5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwb3B1cFNldHRpbmdzXCIsIHZvaWQgMCk7XG5Dcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgcHJvdmlkZXJzOiBbUG9wdXBTZXJ2aWNlLCB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogUE9QVVBfQ09OVEFJTkVSLFxuICAgICAgICAgICAgICAgIHVzZUZhY3Rvcnk6IMm1MCQzXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1jcm9zc2hhaXItdG9vbHRpcCcsXG4gICAgICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxuZy10ZW1wbGF0ZSAjY29udGVudD5cbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJrLWNoYXJ0LXRvb2x0aXAgay1jaGFydC1jcm9zc2hhaXItdG9vbHRpcFwiIFtuZ1N0eWxlXT1cInN0eWxlXCI+XG4gICAgICAgICAgICAgICAge3sgdmFsdWUgfX1cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L25nLXRlbXBsYXRlPlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW1BvcHVwU2VydmljZSwgTG9jYWxpemF0aW9uU2VydmljZV0pXG5dLCBDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50KTtcblxuY29uc3QgQVhFUyA9IFtcImNhdGVnb3J5QXhpc1wiLCBcInZhbHVlQXhpc1wiLCBcInhBeGlzXCIsIFwieUF4aXNcIl07XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IENyb3NzaGFpclRvb2x0aXBzQ29udGFpbmVyQ29tcG9uZW50ID0gY2xhc3MgQ3Jvc3NoYWlyVG9vbHRpcHNDb250YWluZXJDb21wb25lbnQge1xuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy50b29sdGlwS2V5cyA9IFtdO1xuICAgICAgICB0aGlzLnRvb2x0aXBzTWFwID0ge307XG4gICAgfVxuICAgIHNob3coZSkge1xuICAgICAgICBjb25zdCB0b29sdGlwQ29tcG9uZW50cyA9IHRoaXMuY3Jvc3NhaGlyVG9vbHRpcENvbXBvbmVudHMudG9BcnJheSgpO1xuICAgICAgICBjb25zdCBheGlzTmFtZSA9IGUuYXhpc05hbWU7XG4gICAgICAgIGNvbnN0IGF4aXNJbmRleCA9IGUuYXhpc0luZGV4O1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0b29sdGlwQ29tcG9uZW50cy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBpZiAodG9vbHRpcENvbXBvbmVudHNbaWR4XS5rZXkgPT09IGF4aXNOYW1lICsgYXhpc0luZGV4KSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcENvbXBvbmVudHNbaWR4XS5zaG93KGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGhpZGUoKSB7XG4gICAgICAgIGNvbnN0IHRvb2x0aXBDb21wb25lbnRzID0gdGhpcy5jcm9zc2FoaXJUb29sdGlwQ29tcG9uZW50cy50b0FycmF5KCk7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHRvb2x0aXBDb21wb25lbnRzLmxlbmd0aDsgaWR4KyspIHtcbiAgICAgICAgICAgIHRvb2x0aXBDb21wb25lbnRzW2lkeF0uaGlkZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBhY3RpdmUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvb2x0aXBLZXlzLmxlbmd0aCA+IDA7XG4gICAgfVxuICAgIGNyZWF0ZUNyb3NzaGFpclRvb2x0aXBzKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbmV3TWFwID0gdGhpcy5tYXBUb29sdGlwcyhvcHRpb25zKTtcbiAgICAgICAgY29uc3QgbWFwID0gdGhpcy50b29sdGlwc01hcDtcbiAgICAgICAgZm9yIChsZXQga2V5IGluIG1hcCkge1xuICAgICAgICAgICAgaWYgKCFuZXdNYXBba2V5XSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlVG9vbHRpcChrZXkpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYXBba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gbmV3TWFwKSB7XG4gICAgICAgICAgICBpZiAoIW1hcFtrZXldKSB7XG4gICAgICAgICAgICAgICAgbWFwW2tleV0gPSBuZXdNYXBba2V5XTtcbiAgICAgICAgICAgICAgICB0aGlzLnRvb2x0aXBLZXlzLnB1c2goa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZW1vdmVUb29sdGlwKGtleSkge1xuICAgICAgICBjb25zdCBrZXlzID0gdGhpcy50b29sdGlwS2V5cztcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwga2V5cy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBpZiAoa2V5c1tpZHhdID09PSBrZXkpIHtcbiAgICAgICAgICAgICAgICBrZXlzLnNwbGljZShpZHgsIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIG1hcFRvb2x0aXBzKG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgbWFwID0ge307XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IEFYRVMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgY29uc3QgdG9vbHRpcHMgPSB0aGlzLmF4ZXNDcm9zc2hhaXJUb29sdGlwT3B0aW9ucyhvcHRpb25zLCBBWEVTW2lkeF0pO1xuICAgICAgICAgICAgZm9yIChsZXQgdG9vbHRpcElkeCA9IDA7IHRvb2x0aXBJZHggPCB0b29sdGlwcy5sZW5ndGg7IHRvb2x0aXBJZHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb2x0aXAgPSB0b29sdGlwc1t0b29sdGlwSWR4XTtcbiAgICAgICAgICAgICAgICBtYXBbdG9vbHRpcC5uYW1lICsgdG9vbHRpcC5pbmRleF0gPSB0b29sdGlwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtYXA7XG4gICAgfVxuICAgIGF4ZXNDcm9zc2hhaXJUb29sdGlwT3B0aW9ucyhvcHRpb25zLCBuYW1lKSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBpZiAob3B0aW9uc1tuYW1lXSkge1xuICAgICAgICAgICAgY29uc3QgYXhlcyA9IFtdLmNvbmNhdChvcHRpb25zW25hbWVdKTtcbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGF4ZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRvb2x0aXAgPSAoYXhlc1tpZHhdLmNyb3NzaGFpciB8fCB7fSkudG9vbHRpcDtcbiAgICAgICAgICAgICAgICBpZiAodG9vbHRpcCAmJiB0b29sdGlwLnZpc2libGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXg6IGlkeCxcbiAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IG5hbWVcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENyb3NzaGFpclRvb2x0aXBzQ29udGFpbmVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwb3B1cFNldHRpbmdzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGRyZW4oQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIENyb3NzaGFpclRvb2x0aXBzQ29udGFpbmVyQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjcm9zc2FoaXJUb29sdGlwQ29tcG9uZW50c1wiLCB2b2lkIDApO1xuQ3Jvc3NoYWlyVG9vbHRpcHNDb250YWluZXJDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LWNyb3NzaGFpci10b29sdGlwcy1jb250YWluZXInLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgICAgICA8a2VuZG8tY2hhcnQtY3Jvc3NoYWlyLXRvb2x0aXAgKm5nRm9yPVwibGV0IGtleSBvZiB0b29sdGlwS2V5c1wiIFtrZXldPVwia2V5XCIgW3BvcHVwU2V0dGluZ3NdPVwicG9wdXBTZXR0aW5nc1wiPlxuICAgICAgICA8L2tlbmRvLWNoYXJ0LWNyb3NzaGFpci10b29sdGlwPlxuICAgIGBcbiAgICB9KVxuXSwgQ3Jvc3NoYWlyVG9vbHRpcHNDb250YWluZXJDb21wb25lbnQpO1xuXG5jb25zdCBnZXRUb3VjaCA9IChkb21FdmVudCkgPT4ge1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHtcbiAgICAgICAgICAgIGxvY2F0aW9uOiBkb21FdmVudC5wYWdlWFxuICAgICAgICB9LFxuICAgICAgICB5OiB7XG4gICAgICAgICAgICBsb2NhdGlvbjogZG9tRXZlbnQucGFnZVlcbiAgICAgICAgfVxuICAgIH07XG59O1xuY29uc3QgZXZlbnRBcmdzID0gKGUsIHByZXZpb3VzQXJncykgPT4ge1xuICAgIGNvbnN0IHBvaW50ZXJzID0gZS5wb2ludGVycztcbiAgICBjb25zdCBwb2ludGVyID0gcG9pbnRlcnNbMF07XG4gICAgY29uc3QgeExvY2F0aW9uID0gcG9pbnRlci5wYWdlWDtcbiAgICBjb25zdCB5TG9jYXRpb24gPSBwb2ludGVyLnBhZ2VZO1xuICAgIGxldCBkaXN0YW5jZSA9IDA7XG4gICAgaWYgKHBvaW50ZXJzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgY29uc3QgcG9pbnRlcjEgPSBwb2ludGVyc1swXTtcbiAgICAgICAgY29uc3QgcG9pbnRlcjIgPSBwb2ludGVyc1sxXTtcbiAgICAgICAgZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3cocG9pbnRlcjEucGFnZVggLSBwb2ludGVyMi5wYWdlWCwgMikgKyBNYXRoLnBvdyhwb2ludGVyMS5wYWdlWSAtIHBvaW50ZXIyLnBhZ2VZLCAyKSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGRpc3RhbmNlOiBkaXN0YW5jZSxcbiAgICAgICAgZXZlbnQ6IGUuc3JjRXZlbnQsXG4gICAgICAgIHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIH0sXG4gICAgICAgIHRhcmdldDogZS50YXJnZXQsXG4gICAgICAgIHRvdWNoZXM6IHBvaW50ZXJzLm1hcChnZXRUb3VjaCksXG4gICAgICAgIHR5cGU6IGUudHlwZSxcbiAgICAgICAgeDoge1xuICAgICAgICAgICAgZGVsdGE6IHByZXZpb3VzQXJncyA/IHhMb2NhdGlvbiAtIHByZXZpb3VzQXJncy54LmxvY2F0aW9uIDogMCxcbiAgICAgICAgICAgIGluaXRpYWxEZWx0YTogZS5kZWx0YVgsXG4gICAgICAgICAgICBsb2NhdGlvbjogeExvY2F0aW9uLFxuICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogeExvY2F0aW9uIC0gZS5kZWx0YVhcbiAgICAgICAgfSxcbiAgICAgICAgeToge1xuICAgICAgICAgICAgZGVsdGE6IHByZXZpb3VzQXJncyA/IHlMb2NhdGlvbiAtIHByZXZpb3VzQXJncy55LmxvY2F0aW9uIDogMCxcbiAgICAgICAgICAgIGluaXRpYWxEZWx0YTogZS5kZWx0YVksXG4gICAgICAgICAgICBsb2NhdGlvbjogeUxvY2F0aW9uLFxuICAgICAgICAgICAgc3RhcnRMb2NhdGlvbjogeUxvY2F0aW9uIC0gZS5kZWx0YVlcbiAgICAgICAgfVxuICAgIH07XG59O1xuZnVuY3Rpb24gc2hvdWxkQmluZEdyb3VwKGdyb3VwTmFtZXMsIGV2ZW50cykge1xuICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGdyb3VwTmFtZXMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICBpZiAoZXZlbnRzW2dyb3VwTmFtZXNbaWR4XV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmNvbnN0IGV2ZW50R3JvdXBzID0gW3tcbiAgICAgICAgZW5kOiAncGFuZW5kJyxcbiAgICAgICAgbW92ZTogJ3Bhbm1vdmUnLFxuICAgICAgICBzdGFydDogJ3BhbnN0YXJ0J1xuICAgIH0sIHtcbiAgICAgICAgZ2VzdHVyZWNoYW5nZTogJ3BpbmNobW92ZScsXG4gICAgICAgIGdlc3R1cmVlbmQ6ICdwaW5jaGVuZCcsXG4gICAgICAgIGdlc3R1cmVzdGFydDogJ3BpbmNoc3RhcnQnXG4gICAgfSwge1xuICAgICAgICBwcmVzczogJ3ByZXNzJ1xuICAgIH0sIHtcbiAgICAgICAgdGFwOiAndGFwJ1xuICAgIH1dO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIERvbUV2ZW50cyB7XG4gICAgY29uc3RydWN0b3IoaGFtbWVySW5zdGFuY2UsIGV2ZW50cykge1xuICAgICAgICB0aGlzLmhhbW1lckluc3RhbmNlID0gaGFtbWVySW5zdGFuY2U7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IHt9O1xuICAgICAgICB0aGlzLnRhcCA9IHRoaXMudGFwLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucHJlc3MgPSB0aGlzLnByZXNzLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGFuc3RhcnQgPSB0aGlzLnBhbnN0YXJ0LmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGFubW92ZSA9IHRoaXMucGFubW92ZS5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBhbmVuZCA9IHRoaXMucGFuZW5kLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGluY2hzdGFydCA9IHRoaXMucGluY2hzdGFydC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLnBpbmNobW92ZSA9IHRoaXMucGluY2htb3ZlLmJpbmQodGhpcyk7XG4gICAgICAgIHRoaXMucGluY2hlbmQgPSB0aGlzLnBpbmNoZW5kLmJpbmQodGhpcyk7XG4gICAgICAgIGlmIChldmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuYmluZChldmVudHMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRhcChlKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcigndGFwJywgZSk7XG4gICAgfVxuICAgIHByZXNzKGUpIHtcbiAgICAgICAgdGhpcy50cmlnZ2VyKCdwcmVzcycsIGUpO1xuICAgIH1cbiAgICBwYW5zdGFydChlKSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLnByZXZpb3VzO1xuICAgICAgICB0aGlzLnByZXZpb3VzID0gdGhpcy50cmlnZ2VyKCdzdGFydCcsIGUpO1xuICAgIH1cbiAgICBwYW5tb3ZlKGUpIHtcbiAgICAgICAgdGhpcy5wcmV2aW91cyA9IHRoaXMudHJpZ2dlcignbW92ZScsIGUpO1xuICAgIH1cbiAgICBwYW5lbmQoZSkge1xuICAgICAgICB0aGlzLnRyaWdnZXIoJ2VuZCcsIGUpO1xuICAgICAgICBkZWxldGUgdGhpcy5wcmV2aW91cztcbiAgICB9XG4gICAgcGluY2hzdGFydChlKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignZ2VzdHVyZXN0YXJ0JywgZSk7XG4gICAgfVxuICAgIHBpbmNobW92ZShlKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignZ2VzdHVyZWNoYW5nZScsIGUpO1xuICAgIH1cbiAgICBwaW5jaGVuZChlKSB7XG4gICAgICAgIHRoaXMudHJpZ2dlcignZ2VzdHVyZWVuZCcsIGUpO1xuICAgIH1cbiAgICB0cmlnZ2VyKG5hbWUsIGUpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IGV2ZW50QXJncyhlLCB0aGlzLnByZXZpb3VzKTtcbiAgICAgICAgaWYgKHRoaXMuZXZlbnRIYW5kbGVyc1tuYW1lXSkge1xuICAgICAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzW25hbWVdKGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgIH1cbiAgICBiaW5kKGV2ZW50cyA9IHt9KSB7XG4gICAgICAgIHRoaXMudW5iaW5kKCk7XG4gICAgICAgIHRoaXMuZXZlbnRIYW5kbGVycyA9IGV2ZW50cztcbiAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgZXZlbnRHcm91cHMubGVuZ3RoOyBpZHgrKykge1xuICAgICAgICAgICAgY29uc3QgZXZlbnRHcm91cCA9IGV2ZW50R3JvdXBzW2lkeF07XG4gICAgICAgICAgICBjb25zdCBncm91cE5hbWVzID0gT2JqZWN0LmtleXMoZXZlbnRHcm91cCk7XG4gICAgICAgICAgICBpZiAoc2hvdWxkQmluZEdyb3VwKGdyb3VwTmFtZXMsIGV2ZW50cykpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBuYW1lSWR4ID0gMDsgbmFtZUlkeCA8IGdyb3VwTmFtZXMubGVuZ3RoOyBuYW1lSWR4KyspIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGV2ZW50R3JvdXBbZ3JvdXBOYW1lc1tuYW1lSWR4XV07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuaGFtbWVySW5zdGFuY2Uub24obmFtZSwgdGhpc1tuYW1lXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHVuYmluZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuaGFtbWVySW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuaGFtbWVySW5zdGFuY2Uub2ZmKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5ldmVudEhhbmRsZXJzID0ge307XG4gICAgfVxuICAgIGRlc3Ryb3koKSB7XG4gICAgICAgIGlmICh0aGlzLmhhbW1lckluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmhhbW1lckluc3RhbmNlLmRlc3Ryb3koKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmhhbW1lckluc3RhbmNlO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50SGFuZGxlcnM7XG4gICAgfVxuICAgIHRvZ2dsZURyYWcoZW5hYmxlKSB7XG4gICAgICAgIHRoaXMudG9nZ2xlKCdwYW4nLCBlbmFibGUpO1xuICAgIH1cbiAgICB0b2dnbGVab29tKGVuYWJsZSkge1xuICAgICAgICB0aGlzLnRvZ2dsZSgncGluY2gnLCBlbmFibGUpO1xuICAgIH1cbiAgICB0b2dnbGUocmVjb2duaXplciwgZW5hYmxlKSB7XG4gICAgICAgIGlmICh0aGlzLmhhbW1lckluc3RhbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBpbnN0YW5jZVJlY29nbml6ZXIgPSB0aGlzLmhhbW1lckluc3RhbmNlLmdldChyZWNvZ25pemVyKTtcbiAgICAgICAgICAgIGluc3RhbmNlUmVjb2duaXplci5zZXQoe1xuICAgICAgICAgICAgICAgIGVuYWJsZTogZW5hYmxlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgTUlTU0lOR19IQU1NRVJfTUVTU0FHRSA9ICdIYW1tZXJqcyBpcyBub3QgbG9hZGVkLicgK1xuICAgICdTb2x1dGlvbjogaHR0cDovL3d3dy50ZWxlcmlrLmNvbS9rZW5kby1hbmd1bGFyLXVpL2NvbXBvbmVudHMvY2hhcnRzL3Ryb3VibGVzaG9vdGluZy8jdG9jLWhhbW1lcmpzLWlzLW5vdC1sb2FkZWQnO1xuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIERvbUV2ZW50c0J1aWxkZXIkMSB7XG4gICAgc3RhdGljIGNyZWF0ZShlbGVtZW50LCBldmVudHMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBjb25zdCBIQU1NRVIgPSB3aW5kb3cuSGFtbWVyO1xuICAgICAgICAgICAgaWYgKCFIQU1NRVIpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNEZXZNb2RlKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKE1JU1NJTkdfSEFNTUVSX01FU1NBR0UpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoYW1tZXJJbnN0YW5jZSA9IG5ldyBIQU1NRVIoZWxlbWVudCwge1xuICAgICAgICAgICAgICAgIHJlY29nbml6ZXJzOiBbXG4gICAgICAgICAgICAgICAgICAgIFtIQU1NRVIuVGFwXSxcbiAgICAgICAgICAgICAgICAgICAgW0hBTU1FUi5QYW5dLFxuICAgICAgICAgICAgICAgICAgICBbSEFNTUVSLlBpbmNoXSxcbiAgICAgICAgICAgICAgICAgICAgW0hBTU1FUi5QcmVzcywgeyB0aW1lOiAwIH1dXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERvbUV2ZW50cyhoYW1tZXJJbnN0YW5jZSwgZXZlbnRzKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuY29uc3QgZGF0ZUNhdGVnb3J5QXhpc0Zvcm1hdHMgPSBEYXRlQ2F0ZWdvcnlBeGlzLnByb3RvdHlwZS5vcHRpb25zLmxhYmVscy5kYXRlRm9ybWF0cztcbmNvbnN0IGRhdGVWYWx1ZUF4aXNGb3JtYXRzID0gRGF0ZVZhbHVlQXhpcy5wcm90b3R5cGUub3B0aW9ucy5sYWJlbHMuZGF0ZUZvcm1hdHM7XG5jb25zdCBkYXRlRm9ybWF0cyA9IHtcbiAgICBtaWxsaXNlY29uZHM6IFwiSEg6bW06c3MuU1NTXCIsXG4gICAgc2Vjb25kczogeyB0aW1lOiAnbWVkaXVtJyB9LFxuICAgIG1pbnV0ZXM6IHsgdGltZTogJ3Nob3J0JyB9LFxuICAgIGhvdXJzOiB7IHRpbWU6ICdzaG9ydCcgfSxcbiAgICBkYXlzOiB7IHNrZWxldG9uOiAnTWQnIH0sXG4gICAgd2Vla3M6IHsgc2tlbGV0b246ICdNZCcgfSxcbiAgICBtb250aHM6IHsgc2tlbGV0b246ICd5eU1NTScgfSxcbiAgICB5ZWFyczogeyBza2VsZXRvbjogJ3knIH1cbn07XG5PYmplY3QuYXNzaWduKGRhdGVDYXRlZ29yeUF4aXNGb3JtYXRzLCBkYXRlRm9ybWF0cyk7XG5PYmplY3QuYXNzaWduKGRhdGVWYWx1ZUF4aXNGb3JtYXRzLCBkYXRlRm9ybWF0cyk7XG5Eb21FdmVudHNCdWlsZGVyLnJlZ2lzdGVyKERvbUV2ZW50c0J1aWxkZXIkMSk7XG5cbmZ1bmN0aW9uIGhhc09ic2VydmVycyhlbWl0dGVyKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIub2JzZXJ2ZXJzLmxlbmd0aCA+IDA7XG59XG4vKipcbiAqIFRoZSByb290IENoYXJ0IGNvbXBvbmVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICB0ZW1wbGF0ZTogYFxuICogICAgIDxidXR0b24gKGNsaWNrKT1cInRvZ2dsZUxlZ2VuZCgpXCI+VG9nZ2xlIExlZ2VuZDwvYnV0dG9uPlxuICogICAgIDxidXR0b24gKGNsaWNrKT1cInRvZ2dsZVNlcmllcygpXCI+VG9nZ2xlIFNlcmllczwvYnV0dG9uPlxuICogICAgIDxrZW5kby1jaGFydD5cbiAqICAgICAgIDxrZW5kby1jaGFydC1sZWdlbmQgW3Zpc2libGVdPVwibGVnZW5kVmlzaWJsZVwiPlxuICogICAgICAgPC9rZW5kby1jaGFydC1sZWdlbmQ+XG4gKiAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzPlxuICogICAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0gKm5nSWY9XCJzZXJpZXNWaXNpYmxlXCIgbmFtZT1cIlNlcmllcyAjMVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZT1cImxpbmVcIiBbZGF0YV09XCJbMSwgMiwgM11cIj5cbiAqICAgICAgICAgPC9rZW5kby1jaGFydC1zZXJpZXMtaXRlbT5cbiAqICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzPlxuICogICAgIDwva2VuZG8tY2hhcnQ+XG4gKiAgIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICBwdWJsaWMgbGVnZW5kVmlzaWJsZTogYm9vbGVhbiA9IHRydWU7XG4gKiAgIHB1YmxpYyBzZXJpZXNWaXNpYmxlOiBib29sZWFuID0gdHJ1ZTtcbiAqXG4gKiAgIHB1YmxpYyB0b2dnbGVTZXJpZXMoKTogdm9pZCB7XG4gKiAgICAgdGhpcy5zZXJpZXNWaXNpYmxlID0gIXRoaXMuc2VyaWVzVmlzaWJsZTtcbiAqICAgfVxuICpcbiAqICAgcHVibGljIHRvZ2dsZUxlZ2VuZCgpOiB2b2lkIHtcbiAqICAgICB0aGlzLmxlZ2VuZFZpc2libGUgPSAhdGhpcy5sZWdlbmRWaXNpYmxlO1xuICogICB9XG4gKiB9XG4gKlxuICogYGBgXG4gKi9cbmxldCBDaGFydENvbXBvbmVudCA9IGNsYXNzIENoYXJ0Q29tcG9uZW50IGV4dGVuZHMgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCB0aGVtZVNlcnZpY2UsIGVsZW1lbnQsIGludGwsIGxvY2FsaXphdGlvblNlcnZpY2UsIG5nWm9uZSwgaW5zdGFuY2VFdmVudFNlcnZpY2UsIGNoYW5nZURldGVjdG9yLCByZW5kZXJlcikge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy50aGVtZVNlcnZpY2UgPSB0aGVtZVNlcnZpY2U7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuaW50bCA9IGludGw7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uU2VydmljZSA9IGxvY2FsaXphdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLmluc3RhbmNlRXZlbnRTZXJ2aWNlID0gaW5zdGFuY2VFdmVudFNlcnZpY2U7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IgPSBjaGFuZ2VEZXRlY3RvcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiBhIGxlZ2VuZCBpdGVtIGlzIGNsaWNrZWQgYmVmb3JlIHRoZSBzZWxlY3RlZCBzZXJpZXMgdmlzaWJpbGl0eSBpcyB0b2dnbGVkLlxuICAgICAgICAgKiBDYW4gYmUgcHJldmVudGVkLlxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5sZWdlbmRJdGVtQ2xpY2sgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMaW1pdHMgdGhlIGF1dG9tYXRpYyByZXNpemluZyBvZiB0aGUgQ2hhcnQuIFNldHMgdGhlIG1heGltdW0gbnVtYmVyIG9mIHRpbWVzIHBlciBzZWNvbmRcbiAgICAgICAgICogdGhhdCB0aGUgY29tcG9uZW50IHJlZHJhd3MgaXRzIGNvbnRlbnQgd2hlbiB0aGUgc2l6ZSBvZiBpdHMgY29udGFpbmVyIGNoYW5nZXMuXG4gICAgICAgICAqIERlZmF1bHRzIHRvIGAxMGAuIFRvIGRpc2FibGUgdGhlIGF1dG9tYXRpYyByZXNpemluZywgc2V0IGl0IHRvIGAwYC5cbiAgICAgICAgICpcbiAgICAgICAgICogQGV4YW1wbGVcbiAgICAgICAgICogYGBgdHNcbiAgICAgICAgICogX0BDb21wb25lbnQoe1xuICAgICAgICAgKiAgICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICAgICAgICAgKiAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgICogICAgICAgICA8a2VuZG8tY2hhcnQgW3Jlc2l6ZVJhdGVMaW1pdF09XCIyXCI+XG4gICAgICAgICAqIDwhLS0gICAgICAgICAgICAgICAgIF5eXl5eXl5eXl5eXl5eXl5eXl5eXl5cbiAgICAgICAgICogICAgICAgV2lsbCB1cGRhdGUgdGhlIHNpemUgb2YgdGhlIENoYXJ0IHVwIHRvIHR3byB0aW1lcyBhIHNlY29uZC5cbiAgICAgICAgICogICAgICAgUmVzaXplIHRoZSBQbHVua3IgcGFuZSBvciB3aW5kb3cgdG8gdHJ5IGl0IG91dC5cbiAgICAgICAgICogLS0+XG4gICAgICAgICAqICAgICAgICAgIDxrZW5kby1jaGFydC1zZXJpZXM+XG4gICAgICAgICAqICAgICAgICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcy1pdGVtIFtkYXRhXT1cInNlcmllc0RhdGFcIj5cbiAgICAgICAgICogICAgICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0+XG4gICAgICAgICAqICAgICAgICAgPC9rZW5kby1jaGFydC1zZXJpZXM+XG4gICAgICAgICAqICAgICAgIDwva2VuZG8tY2hhcnQ+XG4gICAgICAgICAqICAgYFxuICAgICAgICAgKiB9KVxuICAgICAgICAgKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAgICAgICAgICogICAgc2VyaWVzRGF0YTogbnVtYmVyW10gPSBbMSwgMiwgMywgNV07XG4gICAgICAgICAqIH1cbiAgICAgICAgICogYGBgXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnJlc2l6ZVJhdGVMaW1pdCA9IDEwO1xuICAgICAgICB0aGlzLnRoZW1lID0gbnVsbDtcbiAgICAgICAgdGhpcy5zdXBwcmVzc1RyYW5zaXRpb25zID0gZmFsc2U7XG4gICAgICAgIHRoaXMucnRsID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaG9zdENsYXNzZXMgPSBbJ2stY2hhcnQnLCAnay13aWRnZXQnXTtcbiAgICAgICAgdmFsaWRhdGVQYWNrYWdlKHBhY2thZ2VNZXRhZGF0YSk7XG4gICAgICAgIHRoaXMudGhlbWVTZXJ2aWNlLmxvYWRUaGVtZSgpO1xuICAgICAgICB0aGlzLnJlZnJlc2hXYWl0KCk7XG4gICAgfVxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICBpZiAodGhpcy5lbGVtZW50KSB7XG4gICAgICAgICAgICB0aGlzLmhvc3RDbGFzc2VzLmZvckVhY2gobmFtZSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5hZGRDbGFzcyh0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudCwgbmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyZXIuc2V0U3R5bGUodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdwb3NpdGlvbicsICdyZWxhdGl2ZScpO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2FuUmVuZGVyKSB7XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhcnRNb3VzZWxlYXZlID0gdGhpcy5yZW5kZXJlci5saXN0ZW4odGhpcy5zdXJmYWNlRWxlbWVudC5uYXRpdmVFbGVtZW50LCAnbW91c2VsZWF2ZScsIHRoaXMuY2hhcnRNb3VzZWxlYXZlLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIHRoaXMuZG9tU3Vic2NyaXB0aW9ucyA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2hhcnRNb3VzZWxlYXZlKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0RGlyZWN0aW9uKCk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucyA9IHRoaXMuaW50bC5jaGFuZ2VzLnN1YnNjcmliZSh0aGlzLmludGxDaGFuZ2UuYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5hZGQodGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlLmNoYW5nZXMuc3Vic2NyaWJlKHRoaXMucnRsQ2hhbmdlLmJpbmQodGhpcykpKTtcbiAgICB9XG4gICAgbmdBZnRlclZpZXdDaGVja2VkKCkge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSAmJiB0aGlzLmF1dG9SZXNpemUpIHtcbiAgICAgICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlc2l6ZVRpbWVvdXQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgY29uc3Qgc3RvcmUgPSB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlLnN0b3JlO1xuICAgICAgICBjb3B5Q2hhbmdlcyhjaGFuZ2VzLCBzdG9yZSk7XG4gICAgICAgIHN0b3JlLnBvcHVwU2V0dGluZ3MgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlLnB1c2goc3RvcmUpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHRoZSBjb21wb25lbnQgZmllbGRzIHdpdGggdGhlIHNwZWNpZmllZCB2YWx1ZXMgYW5kIHJlZnJlc2hlcyB0aGUgQ2hhcnQuXG4gICAgICpcbiAgICAgKiBVc2UgdGhpcyBtZXRob2Qgd2hlbiB0aGUgY29uZmlndXJhdGlvbiB2YWx1ZXMgY2Fubm90IGJlIHNldCB0aHJvdWdoIHRoZSB0ZW1wbGF0ZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBgdHMtbm8tcnVuXG4gICAgICogY2hhcnQubm90aWZ5Q2hhbmdlcyh7IHRpdGxlOiB7IHRleHQ6ICdOZXcgVGl0bGUnIH0gfSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2hhbmdlcyBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgdXBkYXRlZCBpbnB1dCBmaWVsZHMuXG4gICAgICovXG4gICAgbm90aWZ5Q2hhbmdlcyhjaGFuZ2VzKSB7XG4gICAgICAgIHRoaXMubmdPbkNoYW5nZXModG9TaW1wbGVDaGFuZ2VzKGNoYW5nZXMpKTtcbiAgICB9XG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKHRoaXMuc3Vic2NyaXB0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmRvbVN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuZG9tU3Vic2NyaXB0aW9ucygpO1xuICAgICAgICAgICAgdGhpcy5kb21TdWJzY3JpcHRpb25zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5kZXN0cm95KCk7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMudW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZXNpemVUaW1lb3V0KTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVkcmF3VGltZW91dCk7XG4gICAgfVxuICAgIGNyZWF0ZUluc3RhbmNlKGVsZW1lbnQsIG9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2UgPSBuZXcgQ2hhcnQoZWxlbWVudCwgdGhpcy5vcHRpb25zLCB0aGlzLnRoZW1lLCB7XG4gICAgICAgICAgICBpbnRsU2VydmljZTogdGhpcy5pbnRsLFxuICAgICAgICAgICAgb2JzZXJ2ZXI6IG9ic2VydmVyLFxuICAgICAgICAgICAgcnRsOiB0aGlzLnJ0bCxcbiAgICAgICAgICAgIHNlbmRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3J0cyB0aGUgQ2hhcnQgYXMgYW4gaW1hZ2UuIFRoZSBleHBvcnQgb3BlcmF0aW9uIGlzIGFzeW5jaHJvbm91cyBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ltYWdlRXhwb3J0T3B0aW9uc30gb3B0aW9ucyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZXhwb3J0ZWQgaW1hZ2UuXG4gICAgICogQHJldHVybnMge1Byb21pc2U8c3RyaW5nPn0gLSBBIHByb21pc2UgdGhhdCB3aWxsIGJlIHJlc29sdmVkIHdpdGggYSBQTkcgaW1hZ2UgZW5jb2RlZCBhcyBhIERhdGEgVVJJLlxuICAgICAqL1xuICAgIGV4cG9ydEltYWdlKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0SW1hZ2UodGhpcy5leHBvcnRWaXN1YWwob3B0aW9ucyksIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFeHBvcnRzIHRoZSBDaGFydCBhcyBhbiBTVkcgZG9jdW1lbnQuIFRoZSBleHBvcnQgb3BlcmF0aW9uIGlzIGFzeW5jaHJvbm91cyBhbmQgcmV0dXJucyBhIHByb21pc2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZXhwb3J0ZWQgZmlsZS5cbiAgICAgKiBAcmV0dXJucyAtIEEgcHJvbWlzZSB0aGF0IHdpbGwgYmUgcmVzb2x2ZWQgd2l0aCBhbiBTVkcgZG9jdW1lbnQgdGhhdCBpcyBlbmNvZGVkIGFzIGEgRGF0YSBVUkkuXG4gICAgICovXG4gICAgZXhwb3J0U1ZHKG9wdGlvbnMgPSB7fSkge1xuICAgICAgICByZXR1cm4gZXhwb3J0U1ZHKHRoaXMuZXhwb3J0VmlzdWFsKG9wdGlvbnMpLCBvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRXhwb3J0cyB0aGUgQ2hhcnQgYXMgYSBEcmF3aW5nIGBTY2VuZWAuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgZXhwb3J0IG9wZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyAtIFRoZSByb290IEdyb3VwIG9mIHRoZSBzY2VuZS5cbiAgICAgKi9cbiAgICBleHBvcnRWaXN1YWwob3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlLmV4cG9ydFZpc3VhbChvcHRpb25zKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgYXhpcyB3aXRoIHRoZSBzcGVjaWZpZWQgbmFtZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gVGhlIGF4aXMgbmFtZS5cbiAgICAgKiBAcmV0dXJucyB7Q2hhcnRBeGlzfSAtIFRoZSBheGlzIHdpdGggYSBjb3JyZXNwb25kaW5nIG5hbWUuXG4gICAgICovXG4gICAgZmluZEF4aXNCeU5hbWUobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2UuZmluZEF4aXNCeU5hbWUobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGFuZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4IC0gVGhlIHBhbmUgaW5kZXguXG4gICAgICogQHJldHVybnMge0NoYXJ0UGFuZX0gLSBUaGUgcGFuZSBhdCB0aGUgc3BlY2lmaWVkIGluZGV4LlxuICAgICAqL1xuICAgIGZpbmRQYW5lQnlJbmRleChpbmRleCkge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2UuZmluZFBhbmVCeUluZGV4KGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSBwYW5lIHdpdGggdGhlIHNwZWNpZmllZCBuYW1lLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgcGFuZS5cbiAgICAgKiBAcmV0dXJucyB7Q2hhcnRQYW5lfSAtIFRoZSBwYW5lIHdpdGggdGhlIHByb3ZpZGVkIG5hbWUuXG4gICAgICovXG4gICAgZmluZFBhbmVCeU5hbWUobmFtZSkge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5zdGFuY2UuZmluZFBhbmVCeU5hbWUobmFtZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyB0aGUgcGxvdCBhcmVhIG9mIHRoZSBDaGFydC5cbiAgICAgKiBAcmV0dXJucyB7Q2hhcnRQbG90QXJlYX0gLSBUaGUgcGxvdCBhcmVhIG9mIHRoZSBDaGFydC5cbiAgICAgKi9cbiAgICBnZXRQbG90QXJlYSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmluc3RhbmNlLnBsb3RBcmVhKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogSGlnaGxpZ2h0cyB0aGUgc2VyaWVzIHBvaW50cyBvciB0aGUgc2VnbWVudHMgb2YgYSBQaWUsIERvbnV0LCBvciBGdW5uZWwgY2hhcnRzLlxuICAgICAqXG4gICAgICogU2VlIFtTZXJpZXMgSGlnaGxpZ2h0XSh7JSBzbHVnIHNlcmllc2hpZ2hsaWdodF9jaGFydF9jaGFydHMgJX0pIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICpcbiAgICAgKiBJbiB0aGUgZm9sbG93aW5nIGV4YW1wbGUsIHRoZSBjYWxsYmFjayBpcyBldmFsdWF0ZWQgZm9yIGVhY2ggZGF0YSBwb2ludC5cbiAgICAgKiBJZiB0aGUgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAsIHRoZSBwb2ludCBpcyBoaWdobGlnaHRlZC5cbiAgICAgKlxuICAgICAqIHslIG1ldGEgaGVpZ2h0OjUwMCAlfVxuICAgICAqIHslIGVtYmVkX2ZpbGUgZWxlbWVudHMvaGlnaGxpZ2h0L2FwaS9hcHAuY29tcG9uZW50LnRzIHByZXZpZXcgJX1cbiAgICAgKiB7JSBlbWJlZF9maWxlIHNoYXJlZC9hcHAubW9kdWxlLnRzIGhpZGRlbiAlfVxuICAgICAqIHslIGVtYmVkX2ZpbGUgc2hhcmVkL21haW4udHMgaGlkZGVuICV9XG4gICAgICogeyUgZW5kbWV0YSAlfVxuICAgICAqXG4gICAgICogQHBhcmFtIHNob3cgLSBBIEJvb2xlYW4gdmFsdWUgdGhhdCBpbmRpY2F0ZXMgd2hldGhlciB0aGUgaGlnaGxpZ2h0IGlzIHNob3duIG9yIGhpZGRlbi5cbiAgICAgKiBAcGFyYW0gZmlsdGVyIC0gQSBzdHJpbmcgdGhhdCByZXByZXNlbnRzIHRoZSBzZXJpZXMgb3IgY2F0ZWdvcnkgbmFtZSwgYW4gb2JqZWN0IHdpdGggdGhlIHNlcmllcyBhbmQgY2F0ZWdvcnkgbmFtZSwgb3IgYSBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBwb2ludC4gVGhlIGZ1bmN0aW9uIHNob3VsZCByZXR1cm4gYHRydWVgIGZvciB0aGUgcG9pbnRzIGZvciB3aGljaCB0aGUgaGlnaGxpZ2h0IGlzIHRvZ2dsZWQuXG4gICAgICovXG4gICAgdG9nZ2xlSGlnaGxpZ2h0KHNob3csIGZpbHRlcikge1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS50b2dnbGVIaWdobGlnaHQoc2hvdywgZmlsdGVyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBIaWRlcyB0aGUgdG9vbHRpcCBvZiB0aGUgQ2hhcnQuXG4gICAgICovXG4gICAgaGlkZVRvb2x0aXAoKSB7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLmhpZGVUb29sdGlwKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU2hvd3MgdGhlIENoYXJ0IHRvb2x0aXAgb2YgYSBzcGVjaWZpYyBwb2ludCBvciB0aGUgc2hhcmVkIHRvb2x0aXAgb2YgYSBzcGVjaWZpYyBjYXRlZ29yeS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBmaWx0ZXIgLSBUaGUgY2F0ZWdvcnkgZm9yIGEgc2hhcmVkIHRvb2x0aXAgb3IgYSBmdW5jdGlvbiB3aGljaCB3aWxsIGJlIGNhbGxlZCBmb3IgZWFjaCBwb2ludCB1bnRpbCB0aGUgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAuXG4gICAgICovXG4gICAgc2hvd1Rvb2x0aXAoZmlsdGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNob3dUb29sdGlwKGZpbHRlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW5pdCgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNhblJlbmRlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLnN1cmZhY2VFbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlT2JzZXJ2ZXIgPSBuZXcgQ2hhcnRJbnN0YW5jZU9ic2VydmVyKHRoaXMpO1xuICAgICAgICB0aGlzLmNyZWF0ZUluc3RhbmNlKGVsZW1lbnQsIGluc3RhbmNlT2JzZXJ2ZXIpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEZXRlY3RzIHRoZSBzaXplIG9mIHRoZSBjb250YWluZXIgYW5kIHJlZHJhd3MgdGhlIENoYXJ0LlxuICAgICAqIFJlc2l6aW5nIGlzIGF1dG9tYXRpYyB1bmxlc3MgeW91IHNldCB0aGUgYHJlc2l6ZVJhdGVMaW1pdGAgb3B0aW9uIHRvIGAwYC5cbiAgICAgKi9cbiAgICByZXNpemUoKSB7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmluc3RhbmNlLnJlc2l6ZSgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBoaWRkZW5cbiAgICAgKi9cbiAgICBvblJlc2l6ZShfZXZlbnQpIHtcbiAgICAgICAgaWYgKHRoaXMuYXV0b1Jlc2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5yZXNpemUoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBvbkxlZ2VuZEl0ZW1DbGljayhlKSB7XG4gICAgICAgIHRoaXMucnVuKCgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3MgPSBuZXcgTGVnZW5kSXRlbUNsaWNrRXZlbnQoZSwgdGhpcyk7XG4gICAgICAgICAgICB0aGlzLmxlZ2VuZEl0ZW1DbGljay5lbWl0KGFyZ3MpO1xuICAgICAgICAgICAgaWYgKCFhcmdzLmlzRGVmYXVsdFByZXZlbnRlZCgpKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgc2VyaWVzID0gdGhpcy5zZXJpZXNDb21wb25lbnRzLnRvQXJyYXkoKVtlLnNlcmllcy5pbmRleF07XG4gICAgICAgICAgICAgICAgaWYgKCFzZXJpZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZS5wb2ludEluZGV4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VyaWVzLnRvZ2dsZVZpc2liaWxpdHkoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHNlcmllcy50b2dnbGVQb2ludFZpc2liaWxpdHkoZS5wb2ludEluZGV4KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdXBwcmVzc1RyYW5zaXRpb25zID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgaGFzT2JzZXJ2ZXJzKHRoaXMubGVnZW5kSXRlbUNsaWNrKSwgdGhpcy5zZXJpZXNDb21wb25lbnRzLmxlbmd0aCA+IDApO1xuICAgIH1cbiAgICBvbkluaXQoZSkge1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gZS5zZW5kZXI7XG4gICAgfVxuICAgIG9uUmVuZGVyKGUpIHtcbiAgICAgICAgY29uc3QgZG9udXRDZW50ZXJTdHlsZSA9IHRoaXMuZ2V0RG9udXRDZW50ZXJTdHlsZSgpO1xuICAgICAgICB0aGlzLnJ1bigoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gbmV3IFJlbmRlckV2ZW50KGUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5zdXJmYWNlID0gZS5zZW5kZXIuc3VyZmFjZTtcbiAgICAgICAgICAgIHRoaXMucmVuZGVyLmVtaXQoYXJncyk7XG4gICAgICAgICAgICB0aGlzLmRvbnV0Q2VudGVyU3R5bGUgPSBkb251dENlbnRlclN0eWxlO1xuICAgICAgICB9LCBoYXNPYnNlcnZlcnModGhpcy5yZW5kZXIpLCB0aGlzLmRvbnV0Q2VudGVyU3R5bGUgIT09IGRvbnV0Q2VudGVyU3R5bGUpO1xuICAgIH1cbiAgICBvblNob3dUb29sdGlwKGUpIHtcbiAgICAgICAgdGhpcy5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFlLmNyb3NzaGFpcikge1xuICAgICAgICAgICAgICAgIHRoaXMudG9vbHRpcEluc3RhbmNlLnNob3coZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNyb3NzYWhpclRvb2x0aXBzLnNob3coZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sICFlLmNyb3NzaGFpciwgdHJ1ZSk7XG4gICAgfVxuICAgIG9uSGlkZVRvb2x0aXAoZSkge1xuICAgICAgICBpZiAoIWUuY3Jvc3NoYWlyKSB7XG4gICAgICAgICAgICBpZiAodGhpcy50b29sdGlwSW5zdGFuY2UuYWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50b29sdGlwSW5zdGFuY2UuaGlkZSgpO1xuICAgICAgICAgICAgICAgIHRoaXMuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY3Jvc3NhaGlyVG9vbHRpcHMuYWN0aXZlKSB7XG4gICAgICAgICAgICB0aGlzLmNyb3NzYWhpclRvb2x0aXBzLmhpZGUoKTtcbiAgICAgICAgICAgIHRoaXMuZGV0ZWN0Q2hhbmdlcygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRyaWdnZXIobmFtZSwgZSkge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3Jlc2l6ZScpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbWl0dGVyID0gdGhpcy5hY3RpdmVFbWl0dGVyKG5hbWUpO1xuICAgICAgICBpZiAoZW1pdHRlcikge1xuICAgICAgICAgICAgY29uc3QgYXJncyA9IHRoaXMuaW5zdGFuY2VFdmVudFNlcnZpY2UuY3JlYXRlKG5hbWUsIGUsIHRoaXMpO1xuICAgICAgICAgICAgdGhpcy5ydW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgIGVtaXR0ZXIuZW1pdChhcmdzKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGFyZ3MuaXNEZWZhdWx0UHJldmVudGVkICYmIGFyZ3MuaXNEZWZhdWx0UHJldmVudGVkKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVxdWlyZXNIYW5kbGVycyhuYW1lcykge1xuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBuYW1lcy5sZW5ndGg7IGlkeCsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hY3RpdmVFbWl0dGVyKG5hbWVzW2lkeF0pKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZWZyZXNoKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5yZWRyYXdUaW1lb3V0KTtcbiAgICAgICAgdGhpcy51cGRhdGVEaXJlY3Rpb24oKTtcbiAgICAgICAgdGhpcy5jcm9zc2FoaXJUb29sdGlwcy5jcmVhdGVDcm9zc2hhaXJUb29sdGlwcyh0aGlzLm9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNldENoYXJ0QXJlYVNpemUoKTtcbiAgICAgICAgaWYgKCF0aGlzLmluc3RhbmNlKSB7XG4gICAgICAgICAgICB0aGlzLmluaXQoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2l0aW9ucyA9IHRoaXMub3B0aW9ucy50cmFuc2l0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuc3VwcHJlc3NUcmFuc2l0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLnRyYW5zaXRpb25zID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy51cGRhdGVPcHRpb25zKCk7XG4gICAgICAgIGlmICh0aGlzLnN1cHByZXNzVHJhbnNpdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy50cmFuc2l0aW9ucyA9IHRyYW5zaXRpb25zO1xuICAgICAgICAgICAgdGhpcy5zdXBwcmVzc1RyYW5zaXRpb25zID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0Q2hhcnRBcmVhU2l6ZSgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmVsZW1lbnQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgICAgIGNvbnN0IGNoYXJ0QXJlYSA9IHRoaXMub3B0aW9ucy5jaGFydEFyZWEgfHwge307XG4gICAgICAgIGlmIChjaGFydEFyZWEud2lkdGgpIHtcbiAgICAgICAgICAgIGVsZW1lbnQuc3R5bGUud2lkdGggPSBgJHtjaGFydEFyZWEud2lkdGh9cHhgO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaGFydEFyZWEuaGVpZ2h0KSB7XG4gICAgICAgICAgICBlbGVtZW50LnN0eWxlLmhlaWdodCA9IGAke2NoYXJ0QXJlYS5oZWlnaHR9cHhgO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZU9wdGlvbnMoKSB7XG4gICAgICAgIHRoaXMuaW5zdGFuY2Uuc2V0T3B0aW9ucyh0aGlzLm9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBAaGlkZGVuXG4gICAgICovXG4gICAgdG9vbHRpcE1vdXNlbGVhdmUoZSkge1xuICAgICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0gZS5yZWxhdGVkVGFyZ2V0O1xuICAgICAgICBjb25zdCBjaGFydEVsZW1lbnQgPSB0aGlzLmVsZW1lbnQubmF0aXZlRWxlbWVudDtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UgJiYgKCFyZWxhdGVkVGFyZ2V0IHx8ICFoYXNQYXJlbnQocmVsYXRlZFRhcmdldCwgY2hhcnRFbGVtZW50KSkpIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuaGlkZUVsZW1lbnRzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQGhpZGRlblxuICAgICAqL1xuICAgIGNoYXJ0TW91c2VsZWF2ZShlKSB7XG4gICAgICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSBlLnJlbGF0ZWRUYXJnZXQ7XG4gICAgICAgIGNvbnN0IGNoYXJ0RWxlbWVudCA9IHRoaXMuZWxlbWVudC5uYXRpdmVFbGVtZW50O1xuICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSAmJiAoIXJlbGF0ZWRUYXJnZXQgfHwgISh0aGlzLnRvb2x0aXBJbnN0YW5jZS5jb250YWluc0VsZW1lbnQocmVsYXRlZFRhcmdldCkgfHwgaGFzUGFyZW50KHJlbGF0ZWRUYXJnZXQsIGNoYXJ0RWxlbWVudCkpKSAmJlxuICAgICAgICAgICAgIXRoaXMuaW5zdGFuY2UuaGFuZGxpbmdUYXApIHtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuaGlkZUVsZW1lbnRzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IGNhblJlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIGlzRG9jdW1lbnRBdmFpbGFibGUoKSAmJiBCb29sZWFuKHRoaXMuc3VyZmFjZUVsZW1lbnQpO1xuICAgIH1cbiAgICBnZXQgYXV0b1Jlc2l6ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVzaXplUmF0ZUxpbWl0ID4gMDtcbiAgICB9XG4gICAgYWN0aXZlRW1pdHRlcihuYW1lKSB7XG4gICAgICAgIGNvbnN0IGVtaXR0ZXIgPSB0aGlzW25hbWVdO1xuICAgICAgICBpZiAoZW1pdHRlciAmJiBlbWl0dGVyLmVtaXQgJiYgaGFzT2JzZXJ2ZXJzKGVtaXR0ZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gZW1pdHRlcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXREb251dENlbnRlclN0eWxlKCkge1xuICAgICAgICBpZiAoIXRoaXMuaW5zdGFuY2UgfHwgIXRoaXMub3B0aW9ucyB8fCAhdGhpcy5vcHRpb25zLnNlcmllcykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpcnN0U2VyaWVzID0gdGhpcy5vcHRpb25zLnNlcmllc1swXTtcbiAgICAgICAgY29uc3QgY2hhcnRzID0gdGhpcy5pbnN0YW5jZS5fcGxvdEFyZWEuY2hhcnRzO1xuICAgICAgICBpZiAoIWZpcnN0U2VyaWVzIHx8IGZpcnN0U2VyaWVzLnR5cGUgIT09ICdkb251dCcgfHwgIWNoYXJ0cyB8fCBjaGFydHNbMF0ucG9pbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpcnN0UG9pbnQgPSBjaGFydHNbMF0ucG9pbnRzWzBdO1xuICAgICAgICBjb25zdCBjZW50ZXIgPSBmaXJzdFBvaW50LmJveC5jZW50ZXIoKTtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gZmlyc3RQb2ludC5zZWN0b3IuaW5uZXJSYWRpdXM7XG4gICAgICAgIGNvbnN0IHRvcCA9IGNlbnRlci55IC0gcmFkaXVzO1xuICAgICAgICBjb25zdCBsZWZ0ID0gY2VudGVyLnggLSByYWRpdXM7XG4gICAgICAgIGNvbnN0IHNpemUgPSByYWRpdXMgKiAyO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaGVpZ2h0OiBzaXplICsgJ3B4JyxcbiAgICAgICAgICAgIGxlZnQ6IGxlZnQgKyAncHgnLFxuICAgICAgICAgICAgdG9wOiB0b3AgKyAncHgnLFxuICAgICAgICAgICAgd2lkdGg6IHNpemUgKyAncHgnXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJlZnJlc2hXYWl0KCkge1xuICAgICAgICB0aGlzLm5nWm9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IGNvbWJpbmVMYXRlc3QodGhpcy5jb25maWd1cmF0aW9uU2VydmljZS5vbkNoYW5nZSQsIHRoaXMudGhlbWVTZXJ2aWNlLm9uQ2hhbmdlJCkucGlwZSh0YXAoKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHJlc3VsdFswXTtcbiAgICAgICAgICAgICAgICB0aGlzLnRoZW1lID0gcmVzdWx0WzFdO1xuICAgICAgICAgICAgfSksIGF1ZGl0VGltZShUSFJPVFRMRV9NUykpXG4gICAgICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWZyZXNoKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJ1bihjYWxsYmFjaywgaW5ab25lID0gdHJ1ZSwgZGV0ZWN0Q2hhbmdlcykge1xuICAgICAgICBpZiAoaW5ab25lKSB7XG4gICAgICAgICAgICBpZiAoZGV0ZWN0Q2hhbmdlcykge1xuICAgICAgICAgICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IubWFya0ZvckNoZWNrKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5nWm9uZS5ydW4oY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIGlmIChkZXRlY3RDaGFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGV0ZWN0Q2hhbmdlcygpIHtcbiAgICAgICAgaWYgKCF0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3Rvci5kZXRlY3RDaGFuZ2VzKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaW50bENoYW5nZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgIHRoaXMuZGVmZXJyZWRSZWRyYXcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBydGxDaGFuZ2UoKSB7XG4gICAgICAgIGlmICh0aGlzLmluc3RhbmNlICYmIHRoaXMucnRsICE9PSB0aGlzLmlzUlRMKSB7XG4gICAgICAgICAgICB0aGlzLmRlZmVycmVkUmVkcmF3KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGVmZXJyZWRSZWRyYXcoKSB7XG4gICAgICAgIHRoaXMubmdab25lLnJ1bk91dHNpZGVBbmd1bGFyKCgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlZHJhd1RpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5yZWRyYXdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVEaXJlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLm5vVHJhbnNpdGlvbnNSZWRyYXcoKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlRGlyZWN0aW9uKCkge1xuICAgICAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5pc1JUTDtcbiAgICAgICAgaWYgKHRoaXMucnRsICE9PSBjdXJyZW50KSB7XG4gICAgICAgICAgICB0aGlzLnNldERpcmVjdGlvbigpO1xuICAgICAgICAgICAgaWYgKHRoaXMuaW5zdGFuY2UpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLnNldERpcmVjdGlvbihjdXJyZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXREaXJlY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucnRsID0gdGhpcy5pc1JUTDtcbiAgICAgICAgaWYgKHRoaXMuZWxlbWVudCkge1xuICAgICAgICAgICAgdGhpcy5yZW5kZXJlci5zZXRBdHRyaWJ1dGUodGhpcy5lbGVtZW50Lm5hdGl2ZUVsZW1lbnQsICdkaXInLCB0aGlzLnJ0bCA/ICdydGwnIDogJ2x0cicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBpc1JUTCgpIHtcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4odGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlLnJ0bCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIE91dHB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBFdmVudEVtaXR0ZXIpXG5dLCBDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwibGVnZW5kSXRlbUNsaWNrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwicmVzaXplUmF0ZUxpbWl0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwicG9wdXBTZXR0aW5nc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkcmVuKFNlcmllc0l0ZW1Db21wb25lbnQsIHsgZGVzY2VuZGFudHM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIENoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJzZXJpZXNDb21wb25lbnRzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoRG9udXRDZW50ZXJUZW1wbGF0ZURpcmVjdGl2ZSwgeyBzdGF0aWM6IGZhbHNlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBEb251dENlbnRlclRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcImRvbnV0Q2VudGVyVGVtcGxhdGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIFZpZXdDaGlsZChUb29sdGlwUG9wdXBDb21wb25lbnQsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBUb29sdGlwUG9wdXBDb21wb25lbnQpXG5dLCBDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9vbHRpcEluc3RhbmNlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBWaWV3Q2hpbGQoQ3Jvc3NoYWlyVG9vbHRpcHNDb250YWluZXJDb21wb25lbnQsIHsgc3RhdGljOiB0cnVlIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBDcm9zc2hhaXJUb29sdGlwc0NvbnRhaW5lckNvbXBvbmVudClcbl0sIENoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjcm9zc2FoaXJUb29sdGlwc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgVmlld0NoaWxkKCdzdXJmYWNlJywgeyBzdGF0aWM6IHRydWUgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEVsZW1lbnRSZWYpXG5dLCBDaGFydENvbXBvbmVudC5wcm90b3R5cGUsIFwic3VyZmFjZUVsZW1lbnRcIiwgdm9pZCAwKTtcbkNoYXJ0Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIGV4cG9ydEFzOiAna2VuZG9DaGFydCcsXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgICAgICAgICBUb29sdGlwVGVtcGxhdGVTZXJ2aWNlLFxuICAgICAgICAgICAgSW5zdGFuY2VFdmVudFNlcnZpY2UsXG4gICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEwxME5fUFJFRklYLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiAna2VuZG8uY2hhcnQnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQnLFxuICAgICAgICB0ZW1wbGF0ZTogYFxuICAgIDxkaXYgI3N1cmZhY2UgY2xhc3M9XCJrLWNoYXJ0LXN1cmZhY2VcIj48L2Rpdj5cbiAgICA8a2VuZG8tY2hhcnQtY3Jvc3NoYWlyLXRvb2x0aXBzLWNvbnRhaW5lciBbcG9wdXBTZXR0aW5nc109XCJwb3B1cFNldHRpbmdzXCI+XG4gICAgPC9rZW5kby1jaGFydC1jcm9zc2hhaXItdG9vbHRpcHMtY29udGFpbmVyPlxuICAgIDxrZW5kby1jaGFydC10b29sdGlwLXBvcHVwIChsZWF2ZSk9XCJ0b29sdGlwTW91c2VsZWF2ZSgkZXZlbnQpXCIgW3BvcHVwU2V0dGluZ3NdPVwicG9wdXBTZXR0aW5nc1wiPlxuICAgIDwva2VuZG8tY2hhcnQtdG9vbHRpcC1wb3B1cD5cbiAgICA8a2VuZG8tcmVzaXplLXNlbnNvciAocmVzaXplKT1cIm9uUmVzaXplKCRldmVudClcIiBbcmF0ZUxpbWl0XT1cInJlc2l6ZVJhdGVMaW1pdFwiPjwva2VuZG8tcmVzaXplLXNlbnNvcj5cbiAgICA8ZGl2IGNsYXNzPVwiay1jaGFydC1kb251dC1jZW50ZXJcIiBbbmdTdHlsZV09XCJkb251dENlbnRlclN0eWxlXCIgKm5nSWY9XCJkb251dENlbnRlclN0eWxlICYmIGRvbnV0Q2VudGVyVGVtcGxhdGVcIj5cbiAgICAgIDxuZy10ZW1wbGF0ZSBbbmdUZW1wbGF0ZU91dGxldF09XCJkb251dENlbnRlclRlbXBsYXRlLnRlbXBsYXRlUmVmXCI+PC9uZy10ZW1wbGF0ZT5cbiAgICA8L2Rpdj5cbiAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgICAgIFRoZW1lU2VydmljZSxcbiAgICAgICAgRWxlbWVudFJlZixcbiAgICAgICAgSW50bFNlcnZpY2UsXG4gICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgIE5nWm9uZSxcbiAgICAgICAgSW5zdGFuY2VFdmVudFNlcnZpY2UsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBSZW5kZXJlcjJdKVxuXSwgQ2hhcnRDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQXhpc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdheGlzRGVmYXVsdHMnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBBeGlzRGVmYXVsdHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEF4aXNEZWZhdWx0c0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEF4aXNEZWZhdWx0c0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibGluZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQXhpc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYWpvckdyaWRMaW5lc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQXhpc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYWpvclRpY2tzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBBeGlzRGVmYXVsdHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1pbm9yR3JpZExpbmVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBBeGlzRGVmYXVsdHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1pbm9yVGlja3NcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBBeGlzRGVmYXVsdHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm5hcnJvd1JhbmdlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBBeGlzRGVmYXVsdHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhbmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgQXhpc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwbG90QmFuZHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBBeGlzRGVmYXVsdHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInJldmVyc2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIEF4aXNEZWZhdWx0c0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic3RhcnRBbmdsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEF4aXNEZWZhdWx0c0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQXhpc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjcm9zc2hhaXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEF4aXNEZWZhdWx0c0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibGFiZWxzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBBeGlzRGVmYXVsdHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInRpdGxlXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgYWxsIENoYXJ0IGF4ZXMuXG4gKiBBY2NlcHRzIHRoZSBvcHRpb25zIHdoaWNoIGFyZSBzdXBwb3J0ZWQgYnkgW2BjYXRlZ29yeUF4aXNgXSh7JSBzbHVnIGFwaV9jaGFydHNfY2F0ZWdvcnlheGlzaXRlbWNvbXBvbmVudCAlfSksXG4gKiBbYHZhbHVlQXhpc2BdKHslIHNsdWcgYXBpX2NoYXJ0c192YWx1ZWF4aXNpdGVtY29tcG9uZW50ICV9KSxcbiAqIFtgeEF4aXNgXSh7JSBzbHVnIGFwaV9jaGFydHNfeGF4aXNpdGVtY29tcG9uZW50ICV9KSxcbiAqIGFuZCBbYHlBeGlzYF0oeyUgc2x1ZyBhcGlfY2hhcnRzX3lheGlzaXRlbWNvbXBvbmVudCAlfSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLXByZXZpZXdcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICB0ZW1wbGF0ZTogYFxuICogIDxkaXYgc3R5bGU9XCJoZWlnaHQ6IDYwMHB4O1wiPlxuICogIDxrZW5kby1jaGFydCBbY2F0ZWdvcnlBeGlzXT1cInsgY2F0ZWdvcmllczogY2F0ZWdvcmllcyB9XCIgW2NoYXJ0QXJlYV09XCJ7aGVpZ2h0OiA2MDB9XCIgPlxuICogICAgPGtlbmRvLWNoYXJ0LWF4aXMtZGVmYXVsdHNcbiAqICAgICAgW2JhY2tncm91bmRdPVwiYmFja2dyb3VuZFwiXG4gKiAgICAgIFtjb2xvcl09XCJjb2xvclwiXG4gKiAgICAgIFtjcm9zc2hhaXJdPVwiY3Jvc3NoYWlyXCJcbiAqICAgICAgW2xhYmVsc109XCJsYWJlbHNcIlxuICogICAgICBbbGluZV09XCJsaW5lXCJcbiAqICAgICAgW21ham9yR3JpZExpbmVzXT1cIm1ham9yR3JpZExpbmVzXCJcbiAqICAgICAgW21pbm9yR3JpZExpbmVzXT1cIm1pbm9yR3JpZExpbmVzXCJcbiAqICAgICAgW21ham9yVGlja3NdPVwibWFqb3JUaWNrc1wiXG4gKiAgICAgIFttaW5vclRpY2tzXT1cIm1pbm9yVGlja3NcIlxuICogICAgICBbdGl0bGVdPVwidGl0bGVcIlxuICogICAgICA+PC9rZW5kby1jaGFydC1heGlzLWRlZmF1bHRzPlxuICogICAgPGtlbmRvLWNoYXJ0LXRpdGxlIHRleHQ9XCJHcm9zcyBkb21lc3RpYyBwcm9kdWN0IGdyb3d0aCAvR0RQIGFubnVhbCAlL1wiPjwva2VuZG8tY2hhcnQtdGl0bGU+XG4gKiAgICA8a2VuZG8tY2hhcnQtbGVnZW5kIHBvc2l0aW9uPVwiYm90dG9tXCIgb3JpZW50YXRpb249XCJob3Jpem9udGFsXCI+PC9rZW5kby1jaGFydC1sZWdlbmQ+XG4gKiAgICA8a2VuZG8tY2hhcnQtdG9vbHRpcCBmb3JtYXQ9XCJ7MH0lXCI+PC9rZW5kby1jaGFydC10b29sdGlwPlxuICogICAgPGtlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0gKm5nRm9yPVwibGV0IGl0ZW0gb2Ygc2VyaWVzXCJcbiAqICAgICAgICAgICAgdHlwZT1cImxpbmVcIiBzdHlsZT1cInNtb290aFwiIFtkYXRhXT1cIml0ZW0uZGF0YVwiIFtuYW1lXT1cIml0ZW0ubmFtZVwiPlxuICogICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0+XG4gKiAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICA8L2tlbmRvLWNoYXJ0PlxuICogIDwvZGl2PlxuICogYFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICogcHVibGljIHNlcmllczogYW55W10gPSBbe1xuICogbmFtZTogXCJJbmRpYVwiLFxuICogZGF0YTogWzQsIDgsIDgsIDksIDksIDksIDMsIDgsIDksIDZdXG4gKiB9LCB7XG4gKiBuYW1lOiBcIlJ1c3NpYW4gRmVkZXJhdGlvblwiLFxuICogZGF0YTogWzQsIDcsIDcsIDYsIDgsIDgsIDUsIDgsIDQsIDRdXG4gKiB9LCB7XG4gKiBuYW1lOiBcIkdlcm1hbnlcIixcbiAqIGRhdGE6IFswLCAwLCAxLCAxLCA0LCAzLCAxLCA1LCA0LCAzXVxuICogfSx7XG4gKiBuYW1lOiBcIldvcmxkXCIsXG4gKiBkYXRhOiBbMiwgMywgNCwgNCwgNCwgNCwgMSwgMiwgNCwgM11cbiAqIH1dO1xuICpcbiAqIHB1YmxpYyAgY2F0ZWdvcmllczogbnVtYmVyW10gPSBbMjAwMiwgMjAwMywgMjAwNCwgMjAwNSwgMjAwNiwgMjAwNywgMjAwOCwgMjAwOSwgMjAxMCwgMjAxMV07XG4gKlxuICogcHVibGljIGJhY2tncm91bmQgPSAnd2hpdGUnO1xuICogLy8gcHVibGljIGNvbG9yID0gJ2N5YW4nOyAvLyB3aWxsIG92ZXJyaWRlIHRoZSBsaW5lLmNvbG9yIG9wdGlvblxuICogcHVibGljIGNyb3NzaGFpciA9IHtcbiAqIHZpc2libGU6IHRydWVcbiAqIH07XG4gKiBwdWJsaWMgbGFiZWxzID0ge1xuICogZm9udDogJ2JvbGQgMTJweC8zMHB4IEhlbHZldGljYSwgQXJpYWwsIHNhbnMtc2VyaWYnLFxuICogY29sb3I6ICcjNENBRjUwJyxcbiAqIHBhZGRpbmc6IDUsXG4gKiByb3RhdGlvbjogNDUsXG4gKiBiYWNrZ3JvdW5kOiAnd2hpdGUnLFxuICogYm9yZGVyOiB7XG4gKiBjb2xvcjogJyM0Q0FGNTAnLFxuICogd2lkdGg6IDJcbiAqIH0sXG4gKiB9O1xuICogcHVibGljIGxpbmUgPSB7XG4gKiBjb2xvcjogJ2JsYWNrJyxcbiAqIHdpZHRoOiAzXG4gKiB9O1xuICpcbiAqIHB1YmxpYyBtYWpvckdyaWRMaW5lcyA9IHtcbiAqIGNvbG9yOiAnYmxhY2snLFxuICogdmlzaWJsZTogdHJ1ZVxuICogfVxuICpcbiAqIHB1YmxpYyBtaW5vckdyaWRMaW5lcyA9IHtcbiAqIGNvbG9yOiAnbGlnaHRncmF5JyxcbiAqIHZpc2libGU6IHRydWVcbiAqIH1cbiAqXG4gKiBwdWJsaWMgbWFqb3JUaWNrcyA9IHtcbiAqIGNvbG9yOiAnYmxhY2snLFxuICogc2l6ZTogMTVcbiAqIH1cbiAqXG4gKiBwdWJsaWMgbWlub3JUaWNrcyA9IHtcbiAqIGNvbG9yOiAnbGlnaHRncmF5JyxcbiAqIHNpemU6IDEwXG4gKiB9XG4gKlxuICogcHVibGljIHRpdGxlID0ge1xuICogdGV4dDogJ0RlZmF1bHQgQXhpcyBUaXRsZScsXG4gKiBjb2xvcjogJ2JsYWNrJyxcbiAqIGJhY2tncm91bmQ6ICd3aGl0ZScsXG4gKiBib3JkZXI6IHtcbiAqIGNvbG9yOiAnYmxhY2snLFxuICogd2lkdGg6IDJcbiAqIH0sXG4gKiBwYWRkaW5nOiAxMFxuICogfVxuICogfVxuICogYGBgXG4gKi9cbmxldCBBeGlzRGVmYXVsdHNDb21wb25lbnQgPSBjbGFzcyBBeGlzRGVmYXVsdHNDb21wb25lbnQgZXh0ZW5kcyBBeGlzRGVmYXVsdHNDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuQXhpc0RlZmF1bHRzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtYXhpcy1kZWZhdWx0cycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgQXhpc0RlZmF1bHRzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEF4aXNEZWZhdWx0c0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignYXhpc0RlZmF1bHRzLmNyb3NzaGFpcicsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEF4aXNEZWZhdWx0c0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEF4aXNEZWZhdWx0c0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZGFzaFR5cGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIEF4aXNEZWZhdWx0c0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwib3BhY2l0eVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEF4aXNEZWZhdWx0c0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQXhpc0RlZmF1bHRzQ3Jvc3NoYWlyQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ3aWR0aFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQXhpc0RlZmF1bHRzQ3Jvc3NoYWlyQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGNyb3NzaGFpciBjb25maWd1cmF0aW9uIG9wdGlvbnMgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhcGlfY2hhcnRzX2F4aXNkZWZhdWx0c2NvbXBvbmVudCAlfSkpLlxuICovXG5sZXQgQXhpc0RlZmF1bHRzQ3Jvc3NoYWlyQ29tcG9uZW50ID0gY2xhc3MgQXhpc0RlZmF1bHRzQ3Jvc3NoYWlyQ29tcG9uZW50IGV4dGVuZHMgQXhpc0RlZmF1bHRzQ3Jvc3NoYWlyQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubWFya0FzVmlzaWJsZSgpO1xuICAgIH1cbn07XG5BeGlzRGVmYXVsdHNDcm9zc2hhaXJDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1heGlzLWRlZmF1bHRzLWNyb3NzaGFpcicsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgQXhpc0RlZmF1bHRzQ3Jvc3NoYWlyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIEF4aXNEZWZhdWx0c0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ2F4aXNEZWZhdWx0cy5jcm9zc2hhaXIudG9vbHRpcCcsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEF4aXNEZWZhdWx0c0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEF4aXNEZWZhdWx0c0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQXhpc0RlZmF1bHRzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEF4aXNEZWZhdWx0c0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEF4aXNEZWZhdWx0c0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQXhpc0RlZmF1bHRzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIEF4aXNEZWZhdWx0c0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgb3B0aW9ucyBvZiB0aGUgY3Jvc3NoYWlyIHRvb2x0aXAgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBjcm9zc2hhaXJzX2NoYXJ0X2NoYXJ0cyAlfSkpLlxuICogVGhlIGNyb3NzaGFpciB0b29sdGlwIGlzIGRpc3BsYXllZCB3aGVuIHRoZSBbYGF4aXNEZWZhdWx0cy5jcm9zc2hhaXIudG9vbHRpcC52aXNpYmxlYF0oeyUgc2x1ZyBhcGlfY2hhcnRzX2F4aXNkZWZhdWx0c2Nyb3NzaGFpcnRvb2x0aXBjb21wb25lbnQgJX0jdG9jLXZpc2libGUpXG4gKiBvcHRpb24gaXMgc2V0IHRvIGB0cnVlYC5cbiAqL1xubGV0IEF4aXNEZWZhdWx0c0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnQgPSBjbGFzcyBBeGlzRGVmYXVsdHNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50IGV4dGVuZHMgQXhpc0RlZmF1bHRzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG59O1xuQXhpc0RlZmF1bHRzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LWF4aXMtZGVmYXVsdHMtY3Jvc3NoYWlyLXRvb2x0aXAnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIEF4aXNEZWZhdWx0c0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQXhpc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdheGlzRGVmYXVsdHMubGFiZWxzJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBBeGlzRGVmYXVsdHNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbnRlbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEF4aXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9udFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQXhpc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEF4aXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFyZ2luXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQXhpc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtaXJyb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIEF4aXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQXhpc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJyb3RhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQXhpc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJza2lwXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBBeGlzRGVmYXVsdHNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInN0ZXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBBeGlzRGVmYXVsdHNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgQXhpc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXN1YWxcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgYXhpcyBsYWJlbHMgKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhcGlfY2hhcnRzX2F4aXNkZWZhdWx0c2NvbXBvbmVudCAlfSkpLlxuICovXG5sZXQgQXhpc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50ID0gY2xhc3MgQXhpc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50IGV4dGVuZHMgQXhpc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbkF4aXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LWF4aXMtZGVmYXVsdHMtbGFiZWxzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBBeGlzRGVmYXVsdHNMYWJlbHNDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQXhpc0RlZmF1bHRzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ2F4aXNEZWZhdWx0cy50aXRsZScsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEF4aXNEZWZhdWx0c1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBBeGlzRGVmYXVsdHNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBBeGlzRGVmYXVsdHNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEF4aXNEZWZhdWx0c1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb250XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBBeGlzRGVmYXVsdHNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFyZ2luXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBBeGlzRGVmYXVsdHNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQXhpc0RlZmF1bHRzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBBeGlzRGVmYXVsdHNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIEF4aXNEZWZhdWx0c1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQXhpc0RlZmF1bHRzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgQXhpc0RlZmF1bHRzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc3VhbFwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBheGlzIHRpdGxlIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYXBpX2NoYXJ0c19heGlzZGVmYXVsdHNjb21wb25lbnQgJX0pKS5cbiAqL1xubGV0IEF4aXNEZWZhdWx0c1RpdGxlQ29tcG9uZW50ID0gY2xhc3MgQXhpc0RlZmF1bHRzVGl0bGVDb21wb25lbnQgZXh0ZW5kcyBBeGlzRGVmYXVsdHNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5BeGlzRGVmYXVsdHNUaXRsZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LWF4aXMtZGVmYXVsdHMtdGl0bGUnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIEF4aXNEZWZhdWx0c1RpdGxlQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIENvbGxlY3Rpb25Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ0tleSwgY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMuY29uZmlnS2V5ID0gY29uZmlnS2V5O1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvblNlcnZpY2UgPSBjb2xsZWN0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5pdGVtcyA9IFtdO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbiA9IGNvbGxlY3Rpb25TZXJ2aWNlLm9uSXRlbUNoYW5nZSQuc3Vic2NyaWJlKGNoYW5nZXMgPT4gdGhpcy5wcm9jZXNzQ2hhbmdlcyhjaGFuZ2VzKSk7XG4gICAgfVxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbi51bnN1YnNjcmliZSgpO1xuICAgIH1cbiAgICBuZ0FmdGVyQ29udGVudEluaXQoKSB7XG4gICAgICAgIHRoaXMucmVhZEl0ZW1zKCk7XG4gICAgICAgIHRoaXMuY2hpbGRyZW4uY2hhbmdlcy5zdWJzY3JpYmUoKCkgPT4gdGhpcy5yZWFkSXRlbXMoKSk7XG4gICAgfVxuICAgIHByb2Nlc3NDaGFuZ2VzKGNoYW5nZXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaW5kZXggPSB0aGlzLmNoaWxkcmVuLnRvQXJyYXkoKS5pbmRleE9mKGNoYW5nZXMuc2VuZGVyKTtcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaXRlbXNbaW5kZXhdID0gY2hhbmdlcy5vcHRpb25zO1xuICAgICAgICB0aGlzLmNoYW5nZSgpO1xuICAgIH1cbiAgICByZWFkSXRlbXMoKSB7XG4gICAgICAgIHRoaXMuaXRlbXMgPSB0aGlzLmNoaWxkcmVuLm1hcChzID0+IHMub3B0aW9ucyk7XG4gICAgICAgIHRoaXMuY2hhbmdlKCk7XG4gICAgfVxuICAgIGNoYW5nZSgpIHtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZS5ub3RpZnkobmV3IENoYW5nZSh0aGlzLmNvbmZpZ0tleSwgdGhpcy5pdGVtcy5sZW5ndGggPT09IDAgPyB1bmRlZmluZWQgOiB0aGlzLml0ZW1zKSk7XG4gICAgfVxufVxuXG4vKipcbiAqIFNwZWNpZmllcyB0aGUgYHdlZWtTdGFydERheWAgb2YgYSBbQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudF0oeyUgc2x1ZyBhcGlfY2hhcnRzX2NhdGVnb3J5YXhpc2l0ZW1jb21wb25lbnQgJX0pLlxuICovXG52YXIgV2Vla1N0YXJ0RGF5O1xuKGZ1bmN0aW9uIChXZWVrU3RhcnREYXkpIHtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgU3VuZGF5IGFzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICovXG4gICAgV2Vla1N0YXJ0RGF5W1dlZWtTdGFydERheVtcIlN1bmRheVwiXSA9IDBdID0gXCJTdW5kYXlcIjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgTW9uZGF5IGFzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICovXG4gICAgV2Vla1N0YXJ0RGF5W1dlZWtTdGFydERheVtcIk1vbmRheVwiXSA9IDFdID0gXCJNb25kYXlcIjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgVHVlc2RheSBhcyB0aGUgZmlyc3QgZGF5IG9mIHRoZSB3ZWVrLlxuICAgICAqL1xuICAgIFdlZWtTdGFydERheVtXZWVrU3RhcnREYXlbXCJUdWVzZGF5XCJdID0gMl0gPSBcIlR1ZXNkYXlcIjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgV2VkbmVzZGF5IGFzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICovXG4gICAgV2Vla1N0YXJ0RGF5W1dlZWtTdGFydERheVtcIldlZG5lc2RheVwiXSA9IDNdID0gXCJXZWRuZXNkYXlcIjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgVGh1cnNkYXkgYXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgKi9cbiAgICBXZWVrU3RhcnREYXlbV2Vla1N0YXJ0RGF5W1wiVGh1cnNkYXlcIl0gPSA0XSA9IFwiVGh1cnNkYXlcIjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgRnJpZGF5IGFzIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsuXG4gICAgICovXG4gICAgV2Vla1N0YXJ0RGF5W1dlZWtTdGFydERheVtcIkZyaWRheVwiXSA9IDVdID0gXCJGcmlkYXlcIjtcbiAgICAvKipcbiAgICAgKiBTcGVjaWZpZXMgU2F0dXJkYXkgYXMgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2Vlay5cbiAgICAgKi9cbiAgICBXZWVrU3RhcnREYXlbV2Vla1N0YXJ0RGF5W1wiU2F0dXJkYXlcIl0gPSA2XSA9IFwiU2F0dXJkYXlcIjtcbn0pKFdlZWtTdGFydERheSB8fCAoV2Vla1N0YXJ0RGF5ID0ge30pKTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBDb2xsZWN0aW9uSXRlbUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlLCBpbnRsLCBsb2NhbGVJZCkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvblNlcnZpY2UgPSBjb2xsZWN0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5ub3RpZnlDaGFuZ2VzKHsgd2Vla1N0YXJ0RGF5OiBpbnRsLmZpcnN0RGF5KGxvY2FsZUlkKSB9KTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJhdXRvQmFzZVVuaXRTdGVwc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYXhpc0Nyb3NzaW5nVmFsdWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhc2VVbml0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYXNlVW5pdFN0ZXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY2F0ZWdvcmllc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJqdXN0aWZpZWRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxpbmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1ham9yR3JpZExpbmVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYWpvclRpY2tzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1heERhdGVHcm91cHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1heERpdmlzaW9uc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtaW5vckdyaWRMaW5lc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWlub3JUaWNrc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibmFtZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFuZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwbG90QmFuZHNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJyZXZlcnNlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicm91bmRUb0Jhc2VVbml0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzdGFydEFuZ2xlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwid2Vla1N0YXJ0RGF5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjcm9zc2hhaXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxhYmVsc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibm90ZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidGl0bGVcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBjb21wb25lbnQgZm9yIGEgY2F0ZWdvcnkgYXhpcyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGF4ZXNfY2hhcnRfY2hhcnRzICV9KSkuXG4gKi9cbmxldCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50ID0gY2xhc3MgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudCBleHRlbmRzIENhdGVnb3J5QXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSwgaW50bCwgbG9jYWxlSWQpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlLCBpbnRsLCBsb2NhbGVJZCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uU2VydmljZSA9IGNvbGxlY3Rpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJyYW5nZUxhYmVsc1wiLCB2b2lkIDApO1xuQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBwcm92aWRlcnM6IFtDb25maWd1cmF0aW9uU2VydmljZV0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtY2F0ZWdvcnktYXhpcy1pdGVtJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19wYXJhbSgzLCBJbmplY3QoTE9DQUxFX0lEKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZSxcbiAgICAgICAgQ29sbGVjdGlvblNlcnZpY2UsXG4gICAgICAgIEludGxTZXJ2aWNlLCBTdHJpbmddKVxuXSwgQ2F0ZWdvcnlBeGlzSXRlbUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBDYXRlZ29yeUF4aXNDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBDb2xsZWN0aW9uQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ2NhdGVnb3J5QXhpcycsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uU2VydmljZSA9IGNvbGxlY3Rpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgQ2F0ZWdvcnlBeGlzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjaGlsZHJlblwiLCB2b2lkIDApO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBvbmUgb3IgbW9yZSBjYXRlZ29yeSBheGlzIGl0ZW1zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgPGtlbmRvLWNoYXJ0PlxuICogICAgICAgPGtlbmRvLWNoYXJ0LWNhdGVnb3J5LWF4aXM+XG4gKiAgICAgICAgIDxrZW5kby1jaGFydC1jYXRlZ29yeS1heGlzLWl0ZW0gW2NhdGVnb3JpZXNdPVwiWzIwMTUsIDIwMTZdXCIgY29sb3I9XCIjZjAwXCI+XG4gKiAgICAgICAgIDwva2VuZG8tY2hhcnQtY2F0ZWdvcnktYXhpcy1pdGVtPlxuICogICAgICAgPC9rZW5kby1jaGFydC1jYXRlZ29yeS1heGlzPlxuICogICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcy1pdGVtIHR5cGU9XCJsaW5lXCIgW2RhdGFdPVwiWzEsIDIsIDNdXCI+XG4gKiAgICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0+XG4gKiAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICA8L2tlbmRvLWNoYXJ0PlxuICogICBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqIH1cbiAqIGBgYFxuICovXG5sZXQgQ2F0ZWdvcnlBeGlzQ29tcG9uZW50ID0gY2xhc3MgQ2F0ZWdvcnlBeGlzQ29tcG9uZW50IGV4dGVuZHMgQ2F0ZWdvcnlBeGlzQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uU2VydmljZSA9IGNvbGxlY3Rpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5DYXRlZ29yeUF4aXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgcHJvdmlkZXJzOiBbQ29sbGVjdGlvblNlcnZpY2VdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LWNhdGVnb3J5LWF4aXMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlLFxuICAgICAgICBDb2xsZWN0aW9uU2VydmljZV0pXG5dLCBDYXRlZ29yeUF4aXNDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdjcm9zc2hhaXInLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXRlZ29yeUF4aXNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXRlZ29yeUF4aXNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImRhc2hUeXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBDYXRlZ29yeUF4aXNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDYXRlZ29yeUF4aXNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENhdGVnb3J5QXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjcm9zc2hhaXIgY29uZmlndXJhdGlvbiBvcHRpb25zIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY3Jvc3NoYWlyc19jaGFydF9jaGFydHMgJX0pKS5cbiAqL1xubGV0IENhdGVnb3J5QXhpc0Nyb3NzaGFpckNvbXBvbmVudCA9IGNsYXNzIENhdGVnb3J5QXhpc0Nyb3NzaGFpckNvbXBvbmVudCBleHRlbmRzIENhdGVnb3J5QXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG59O1xuQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtY2F0ZWdvcnktYXhpcy1pdGVtLWNyb3NzaGFpcicsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIENhdGVnb3J5QXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ2Nyb3NzaGFpci50b29sdGlwJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXRlZ29yeUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9udFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBvcHRpb25zIG9mIHRoZSBjcm9zc2hhaXIgdG9vbHRpcCAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGNyb3NzaGFpcnNfY2hhcnRfY2hhcnRzICV9KSkuXG4gKiBUaGUgY3Jvc3NoYWlyIHRvb2x0aXAgaXMgZGlzcGxheWVkIHdoZW4gdGhlIGB2aXNpYmxlYCBvcHRpb24gaXMgc2V0IHRvIGB0cnVlYC5cbiAqL1xubGV0IENhdGVnb3J5QXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnQgPSBjbGFzcyBDYXRlZ29yeUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50IGV4dGVuZHMgQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG59O1xuQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LWNhdGVnb3J5LWF4aXMtaXRlbS1jcm9zc2hhaXItdG9vbHRpcCcsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIGF4aXMgbGFiZWxzIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgbGFiZWxzX2NoYXJ0X2NoYXJ0cyAlfSkpLlxuICovXG5sZXQgQ2F0ZWdvcnlBeGlzTGFiZWxzQ29tcG9uZW50ID0gY2xhc3MgQ2F0ZWdvcnlBeGlzTGFiZWxzQ29tcG9uZW50IGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdsYWJlbHMnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2F0ZWdvcnlBeGlzTGFiZWxzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2F0ZWdvcnlBeGlzTGFiZWxzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBDYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQucHJvdG90eXBlLCBcImNvbnRlbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhdGVnb3J5QXhpc0xhYmVsc0NvbXBvbmVudC5wcm90b3R5cGUsIFwiY3VsdHVyZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzTGFiZWxzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRlRm9ybWF0c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2F0ZWdvcnlBeGlzTGFiZWxzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmb250XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQucHJvdG90eXBlLCBcImZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzTGFiZWxzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXJnaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQucHJvdG90eXBlLCBcIm1pcnJvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzTGFiZWxzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBDYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQucHJvdG90eXBlLCBcInNraXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENhdGVnb3J5QXhpc0xhYmVsc0NvbXBvbmVudC5wcm90b3R5cGUsIFwic3RlcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIENhdGVnb3J5QXhpc0xhYmVsc0NvbXBvbmVudC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBDYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQucHJvdG90eXBlLCBcInZpc3VhbFwiLCB2b2lkIDApO1xuQ2F0ZWdvcnlBeGlzTGFiZWxzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtY2F0ZWdvcnktYXhpcy1pdGVtLWxhYmVscycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgQ2F0ZWdvcnlBeGlzTGFiZWxzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgYXhpcyBkYXRlIHJhbmdlIGxhYmVscyAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGxhYmVsc19jaGFydF9jaGFydHMgJX0pKS5cbiAqL1xubGV0IENhdGVnb3J5QXhpc1JhbmdlTGFiZWxzQ29tcG9uZW50ID0gY2xhc3MgQ2F0ZWdvcnlBeGlzUmFuZ2VMYWJlbHNDb21wb25lbnQgZXh0ZW5kcyBDYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbmZpZ0tleSA9ICdyYW5nZUxhYmVscyc7XG4gICAgICAgIHRoaXMubWFya0FzVmlzaWJsZSgpO1xuICAgIH1cbn07XG5DYXRlZ29yeUF4aXNSYW5nZUxhYmVsc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LWNhdGVnb3J5LWF4aXMtaXRlbS1yYW5nZS1sYWJlbHMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIENhdGVnb3J5QXhpc1JhbmdlTGFiZWxzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIENhdGVnb3J5QXhpc05vdGVzQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdub3RlcycsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgQ2F0ZWdvcnlBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc05vdGVzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJsaW5lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXRlZ29yeUF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgQ2F0ZWdvcnlBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc3VhbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImljb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc05vdGVzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJsYWJlbFwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBjYXRlZ29yeSBheGlzIG5vdGVzIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgbm90ZXNfY2hhcnRfY2hhcnRzICV9I3RvYy1heGlzLW5vdGVzKSkuXG4gKi9cbmxldCBDYXRlZ29yeUF4aXNOb3Rlc0NvbXBvbmVudCA9IGNsYXNzIENhdGVnb3J5QXhpc05vdGVzQ29tcG9uZW50IGV4dGVuZHMgQ2F0ZWdvcnlBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuQ2F0ZWdvcnlBeGlzTm90ZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1jYXRlZ29yeS1heGlzLWl0ZW0tbm90ZXMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIENhdGVnb3J5QXhpc05vdGVzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIENhdGVnb3J5QXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbm90ZXMuaWNvbicsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhdGVnb3J5QXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENhdGVnb3J5QXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2F0ZWdvcnlBeGlzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ2F0ZWdvcnlBeGlzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGljb24gb2YgdGhlIG5vdGVzLlxuICovXG5sZXQgQ2F0ZWdvcnlBeGlzTm90ZXNJY29uQ29tcG9uZW50ID0gY2xhc3MgQ2F0ZWdvcnlBeGlzTm90ZXNJY29uQ29tcG9uZW50IGV4dGVuZHMgQ2F0ZWdvcnlBeGlzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbkNhdGVnb3J5QXhpc05vdGVzSWNvbkNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LWNhdGVnb3J5LWF4aXMtaXRlbS1ub3Rlcy1pY29uJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBDYXRlZ29yeUF4aXNOb3Rlc0ljb25Db21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ2F0ZWdvcnlBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbm90ZXMubGFiZWwnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXRlZ29yeUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhdGVnb3J5QXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIENhdGVnb3J5QXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbnRlbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhdGVnb3J5QXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhdGVnb3J5QXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2F0ZWdvcnlBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENhdGVnb3J5QXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgQ2F0ZWdvcnlBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBsYWJlbCBvZiB0aGUgbm90ZXMuXG4gKi9cbmxldCBDYXRlZ29yeUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50ID0gY2xhc3MgQ2F0ZWdvcnlBeGlzTm90ZXNMYWJlbENvbXBvbmVudCBleHRlbmRzIENhdGVnb3J5QXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuQ2F0ZWdvcnlBeGlzTm90ZXNMYWJlbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LWNhdGVnb3J5LWF4aXMtaXRlbS1ub3Rlcy1sYWJlbCcsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgQ2F0ZWdvcnlBeGlzTm90ZXNMYWJlbENvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBDYXRlZ29yeUF4aXNTZWxlY3RDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ3NlbGVjdCcsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc1NlbGVjdENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZnJvbVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgQ2F0ZWdvcnlBeGlzU2VsZWN0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYXhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc1NlbGVjdENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDYXRlZ29yeUF4aXNTZWxlY3RDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1vdXNld2hlZWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc1NlbGVjdENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidG9cIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgc2VsZWN0ZWQgYXhpcyByYW5nZS4gSWYgc2V0LCB0aGUgYXhpcyBzZWxlY3Rpb24gaXMgZW5hYmxlZC4gVGhlIHJhbmdlIGlzIGluZGV4LWJhc2VkIGFuZCBzdGFydHMgZnJvbSB6ZXJvLlxuICogQ2F0ZWdvcmllcyB3aXRoIGluZGV4ZXMgaW4gdGhlXG4gKiAoW2BzZWxlY3QuZnJvbWBdKHslIHNsdWcgYXBpX2NoYXJ0c19jYXRlZ29yeWF4aXNzZWxlY3Rjb21wb25lbnQgJX0jdG9jLWZyb20pXG4gKiAmbWRhc2g7W2BzZWxlY3QudG9gXSh7JSBzbHVnIGFwaV9jaGFydHNfY2F0ZWdvcnlheGlzc2VsZWN0Y29tcG9uZW50ICV9I3RvYy10bykpIHJhbmdlIHdpbGwgYmUgc2VsZWN0ZWQuXG4gKiBUaGlzIG1lYW5zIHRoYXQgdGhlIGxhc3QgY2F0ZWdvcnkgaW4gdGhlIHJhbmdlIHdpbGwgbm90IGJlIGluY2x1ZGVkIGluIHRoZSBzZWxlY3Rpb24uXG4gKiBJZiB0aGUgY2F0ZWdvcmllcyBhcmUgZGF0ZXMsIHRoZSByYW5nZSBoYXMgdG8gYmUgYWxzbyBzcGVjaWZpZWQgd2l0aCBkYXRlIHZhbHVlcy5cbiAqL1xubGV0IENhdGVnb3J5QXhpc1NlbGVjdENvbXBvbmVudCA9IGNsYXNzIENhdGVnb3J5QXhpc1NlbGVjdENvbXBvbmVudCBleHRlbmRzIENhdGVnb3J5QXhpc1NlbGVjdENvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5DYXRlZ29yeUF4aXNTZWxlY3RDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1jYXRlZ29yeS1heGlzLWl0ZW0tc2VsZWN0JyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBDYXRlZ29yeUF4aXNTZWxlY3RDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgQ2F0ZWdvcnlBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ3RpdGxlJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2F0ZWdvcnlBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIENhdGVnb3J5QXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2F0ZWdvcnlBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYXJnaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENhdGVnb3J5QXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBDYXRlZ29yeUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENhdGVnb3J5QXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJyb3RhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2F0ZWdvcnlBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInRleHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBDYXRlZ29yeUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBDYXRlZ29yeUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzdWFsXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIGNhdGVnb3J5IGF4aXMgdGl0bGUuXG4gKi9cbmxldCBDYXRlZ29yeUF4aXNUaXRsZUNvbXBvbmVudCA9IGNsYXNzIENhdGVnb3J5QXhpc1RpdGxlQ29tcG9uZW50IGV4dGVuZHMgQ2F0ZWdvcnlBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuQ2F0ZWdvcnlBeGlzVGl0bGVDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1jYXRlZ29yeS1heGlzLWl0ZW0tdGl0bGUnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIENhdGVnb3J5QXhpc1RpdGxlQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIENoYXJ0QXJlYUNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignY2hhcnRBcmVhJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgQ2hhcnRBcmVhQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBDaGFydEFyZWFDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgQ2hhcnRBcmVhQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJoZWlnaHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIENoYXJ0QXJlYUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFyZ2luXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBDaGFydEFyZWFDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIENoYXJ0QXJlYUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIG9mIHRoZSBDaGFydCBhcmVhLlxuICogUmVwcmVzZW50cyB0aGUgZW50aXJlIHZpc2libGUgYXJlYSBvZiB0aGUgQ2hhcnRcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY2hhcnRhcmVhX2NoYXJ0X2NoYXJ0cyAlfSkpLlxuICovXG5sZXQgQ2hhcnRBcmVhQ29tcG9uZW50ID0gY2xhc3MgQ2hhcnRBcmVhQ29tcG9uZW50IGV4dGVuZHMgQ2hhcnRBcmVhQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbkNoYXJ0QXJlYUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LWFyZWEnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIENoYXJ0QXJlYUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBMZWdlbmRDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ2xlZ2VuZCcsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIExlZ2VuZENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYWxpZ25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIExlZ2VuZENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTGVnZW5kQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIExlZ2VuZENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBMZWdlbmRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxhYmVsc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTGVnZW5kQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYXJnaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIExlZ2VuZENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwib2Zmc2V0WFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgTGVnZW5kQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJvZmZzZXRZXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBMZWdlbmRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm9yaWVudGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBMZWdlbmRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIExlZ2VuZENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBMZWdlbmRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInJldmVyc2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBMZWdlbmRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIExlZ2VuZENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIExlZ2VuZENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFya2Vyc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgTGVnZW5kQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzcGFjaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBMZWdlbmRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImluYWN0aXZlSXRlbXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIExlZ2VuZENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiaXRlbVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTGVnZW5kQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb2YgdGhlIENoYXJ0IGxlZ2VuZFxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBsZWdlbmRfY2hhcnRfY2hhcnRzICV9KSkuXG4gKi9cbmxldCBMZWdlbmRDb21wb25lbnQgPSBjbGFzcyBMZWdlbmRDb21wb25lbnQgZXh0ZW5kcyBMZWdlbmRDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5tYXJrQXNWaXNpYmxlKCk7XG4gICAgfVxufTtcbkxlZ2VuZENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LWxlZ2VuZCcsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgTGVnZW5kQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIExlZ2VuZEluYWN0aXZlSXRlbXNDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ2xlZ2VuZC5pbmFjdGl2ZUl0ZW1zJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTGVnZW5kSW5hY3RpdmVJdGVtc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibGFiZWxzXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIGluYWN0aXZlIENoYXJ0IGxlZ2VuZCBpdGVtcy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGh0bWwtbm8tcnVuXG4gKiA8a2VuZG8tY2hhcnQ+XG4gKiAgIDxrZW5kby1jaGFydC1sZWdlbmQ+XG4gKiAgICAgIDxrZW5kby1jaGFydC1sZWdlbmQtaW5hY3RpdmUtaXRlbXMgW2xhYmVsc109XCJ7Y29sb3I6ICdwaW5rJ31cIj48L2tlbmRvLWNoYXJ0LWxlZ2VuZC1pbmFjdGl2ZS1pdGVtcz5cbiAqICAgPC9rZW5kby1jaGFydC1sZWdlbmQ+XG4gKiA8L2tlbmRvLWNoYXJ0PlxuICogYGBgXG4gKi9cbmxldCBMZWdlbmRJbmFjdGl2ZUl0ZW1zQ29tcG9uZW50ID0gY2xhc3MgTGVnZW5kSW5hY3RpdmVJdGVtc0NvbXBvbmVudCBleHRlbmRzIExlZ2VuZEluYWN0aXZlSXRlbXNDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuTGVnZW5kSW5hY3RpdmVJdGVtc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LWxlZ2VuZC1pbmFjdGl2ZS1pdGVtcycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgTGVnZW5kSW5hY3RpdmVJdGVtc0NvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBMZWdlbmRJdGVtQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdsZWdlbmQuaXRlbScsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIExlZ2VuZEl0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImN1cnNvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBMZWdlbmRJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXN1YWxcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgQ2hhcnQgbGVnZW5kIGl0ZW0uXG4gKlxuICogQGV4YW1wbGVcbiAqXG4gKiBgYGBodG1sLW5vLXJ1blxuICogPGtlbmRvLWNoYXJ0PlxuICogICA8a2VuZG8tY2hhcnQtbGVnZW5kPlxuICogICAgICA8a2VuZG8tY2hhcnQtbGVnZW5kLWl0ZW0gY3Vyc29yPVwiY3Jvc3NoYWlyXCI+PC9rZW5kby1jaGFydC1sZWdlbmQtaXRlbT5cbiAqICAgPC9rZW5kby1jaGFydC1sZWdlbmQ+XG4gKiA8L2tlbmRvLWNoYXJ0PlxuICogYGBgXG4gKi9cbmxldCBMZWdlbmRJdGVtQ29tcG9uZW50ID0gY2xhc3MgTGVnZW5kSXRlbUNvbXBvbmVudCBleHRlbmRzIExlZ2VuZEl0ZW1Db21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuTGVnZW5kSXRlbUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LWxlZ2VuZC1pdGVtJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBMZWdlbmRJdGVtQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFBhbmVDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBDb2xsZWN0aW9uSXRlbUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uU2VydmljZSA9IGNvbGxlY3Rpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFBhbmVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFBhbmVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFBhbmVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNsaXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFBhbmVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImhlaWdodFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgUGFuZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFyZ2luXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQYW5lQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBQYW5lQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBQYW5lQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIGNvbXBvbmVudCBmb3IgYSBDaGFydCBwYW5lLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICA8a2VuZG8tY2hhcnQ+XG4gKiAgICAgICAgIDxrZW5kby1jaGFydC1wYW5lcz5cbiAqICAgICAgICAgICAgIDxrZW5kby1jaGFydC1wYW5lIG5hbWU9XCJ0b3BcIiBiYWNrZ3JvdW5kPVwicGlua1wiIFtib3JkZXJdPVwieyBjb2xvcjogJ2JsYWNrJywgZGFzaHR5cGU6ICdkYXNoJywgd2lkdGg6IDIgfVwiPlxuICogICAgICAgICAgICAgICA8IS0tICAgICAgICAgICAgXl5eXl5eXl5eXlxuICogICAgICAgICAgICAgICAgICAgVW5pcXVlIElEIGZvciB0aGUgcGFuZS5cbiAqICAgICAgICAgICAgICAgLS0+XG4gKiAgICAgICAgICAgICA8L2tlbmRvLWNoYXJ0LXBhbmU+XG4gKiAgICAgICAgICAgICA8a2VuZG8tY2hhcnQtcGFuZSBuYW1lPVwiYm90dG9tXCIgW2hlaWdodF09XCIxNTBcIiB0aXRsZT1cIkJvdHRvbSBwYW5lXCI+XG4gKiAgICAgICAgICAgICAgIDwhLS0gICAgICAgICAgICAgICAgICAgICAgICAgIF5eXl5eXl5eXl5eXl5eXG4gKiAgICAgICAgICAgICAgICAgICBOb3RlIHRoYXQgdGhlIGJpbmRpbmcgaXMgcmVxdWlyZWQsXG4gKiAgICAgICAgICAgICAgICAgICBvdGhlcndpc2UgdGhlIHByb3BlcnR5IHdpbGwgYmVcbiAqICAgICAgICAgICAgICAgICAgIGJvdW5kIHRvIGEgJzEwMCcgc3RyaW5nLlxuICogICAgICAgICAgICAgICAtLT5cbiAqICAgICAgICAgICAgIDwva2VuZG8tY2hhcnQtcGFuZT5cbiAqICAgICAgICAgPC9rZW5kby1jaGFydC1wYW5lcz5cbiAqXG4gKiAgICAgICAgIDxrZW5kby1jaGFydC12YWx1ZS1heGlzPlxuICogICAgICAgICAgICAgPGtlbmRvLWNoYXJ0LXZhbHVlLWF4aXMtaXRlbSBuYW1lPVwidG9wXCI+XG4gKiAgICAgICAgICAgICAgIDwhLS0gICAgICAgICAgICAgICAgICAgICAgIF5eXl5eXl5eXl5cbiAqICAgICAgICAgICAgICAgICAgIFVuaXF1ZSBJRCBmb3IgdGhlIGF4aXMuXG4gKiAgICAgICAgICAgICAgICAgICBObyBuZWVkIHRvIHNldCBhIHBhbmUgYXMgaXQgd2lsbCB1c2UgdGhlIGZpcnN0LFxuICogICAgICAgICAgICAgICAgICAgJ3RvcCcgcGFuZSBieSBkZWZhdWx0LlxuICogICAgICAgICAgICAgICAtLT5cbiAqICAgICAgICAgICAgIDwva2VuZG8tY2hhcnQtdmFsdWUtYXhpcy1pdGVtPlxuICogICAgICAgICAgICAgPGtlbmRvLWNoYXJ0LXZhbHVlLWF4aXMtaXRlbSBuYW1lPVwiYm90dG9tXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFuZT1cImJvdHRvbVwiPlxuICogICAgICAgICAgICAgICA8IS0tICAgICAgICAgICAgICAgICAgICAgICBeXl5eXl5eXl5eXl5eXG4gKiAgICAgICAgICAgICAgICAgICBNb3ZlIHRoZSBheGlzIHRvIHRoZSBib3R0b20gcGFuZS5cbiAqICAgICAgICAgICAgICAgLS0+XG4gKiAgICAgICAgICAgICA8L2tlbmRvLWNoYXJ0LXZhbHVlLWF4aXMtaXRlbT5cbiAqICAgICAgICAgPC9rZW5kby1jaGFydC12YWx1ZS1heGlzPlxuICogICAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzPlxuICogICAgICAgICAgIDxrZW5kby1jaGFydC1zZXJpZXMtaXRlbSBbZGF0YV09XCJzZXJpZXNEYXRhWzBdXCI+XG4gKiAgICAgICAgICAgICAgIDwhLS0gV2lsbCB1c2UgdGhlIGZpcnN0LCAndG9wJyB2YWx1ZSBheGlzIGJ5IGRlZmF1bHQuIC0tPlxuICogICAgICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0+XG4gKiAgICAgICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcy1pdGVtIHR5cGU9XCJsaW5lXCIgW2RhdGFdPVwic2VyaWVzRGF0YVsxXVwiIGF4aXM9XCJib3R0b21cIj5cbiAqICAgICAgICAgICAgICAgPCEtLSBQbG90IHRoaXMgc2VyaWVzIHRvIHRoZSAnYm90dG9tJyBheGlzLiAgICAgICAgICAgICAgXl5eXl5eXl5eXl5eXiAtLT5cbiAqICAgICAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtPlxuICogICAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICAgIDwva2VuZG8tY2hhcnQ+XG4gKiAgIGBcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgcHVibGljIHNlcmllc0RhdGE6IG51bWJlcltdW10gPSBbWzEsIDIsIDMsIDVdLCBbMCwgMSwgMCwgMV1dO1xuICogfVxuICogYGBgXG4gKi9cbmxldCBQYW5lQ29tcG9uZW50ID0gY2xhc3MgUGFuZUNvbXBvbmVudCBleHRlbmRzIFBhbmVDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgfVxufTtcblBhbmVDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgcHJvdmlkZXJzOiBbQ29uZmlndXJhdGlvblNlcnZpY2VdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXBhbmUsIGtlbmRvLWNoYXJ0LXBhbmVzLWl0ZW0nLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlLFxuICAgICAgICBDb2xsZWN0aW9uU2VydmljZV0pXG5dLCBQYW5lQ29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgZGVmYXVsdCBvcHRpb25zIGZvciBhbGwgY2hhcnQgcGFuZXMsXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHBhbmVzX2NoYXJ0X2NoYXJ0cyAlfSN0b2MtZGVmYXVsdC1wYW5lcy1jb25maWd1cmF0aW9uKSkuXG4gKi9cbmxldCBQYW5lRGVmYXVsdHNDb21wb25lbnQgPSBjbGFzcyBQYW5lRGVmYXVsdHNDb21wb25lbnQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ3BhbmVEZWZhdWx0cycsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQYW5lRGVmYXVsdHNDb21wb25lbnQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFBhbmVEZWZhdWx0c0NvbXBvbmVudC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgUGFuZURlZmF1bHRzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjbGlwXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBQYW5lRGVmYXVsdHNDb21wb25lbnQucHJvdG90eXBlLCBcImhlaWdodFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgUGFuZURlZmF1bHRzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJtYXJnaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFBhbmVEZWZhdWx0c0NvbXBvbmVudC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgUGFuZURlZmF1bHRzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB2b2lkIDApO1xuUGFuZURlZmF1bHRzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtcGFuZS1kZWZhdWx0cycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgUGFuZURlZmF1bHRzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgcGFuZSBkZWZhdWx0IHRpdGxlLlxuICovXG5sZXQgUGFuZURlZmF1bHRzVGl0bGVDb21wb25lbnQgPSBjbGFzcyBQYW5lRGVmYXVsdHNUaXRsZUNvbXBvbmVudCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcigncGFuZURlZmF1bHRzLnRpdGxlJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFBhbmVEZWZhdWx0c1RpdGxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBQYW5lRGVmYXVsdHNUaXRsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQYW5lRGVmYXVsdHNUaXRsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFBhbmVEZWZhdWx0c1RpdGxlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJmb250XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBQYW5lRGVmYXVsdHNUaXRsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwibWFyZ2luXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQYW5lRGVmYXVsdHNUaXRsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBQYW5lRGVmYXVsdHNUaXRsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBQYW5lRGVmYXVsdHNUaXRsZUNvbXBvbmVudC5wcm90b3R5cGUsIFwidmlzdWFsXCIsIHZvaWQgMCk7XG5QYW5lRGVmYXVsdHNUaXRsZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXBhbmUtZGVmYXVsdHMtdGl0bGUnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFBhbmVEZWZhdWx0c1RpdGxlQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFBhbmVzQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgQ29sbGVjdGlvbkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdwYW5lcycsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uU2VydmljZSA9IGNvbGxlY3Rpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihQYW5lQ29tcG9uZW50KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgUGFuZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNoaWxkcmVuXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIG9uZSBvciBtb3JlIHBhbmUgY29uZmlndXJhdGlvbiBjb21wb25lbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgPGtlbmRvLWNoYXJ0PlxuICogICAgICAgPGtlbmRvLWNoYXJ0LXBhbmVzPlxuICogICAgICAgICA8a2VuZG8tY2hhcnQtcGFuZSBuYW1lPVwidG9wUGFuZVwiPlxuICogICAgICAgICA8L2tlbmRvLWNoYXJ0LXBhbmU+XG4gKiAgICAgICAgIDxrZW5kby1jaGFydC1wYW5lIG5hbWU9XCJib3R0b21QYW5lXCI+XG4gKiAgICAgICAgIDwva2VuZG8tY2hhcnQtcGFuZT5cbiAqICAgICAgIDwva2VuZG8tY2hhcnQtcGFuZXM+XG4gKiAgICAgICA8a2VuZG8tY2hhcnQtdmFsdWUtYXhpcz5cbiAqICAgICAgICAgPGtlbmRvLWNoYXJ0LXZhbHVlLWF4aXMtaXRlbSBwYW5lPVwidG9wUGFuZVwiPlxuICogICAgICAgICA8L2tlbmRvLWNoYXJ0LXZhbHVlLWF4aXMtaXRlbT5cbiAqICAgICAgICAgPGtlbmRvLWNoYXJ0LXZhbHVlLWF4aXMtaXRlbSBuYW1lPVwiYm90dG9tQXhpc1wiIHBhbmU9XCJib3R0b21QYW5lXCI+XG4gKiAgICAgICAgIDwva2VuZG8tY2hhcnQtdmFsdWUtYXhpcy1pdGVtPlxuICogICAgICAgPC9rZW5kby1jaGFydC12YWx1ZS1heGlzPlxuICogICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcy1pdGVtIHR5cGU9XCJsaW5lXCIgW2RhdGFdPVwiWzEsIDIsIDNdXCI+XG4gKiAgICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0+XG4gKiAgICAgICAgIDxrZW5kby1jaGFydC1zZXJpZXMtaXRlbSB0eXBlPVwibGluZVwiIFtkYXRhXT1cIlsxLCAyLCAzLCA0XVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBheGlzPVwiYm90dG9tQXhpc1wiPlxuICogICAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtPlxuICogICAgICAgPC9rZW5kby1jaGFydC1zZXJpZXM+XG4gKiAgICAgPC9rZW5kby1jaGFydD5cbiAqICAgYFxuICogfSlcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiB9XG4gKlxuICogYGBgXG4gKi9cbmxldCBQYW5lc0NvbXBvbmVudCA9IGNsYXNzIFBhbmVzQ29tcG9uZW50IGV4dGVuZHMgUGFuZXNDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgfVxufTtcblBhbmVzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHByb3ZpZGVyczogW0NvbGxlY3Rpb25TZXJ2aWNlXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1wYW5lcycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgICAgIENvbGxlY3Rpb25TZXJ2aWNlXSlcbl0sIFBhbmVzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFBhbmVzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ3RpdGxlJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgUGFuZXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgUGFuZXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQYW5lc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgUGFuZXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9udFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgUGFuZXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFyZ2luXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBQYW5lc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgUGFuZXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidGV4dFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFBhbmVzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgUGFuZXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzdWFsXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIENoYXJ0IHBhbmUgdGl0bGUuXG4gKi9cbmxldCBQYW5lc1RpdGxlQ29tcG9uZW50ID0gY2xhc3MgUGFuZXNUaXRsZUNvbXBvbmVudCBleHRlbmRzIFBhbmVzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuUGFuZXNUaXRsZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXBhbmUtdGl0bGUnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFBhbmVzVGl0bGVDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgUGxvdEFyZWFDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ3Bsb3RBcmVhJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgUGxvdEFyZWFDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFBsb3RBcmVhQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFBsb3RBcmVhQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYXJnaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFBsb3RBcmVhQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJvcGFjaXR5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBQbG90QXJlYUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb2YgdGhlIHBsb3QgYXJlYVxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBwbG90YXJlYV9jaGFydF9jaGFydHMgJX0pKS5cbiAqIFRoZSBwbG90IGFyZWEgaXMgdGhlIGFyZWEgd2hpY2ggZGlzcGxheXMgdGhlIHNlcmllcy5cbiAqL1xubGV0IFBsb3RBcmVhQ29tcG9uZW50ID0gY2xhc3MgUGxvdEFyZWFDb21wb25lbnQgZXh0ZW5kcyBQbG90QXJlYUNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5QbG90QXJlYUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXBsb3QtYXJlYScsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgUGxvdEFyZWFDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2VyaWVzQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgQ29sbGVjdGlvbkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdzZXJpZXMnLCBjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvblNlcnZpY2UgPSBjb2xsZWN0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGRyZW4oU2VyaWVzSXRlbUNvbXBvbmVudCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIFNlcmllc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY2hpbGRyZW5cIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2Ygb25lIG9yIG1vcmUgc2VyaWVzIGl0ZW1zLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgPGtlbmRvLWNoYXJ0PlxuICogICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcy1pdGVtIHR5cGU9XCJsaW5lXCIgW2RhdGFdPVwiWzEsIDIsIDNdXCI+XG4gKiAgICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0+XG4gKiAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICA8L2tlbmRvLWNoYXJ0PlxuICogICBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqIH1cbiAqXG4gKiBgYGBcbiAqL1xubGV0IFNlcmllc0NvbXBvbmVudCA9IGNsYXNzIFNlcmllc0NvbXBvbmVudCBleHRlbmRzIFNlcmllc0NvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSwgdG9vbHRpcFRlbXBsYXRlU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvblNlcnZpY2UgPSBjb2xsZWN0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy50b29sdGlwVGVtcGxhdGVTZXJ2aWNlID0gdG9vbHRpcFRlbXBsYXRlU2VydmljZTtcbiAgICB9XG4gICAgbmdBZnRlckNvbnRlbnRDaGVja2VkKCkge1xuICAgICAgICB0aGlzLnJlYWRUb29sdGlwVGVtcGxhdGVzKCk7XG4gICAgfVxuICAgIHJlYWRUb29sdGlwVGVtcGxhdGVzKCkge1xuICAgICAgICBjb25zdCB0ZW1wbGF0ZXMgPSB0aGlzLmNoaWxkcmVuLm1hcCgoaXRlbSkgPT4gaXRlbS5zZXJpZXNUb29sdGlwVGVtcGxhdGVSZWYpO1xuICAgICAgICB0aGlzLnRvb2x0aXBUZW1wbGF0ZVNlcnZpY2Uuc2V0U2VyaWVzVGVtcGxhdGVzKHRlbXBsYXRlcyk7XG4gICAgfVxufTtcblNlcmllc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBwcm92aWRlcnM6IFtDb2xsZWN0aW9uU2VydmljZV0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtc2VyaWVzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZSxcbiAgICAgICAgQ29sbGVjdGlvblNlcnZpY2UsXG4gICAgICAgIFRvb2x0aXBUZW1wbGF0ZVNlcnZpY2VdKVxuXSwgU2VyaWVzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNlcmllc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdzZXJpZXNEZWZhdWx0cycsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNlcmllc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJnYXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJoaWdobGlnaHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJvdmVybGF5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTZXJpZXNEZWZhdWx0c0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic3BhY2luZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzRGVmYXVsdHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInN0YWNrXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNEZWZhdWx0c0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidHlwZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBTZXJpZXNEZWZhdWx0c0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzdWFsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNEZWZhdWx0c0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibGFiZWxzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNEZWZhdWx0c0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibm90ZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0RlZmF1bHRzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgb3B0aW9ucyBmb3IgYWxsIHNlcmllc1xuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBzZXJpZXNfY2hhcnRfY2hhcnRzICV9I3RvYy1kZWZhdWx0LXNlcmllcy1jb25maWd1cmF0aW9uKSkuXG4gKi9cbmxldCBTZXJpZXNEZWZhdWx0c0NvbXBvbmVudCA9IGNsYXNzIFNlcmllc0RlZmF1bHRzQ29tcG9uZW50IGV4dGVuZHMgU2VyaWVzRGVmYXVsdHNDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuU2VyaWVzRGVmYXVsdHNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1zZXJpZXMtZGVmYXVsdHMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFNlcmllc0RlZmF1bHRzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNlcmllc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdzZXJpZXNEZWZhdWx0cy5sYWJlbHMnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzRGVmYXVsdHNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzRGVmYXVsdHNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFNlcmllc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb250ZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9udFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzRGVmYXVsdHNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzRGVmYXVsdHNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1hcmdpblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzRGVmYXVsdHNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzdWFsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZnJvbVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzRGVmYXVsdHNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInRvXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIENoYXJ0IHNlcmllcyBsYWJlbC5cbiAqL1xubGV0IFNlcmllc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50ID0gY2xhc3MgU2VyaWVzRGVmYXVsdHNMYWJlbHNDb21wb25lbnQgZXh0ZW5kcyBTZXJpZXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG59O1xuU2VyaWVzRGVmYXVsdHNMYWJlbHNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1zZXJpZXMtZGVmYXVsdHMtbGFiZWxzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTZXJpZXNEZWZhdWx0c0xhYmVsc0Zyb21Db21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ3Nlcmllc0RlZmF1bHRzLmxhYmVscy5mcm9tJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzRGVmYXVsdHNMYWJlbHNGcm9tQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc0Zyb21Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzRGVmYXVsdHNMYWJlbHNGcm9tQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc0Zyb21Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbnRlbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0RlZmF1bHRzTGFiZWxzRnJvbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9udFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzRGVmYXVsdHNMYWJlbHNGcm9tQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0RlZmF1bHRzTGFiZWxzRnJvbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFyZ2luXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc0Zyb21Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc0Zyb21Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgYGZyb21gIGxhYmVsIGNvbmZpZ3VyYXRpb24gb2YgdGhlIENoYXJ0IHNlcmllcy5cbiAqL1xubGV0IFNlcmllc0RlZmF1bHRzTGFiZWxzRnJvbUNvbXBvbmVudCA9IGNsYXNzIFNlcmllc0RlZmF1bHRzTGFiZWxzRnJvbUNvbXBvbmVudCBleHRlbmRzIFNlcmllc0RlZmF1bHRzTGFiZWxzRnJvbUNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG59O1xuU2VyaWVzRGVmYXVsdHNMYWJlbHNGcm9tQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtc2VyaWVzLWRlZmF1bHRzLWxhYmVscy1mcm9tJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc0Zyb21Db21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2VyaWVzRGVmYXVsdHNMYWJlbHNUb0NvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignc2VyaWVzRGVmYXVsdHMubGFiZWxzLnRvJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzRGVmYXVsdHNMYWJlbHNUb0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzRGVmYXVsdHNMYWJlbHNUb0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc1RvQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc1RvQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb250ZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc1RvQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb250XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc1RvQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0RlZmF1bHRzTGFiZWxzVG9Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1hcmdpblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzRGVmYXVsdHNMYWJlbHNUb0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNlcmllc0RlZmF1bHRzTGFiZWxzVG9Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgYHRvYCBsYWJlbCBjb25maWd1cmF0aW9uIG9mIHRoZSBDaGFydCBzZXJpZXMuXG4gKi9cbmxldCBTZXJpZXNEZWZhdWx0c0xhYmVsc1RvQ29tcG9uZW50ID0gY2xhc3MgU2VyaWVzRGVmYXVsdHNMYWJlbHNUb0NvbXBvbmVudCBleHRlbmRzIFNlcmllc0RlZmF1bHRzTGFiZWxzVG9Db21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5tYXJrQXNWaXNpYmxlKCk7XG4gICAgfVxufTtcblNlcmllc0RlZmF1bHRzTGFiZWxzVG9Db21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1zZXJpZXMtZGVmYXVsdHMtbGFiZWxzLXRvJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBTZXJpZXNEZWZhdWx0c0xhYmVsc1RvQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNlcmllc0RlZmF1bHRzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ3Nlcmllc0RlZmF1bHRzLm5vdGVzJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzRGVmYXVsdHNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibGluZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBTZXJpZXNEZWZhdWx0c05vdGVzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXN1YWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0RlZmF1bHRzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImljb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0RlZmF1bHRzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxhYmVsXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIFtgc2VyaWVzRGVmYXVsdHNgXSh7JSBzbHVnIGFwaV9jaGFydHNfc2VyaWVzZGVmYXVsdHNjb21wb25lbnQgJX0pIG5vdGVzLlxuICovXG5sZXQgU2VyaWVzRGVmYXVsdHNOb3Rlc0NvbXBvbmVudCA9IGNsYXNzIFNlcmllc0RlZmF1bHRzTm90ZXNDb21wb25lbnQgZXh0ZW5kcyBTZXJpZXNEZWZhdWx0c05vdGVzQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcblNlcmllc0RlZmF1bHRzTm90ZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1zZXJpZXMtZGVmYXVsdHMtbm90ZXMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFNlcmllc0RlZmF1bHRzTm90ZXNDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2VyaWVzRGVmYXVsdHNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ3Nlcmllc0RlZmF1bHRzLm5vdGVzLmljb24nLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNEZWZhdWx0c05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzRGVmYXVsdHNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2VyaWVzRGVmYXVsdHNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0RlZmF1bHRzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2VyaWVzRGVmYXVsdHNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgaWNvbiBvZiB0aGUgbm90ZXMuXG4gKi9cbmxldCBTZXJpZXNEZWZhdWx0c05vdGVzSWNvbkNvbXBvbmVudCA9IGNsYXNzIFNlcmllc0RlZmF1bHRzTm90ZXNJY29uQ29tcG9uZW50IGV4dGVuZHMgU2VyaWVzRGVmYXVsdHNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuU2VyaWVzRGVmYXVsdHNOb3Rlc0ljb25Db21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1zZXJpZXMtZGVmYXVsdHMtbm90ZXMtaWNvbicsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgU2VyaWVzRGVmYXVsdHNOb3Rlc0ljb25Db21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2VyaWVzRGVmYXVsdHNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdzZXJpZXNEZWZhdWx0cy5ub3Rlcy5sYWJlbCcsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0RlZmF1bHRzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzRGVmYXVsdHNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0RlZmF1bHRzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgU2VyaWVzRGVmYXVsdHNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb250ZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNEZWZhdWx0c05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0RlZmF1bHRzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNEZWZhdWx0c05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTZXJpZXNEZWZhdWx0c05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2VyaWVzRGVmYXVsdHNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGxhYmVsIG9mIHRoZSBub3Rlcy5cbiAqL1xubGV0IFNlcmllc0RlZmF1bHRzTm90ZXNMYWJlbENvbXBvbmVudCA9IGNsYXNzIFNlcmllc0RlZmF1bHRzTm90ZXNMYWJlbENvbXBvbmVudCBleHRlbmRzIFNlcmllc0RlZmF1bHRzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5TZXJpZXNEZWZhdWx0c05vdGVzTGFiZWxDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1zZXJpZXMtZGVmYXVsdHMtbm90ZXMtbGFiZWwnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFNlcmllc0RlZmF1bHRzTm90ZXNMYWJlbENvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTZXJpZXNEZWZhdWx0c1Rvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ3Nlcmllc0RlZmF1bHRzLnRvb2x0aXAnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNEZWZhdWx0c1Rvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0RlZmF1bHRzVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNEZWZhdWx0c1Rvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNEZWZhdWx0c1Rvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0RlZmF1bHRzVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNEZWZhdWx0c1Rvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTZXJpZXNEZWZhdWx0c1Rvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIG9mIHRoZSBDaGFydCBzZXJpZXMgdG9vbHRpcC5cbiAqL1xubGV0IFNlcmllc0RlZmF1bHRzVG9vbHRpcENvbXBvbmVudCA9IGNsYXNzIFNlcmllc0RlZmF1bHRzVG9vbHRpcENvbXBvbmVudCBleHRlbmRzIFNlcmllc0RlZmF1bHRzVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZS5cbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5tYXJrQXNWaXNpYmxlKCk7XG4gICAgfVxufTtcblNlcmllc0RlZmF1bHRzVG9vbHRpcENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXNlcmllcy1kZWZhdWx0cy10b29sdGlwJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBTZXJpZXNEZWZhdWx0c1Rvb2x0aXBDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2VyaWVzRXJyb3JCYXJzQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdlcnJvckJhcnMnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNFcnJvckJhcnNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2VyaWVzRXJyb3JCYXJzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJlbmRDYXBzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNFcnJvckJhcnNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxpbmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0Vycm9yQmFyc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmFsdWVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgU2VyaWVzRXJyb3JCYXJzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXN1YWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0Vycm9yQmFyc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwieFZhbHVlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNFcnJvckJhcnNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInlWYWx1ZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBlcnJvciBiYXJzIG9mIHRoZSBDaGFydCBzZXJpZXNcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgZXJyb3JiYXJzX2NoYXJ0X2NoYXJ0cyAlfSkpLlxuICovXG5sZXQgU2VyaWVzRXJyb3JCYXJzQ29tcG9uZW50ID0gY2xhc3MgU2VyaWVzRXJyb3JCYXJzQ29tcG9uZW50IGV4dGVuZHMgU2VyaWVzRXJyb3JCYXJzQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcblNlcmllc0Vycm9yQmFyc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtLWVycm9yLWJhcnMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFNlcmllc0Vycm9yQmFyc0NvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTZXJpZXNFeHRyZW1lc0NvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignZXh0cmVtZXMnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNFeHRyZW1lc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzRXh0cmVtZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2VyaWVzRXh0cmVtZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTZXJpZXNFeHRyZW1lc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzRXh0cmVtZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgQ2hhcnQgc2VyaWVzIGV4dHJlbWVzLlxuICogQXBwbGllcyB0byBleHRyZW1lIG91dGxpZXJzLlxuICogRm9yIG1vcmUgaW5mb3JtYXRpb24sIHJlZmVyIHRvIFtgc2VyaWVzLm91dGxpZXJzYF0oeyUgc2x1ZyBhcGlfY2hhcnRzX3Nlcmllc2l0ZW1jb21wb25lbnQgJX0jdG9jLW91dGxpZXJzKS5cbiAqL1xubGV0IFNlcmllc0V4dHJlbWVzQ29tcG9uZW50ID0gY2xhc3MgU2VyaWVzRXh0cmVtZXNDb21wb25lbnQgZXh0ZW5kcyBTZXJpZXNFeHRyZW1lc0NvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5TZXJpZXNFeHRyZW1lc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtLWV4dHJlbWVzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBTZXJpZXNFeHRyZW1lc0NvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTZXJpZXNIaWdobGlnaHRDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ2hpZ2hsaWdodCcsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0hpZ2hsaWdodENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNIaWdobGlnaHRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNIaWdobGlnaHRDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxpbmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0hpZ2hsaWdodENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFya2Vyc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2VyaWVzSGlnaGxpZ2h0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJvcGFjaXR5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFNlcmllc0hpZ2hsaWdodENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidG9nZ2xlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2VyaWVzSGlnaGxpZ2h0Q29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFNlcmllc0hpZ2hsaWdodENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzdWFsXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIENoYXJ0IHNlcmllcyBoaWdobGlnaHRpbmcgY29uZmlndXJhdGlvbiBvcHRpb25zLlxuICovXG5sZXQgU2VyaWVzSGlnaGxpZ2h0Q29tcG9uZW50ID0gY2xhc3MgU2VyaWVzSGlnaGxpZ2h0Q29tcG9uZW50IGV4dGVuZHMgU2VyaWVzSGlnaGxpZ2h0Q29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuU2VyaWVzSGlnaGxpZ2h0Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0taGlnaGxpZ2h0JyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBTZXJpZXNIaWdobGlnaHRDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2VyaWVzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdsYWJlbHMnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImFsaWduXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFNlcmllc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29udGVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2VyaWVzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJkaXN0YW5jZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb250XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYXJnaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgU2VyaWVzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJyb3RhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNlcmllc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBTZXJpZXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc3VhbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmcm9tXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInRvXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIENoYXJ0IHNlcmllcyBsYWJlbFxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBsYWJlbHNfY2hhcnRfY2hhcnRzICV9KSkuXG4gKi9cbmxldCBTZXJpZXNMYWJlbHNDb21wb25lbnQgPSBjbGFzcyBTZXJpZXNMYWJlbHNDb21wb25lbnQgZXh0ZW5kcyBTZXJpZXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5tYXJrQXNWaXNpYmxlKCk7XG4gICAgfVxufTtcblNlcmllc0xhYmVsc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtLWxhYmVscycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgU2VyaWVzTGFiZWxzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNlcmllc0xhYmVsc0Zyb21Db21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ2xhYmVscy5mcm9tJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzTGFiZWxzRnJvbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzTGFiZWxzRnJvbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNMYWJlbHNGcm9tQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBTZXJpZXNMYWJlbHNGcm9tQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb250ZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNMYWJlbHNGcm9tQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb250XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNMYWJlbHNGcm9tQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0xhYmVsc0Zyb21Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1hcmdpblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzTGFiZWxzRnJvbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzTGFiZWxzRnJvbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTZXJpZXNMYWJlbHNGcm9tQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGBmcm9tYCBsYWJlbCBjb25maWd1cmF0aW9uIG9mIHRoZSBDaGFydCBzZXJpZXMuXG4gKi9cbmxldCBTZXJpZXNMYWJlbHNGcm9tQ29tcG9uZW50ID0gY2xhc3MgU2VyaWVzTGFiZWxzRnJvbUNvbXBvbmVudCBleHRlbmRzIFNlcmllc0xhYmVsc0Zyb21Db21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5tYXJrQXNWaXNpYmxlKCk7XG4gICAgfVxufTtcblNlcmllc0xhYmVsc0Zyb21Db21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1zZXJpZXMtaXRlbS1sYWJlbHMtZnJvbScsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgU2VyaWVzTGFiZWxzRnJvbUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTZXJpZXNMYWJlbHNUb0NvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbGFiZWxzLnRvJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzTGFiZWxzVG9Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0xhYmVsc1RvQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0xhYmVsc1RvQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBTZXJpZXNMYWJlbHNUb0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29udGVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzTGFiZWxzVG9Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc0xhYmVsc1RvQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0xhYmVsc1RvQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYXJnaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc0xhYmVsc1RvQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNMYWJlbHNUb0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBTZXJpZXNMYWJlbHNUb0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBgdG9gIGxhYmVsIGNvbmZpZ3VyYXRpb24gb2YgdGhlIENoYXJ0IHNlcmllcy5cbiAqL1xubGV0IFNlcmllc0xhYmVsc1RvQ29tcG9uZW50ID0gY2xhc3MgU2VyaWVzTGFiZWxzVG9Db21wb25lbnQgZXh0ZW5kcyBTZXJpZXNMYWJlbHNUb0NvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG59O1xuU2VyaWVzTGFiZWxzVG9Db21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1zZXJpZXMtaXRlbS1sYWJlbHMtdG8nLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFNlcmllc0xhYmVsc1RvQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNlcmllc01hcmtlcnNDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ21hcmtlcnMnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNNYXJrZXJzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNNYXJrZXJzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNlcmllc01hcmtlcnNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTZXJpZXNNYXJrZXJzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNNYXJrZXJzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2VyaWVzTWFya2Vyc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBTZXJpZXNNYXJrZXJzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXN1YWxcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc01hcmtlcnNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZyb21cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc01hcmtlcnNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInRvXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIENoYXJ0IHNlcmllcyBtYXJrZXIuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICAgICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICA8a2VuZG8tY2hhcnQgW2NhdGVnb3J5QXhpc109XCJ7IGNhdGVnb3JpZXM6IGNhdGVnb3JpZXMgfVwiPlxuICogICAgICAgICAgIDxrZW5kby1jaGFydC10aXRsZSB0ZXh0PVwiR3Jvc3MgZG9tZXN0aWMgcHJvZHVjdCBncm93dGggL0dEUCBhbm51YWwgJS9cIj48L2tlbmRvLWNoYXJ0LXRpdGxlPlxuICogICAgICAgICAgIDxrZW5kby1jaGFydC1sZWdlbmQgcG9zaXRpb249XCJib3R0b21cIiBvcmllbnRhdGlvbj1cImhvcml6b250YWxcIj48L2tlbmRvLWNoYXJ0LWxlZ2VuZD5cbiAqICAgICAgICAgICA8a2VuZG8tY2hhcnQtdG9vbHRpcCBmb3JtYXQ9XCJ7MH0lXCI+PC9rZW5kby1jaGFydC10b29sdGlwPlxuICogICAgICAgICAgIDxrZW5kby1jaGFydC1zZXJpZXM+XG4gKiAgICAgICAgICAgICAgIDxrZW5kby1jaGFydC1zZXJpZXMtaXRlbSAqbmdGb3I9XCJsZXQgaXRlbSBvZiBzZXJpZXNcIlxuICogICAgICAgICAgICAgICAgICAgdHlwZT1cImxpbmVcIlxuICogICAgICAgICAgICAgICAgICAgc3R5bGU9XCJzbW9vdGhcIlxuICogICAgICAgICAgICAgICAgICAgW2RhdGFdPVwiaXRlbS5kYXRhXCJcbiAqICAgICAgICAgICAgICAgICAgIFtuYW1lXT1cIml0ZW0ubmFtZVwiXG4gKiAgICAgICAgICAgICAgICAgICBbbWFya2Vyc109XCJpdGVtLm1hcmtlcnNcIj5cbiAqICAgICAgICAgICAgICAgPC9rZW5kby1jaGFydC1zZXJpZXMtaXRlbT5cbiAqICAgICAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICAgIDwva2VuZG8tY2hhcnQ+XG4gKiAgIGBcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqIHB1YmxpYyBzZXJpZXM6IGFueVtdID0gW3tcbiAqICAgbmFtZTogXCJJbmRpYVwiLFxuICogICBkYXRhOiBbMy45MDcsIDcuOTQzLCA3Ljg0OCwgOS4yODQsIDkuMjYzLCA5LjgwMSwgMy44OTAsIDguMjM4LCA5LjU1MiwgNi44NTVdLFxuICogICBtYXJrZXJzOiB7XG4gKiAgICAgYmFja2dyb3VuZDogJ3JlZCcsXG4gKiAgICAgc2l6ZTogMjAsXG4gKiAgICAgdHlwZTogJ2NpcmNsZSdcbiAqICAgfVxuICogfSwge1xuICogICBuYW1lOiBcIlJ1c3NpYW4gRmVkZXJhdGlvblwiLFxuICogICBkYXRhOiBbNC43NDMsIDcuMjk1LCA3LjE3NSwgNi4zNzYsIDguMTUzLCA4LjUzNSwgNS4yNDcsIC03LjgzMiwgNC4zLCA0LjNdLFxuICogICBtYXJrZXJzOiB7XG4gKiAgICAgYmFja2dyb3VuZDogJ3llbGxvdycsXG4gKiAgICAgc2l6ZTogMTAsXG4gKiAgICAgdHlwZTogJ3NxdWFyZScsXG4gKiAgICAgcm90YXRpb246IDQ1XG4gKiAgIH1cbiAqIH0sIHtcbiAqICAgbmFtZTogXCJHZXJtYW55XCIsXG4gKiAgIGRhdGE6IFswLjAxMCwgLTAuMzc1LCAxLjE2MSwgMC42ODQsIDMuNywgMy4yNjksIDEuMDgzLCAtNS4xMjcsIDMuNjkwLCAyLjk5NV0sXG4gKiAgIG1hcmtlcnM6IHtcbiAqICAgICBiYWNrZ3JvdW5kOiAnZ3JlZW4nLFxuICogICAgIHNpemU6IDIwLFxuICogICAgIHR5cGU6ICd0cmlhbmdsZSdcbiAqICAgfVxuICogfSx7XG4gKiAgIG5hbWU6IFwiV29ybGRcIixcbiAqICAgZGF0YTogWzEuOTg4LCAyLjczMywgMy45OTQsIDMuNDY0LCA0LjAwMSwgMy45MzksIDEuMzMzLCAtMi4yNDUsIDQuMzM5LCAyLjcyN10sXG4gKiAgIG1hcmtlcnM6IHtcbiAqICAgICBiYWNrZ3JvdW5kOiAnYmx1ZScsXG4gKiAgICAgc2l6ZTogMTAsXG4gKiAgICAgdHlwZTogJ2Nyb3NzJ1xuICogICB9XG4gKiB9XTtcbiAqIHB1YmxpYyBjYXRlZ29yaWVzOiBudW1iZXJbXSA9IFsyMDAyLCAyMDAzLCAyMDA0LCAyMDA1LCAyMDA2LCAyMDA3LCAyMDA4LCAyMDA5LCAyMDEwLCAyMDExXTtcbiAqIH1cbiAqIGBgYFxuICovXG5sZXQgU2VyaWVzTWFya2Vyc0NvbXBvbmVudCA9IGNsYXNzIFNlcmllc01hcmtlcnNDb21wb25lbnQgZXh0ZW5kcyBTZXJpZXNNYXJrZXJzQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcblNlcmllc01hcmtlcnNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1zZXJpZXMtaXRlbS1tYXJrZXJzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBTZXJpZXNNYXJrZXJzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNlcmllc05vdGVzQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdub3RlcycsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc05vdGVzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJsaW5lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgU2VyaWVzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc3VhbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgU2VyaWVzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImljb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc05vdGVzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJsYWJlbFwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBzZXJpZXMgbm90ZXMgY29uZmlndXJhdGlvblxuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBub3Rlc19jaGFydF9jaGFydHMgJX0pKS5cbiAqL1xubGV0IFNlcmllc05vdGVzQ29tcG9uZW50ID0gY2xhc3MgU2VyaWVzTm90ZXNDb21wb25lbnQgZXh0ZW5kcyBTZXJpZXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5TZXJpZXNOb3Rlc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtLW5vdGVzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBTZXJpZXNOb3Rlc0NvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTZXJpZXNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ25vdGVzLmljb24nLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFNlcmllc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTZXJpZXNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInNpemVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidHlwZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFNlcmllc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBpY29uIG9mIHRoZSBub3Rlcy5cbiAqL1xubGV0IFNlcmllc05vdGVzSWNvbkNvbXBvbmVudCA9IGNsYXNzIFNlcmllc05vdGVzSWNvbkNvbXBvbmVudCBleHRlbmRzIFNlcmllc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5TZXJpZXNOb3Rlc0ljb25Db21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1zZXJpZXMtaXRlbS1ub3Rlcy1pY29uJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBTZXJpZXNOb3Rlc0ljb25Db21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgU2VyaWVzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbm90ZXMubGFiZWwnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFNlcmllc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbnRlbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgU2VyaWVzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNlcmllc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgU2VyaWVzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBsYWJlbCBvZiB0aGUgbm90ZXMuXG4gKi9cbmxldCBTZXJpZXNOb3Rlc0xhYmVsQ29tcG9uZW50ID0gY2xhc3MgU2VyaWVzTm90ZXNMYWJlbENvbXBvbmVudCBleHRlbmRzIFNlcmllc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuU2VyaWVzTm90ZXNMYWJlbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtLW5vdGVzLWxhYmVsJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBTZXJpZXNOb3Rlc0xhYmVsQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFNlcmllc091dGxpZXJzQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdvdXRsaWVycycsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFNlcmllc091dGxpZXJzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTZXJpZXNPdXRsaWVyc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBTZXJpZXNPdXRsaWVyc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFNlcmllc091dGxpZXJzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzaXplXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTZXJpZXNPdXRsaWVyc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidHlwZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBDaGFydCBzZXJpZXMgb3V0bGllcnMuXG4gKiBBcHBsaWVzIHRvIG1pbGQgb3V0bGllcnMuXG4gKiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcmVmZXIgdG8gdGhlIFtgc2VyaWVzLmV4dHJlbWVzYF0oeyUgc2x1ZyBhcGlfY2hhcnRzX3Nlcmllc2l0ZW1jb21wb25lbnQgJX0jdG9jLWV4dHJlbWVzKSBvcHRpb24uXG4gKi9cbmxldCBTZXJpZXNPdXRsaWVyc0NvbXBvbmVudCA9IGNsYXNzIFNlcmllc091dGxpZXJzQ29tcG9uZW50IGV4dGVuZHMgU2VyaWVzT3V0bGllcnNDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuU2VyaWVzT3V0bGllcnNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1zZXJpZXMtaXRlbS1vdXRsaWVycycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgU2VyaWVzT3V0bGllcnNDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ3RpdGxlJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImFsaWduXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9udFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1hcmdpblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFRpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInRleHRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb2YgdGhlIENoYXJ0IHRpdGxlIG9yIHRleHRcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgdGl0bGVfY2hhcnRfY2hhcnRzICV9KSkuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLXByZXZpZXdcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgIHRlbXBsYXRlOiBgXG4gKiAgICAgICAgPGtlbmRvLWNoYXJ0IFtjYXRlZ29yeUF4aXNdPVwieyBjYXRlZ29yaWVzOiBjYXRlZ29yaWVzIH1cIj5cbiAqICAgICAgICAgICAgPGtlbmRvLWNoYXJ0LXRpdGxlIHRleHQ9XCJHcm9zcyBkb21lc3RpYyBwcm9kdWN0IGdyb3d0aCAvR0RQIGFubnVhbCAlL1wiPjwva2VuZG8tY2hhcnQtdGl0bGU+XG4gKiAgICAgICAgICAgIDxrZW5kby1jaGFydC1sZWdlbmRcbiAqICAgICAgICAgICAgICBwb3NpdGlvbj1cImJvdHRvbVwiXG4gKiAgICAgICAgICAgICAgb3JpZW50YXRpb249XCJob3Jpem9udGFsXCJcbiAqICAgICAgICAgICAgICBhbGlnbj1cImVuZFwiXG4gKiAgICAgICAgICAgICAgYmFja2dyb3VuZD1cInJnYmEoMjU1LCAwLCAwLCAwLjEpXCJcbiAqICAgICAgICAgICAgICBbYm9yZGVyXT1cImJvcmRlck9wdGlvbnNcIlxuICogICAgICAgICAgICAgIFttYXJnaW5dPVwiMTBcIlxuICogICAgICAgICAgICAgIFtwYWRkaW5nXT1cIjEwXCJcbiAqICAgICAgICAgICAgICBbd2lkdGhdPVwiMTUwXCJcbiAqICAgICAgICAgICAgICBbb2Zmc2V0WF09XCIxMVwiXG4gKiAgICAgICAgICAgICAgW29mZnNldFldPVwiLTEwM1wiXG4gKiAgICAgICAgICAgICAgW3JldmVyc2VdPVwidHJ1ZVwiXG4gKiAgICAgICAgICAgICAgW3Zpc2libGVdPVwiaXNWaXNpYmxlXCJcbiAqICAgICAgICAgICAgICA+PC9rZW5kby1jaGFydC1sZWdlbmQ+XG4gKiAgICAgICAgICAgIDxrZW5kby1jaGFydC10b29sdGlwIGZvcm1hdD1cInswfSVcIj48L2tlbmRvLWNoYXJ0LXRvb2x0aXA+XG4gKiAgICAgICAgICAgIDxrZW5kby1jaGFydC1zZXJpZXM+XG4gKiAgICAgICAgICAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0gKm5nRm9yPVwibGV0IGl0ZW0gb2Ygc2VyaWVzXCJcbiAqICAgICAgICAgICAgICAgICAgICB0eXBlPVwibGluZVwiIHN0eWxlPVwic21vb3RoXCIgW2RhdGFdPVwiaXRlbS5kYXRhXCIgW25hbWVdPVwiaXRlbS5uYW1lXCI+XG4gKiAgICAgICAgICAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtPlxuICogICAgICAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICAgICA8L2tlbmRvLWNoYXJ0PlxuICogICAgICAgIDxiciAvPjxiciAvPlxuICogICAgICAgIDxidXR0b24gY2xhc3M9XCJrLWJ1dHRvblwiIChjbGljayk9XCJpc1Zpc2libGU9IWlzVmlzaWJsZVwiPlRvZ2dsZSBMZWdlbmQ8L2J1dHRvbj5cbiAqICAgIGBcbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICBwdWJsaWMgaXNWaXNpYmxlID0gdHJ1ZTtcbiAqICBwdWJsaWMgYm9yZGVyT3B0aW9ucyA9IHtcbiAqICAgIGNvbG9yOiBcInJnYmEoMjU1LCAwLCAwLCAwLjgpXCIsXG4gKiAgICBkYXNoVHlwZTogJ2Rhc2gnLFxuICogICAgd2lkdGg6IDJcbiAqICB9O1xuICpcbiAqIHB1YmxpYyBzZXJpZXM6IGFueVtdID0gW3tcbiAqICAgbmFtZTogXCJJbmRpYVwiLFxuICogICBkYXRhOiBbMy45MDcsIDcuOTQzLCA3Ljg0OCwgOS4yODQsIDkuMjYzLCA5LjgwMSwgMy44OTAsIDguMjM4LCA5LjU1MiwgNi44NTVdXG4gKiB9LCB7XG4gKiAgIG5hbWU6IFwiUnVzc2lhbiBGZWRlcmF0aW9uXCIsXG4gKiAgIGRhdGE6IFs0Ljc0MywgNy4yOTUsIDcuMTc1LCA2LjM3NiwgOC4xNTMsIDguNTM1LCA1LjI0NywgLTcuODMyLCA0LjMsIDQuM11cbiAqIH0sIHtcbiAqICAgbmFtZTogXCJHZXJtYW55XCIsXG4gKiAgIGRhdGE6IFswLjAxMCwgLTAuMzc1LCAxLjE2MSwgMC42ODQsIDMuNywgMy4yNjksIDEuMDgzLCAtNS4xMjcsIDMuNjkwLCAyLjk5NV1cbiAqIH0se1xuICogICBuYW1lOiBcIldvcmxkXCIsXG4gKiAgIGRhdGE6IFsxLjk4OCwgMi43MzMsIDMuOTk0LCAzLjQ2NCwgNC4wMDEsIDMuOTM5LCAxLjMzMywgLTIuMjQ1LCA0LjMzOSwgMi43MjddXG4gKiB9XTtcbiAqICBwdWJsaWMgY2F0ZWdvcmllczogbnVtYmVyW10gPSBbMjAwMiwgMjAwMywgMjAwNCwgMjAwNSwgMjAwNiwgMjAwNywgMjAwOCwgMjAwOSwgMjAxMCwgMjAxMV07XG4gKiB9XG4gKiBgYGBcbiAqL1xubGV0IFRpdGxlQ29tcG9uZW50ID0gY2xhc3MgVGl0bGVDb21wb25lbnQgZXh0ZW5kcyBUaXRsZUNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5UaXRsZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXRpdGxlJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBUaXRsZUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCd0b29sdGlwJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9udFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJvcGFjaXR5XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic2hhcmVkXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb2YgdGhlIENoYXJ0IHNlcmllcyB0b29sdGlwXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIHRvb2x0aXBzX2NoYXJ0X2NoYXJ0cyAlfSkpLlxuICovXG5sZXQgVG9vbHRpcENvbXBvbmVudCA9IGNsYXNzIFRvb2x0aXBDb21wb25lbnQgZXh0ZW5kcyBUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgdGVtcGxhdGVTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLnRlbXBsYXRlU2VydmljZSA9IHRlbXBsYXRlU2VydmljZTtcbiAgICAgICAgdGhpcy5tYXJrQXNWaXNpYmxlKCk7XG4gICAgfVxuICAgIG5nQWZ0ZXJDb250ZW50Q2hlY2tlZCgpIHtcbiAgICAgICAgdGhpcy50ZW1wbGF0ZVNlcnZpY2Uuc2V0VGVtcGxhdGUodGhpcy5zZXJpZXNUb29sdGlwVGVtcGxhdGUgPyB0aGlzLnNlcmllc1Rvb2x0aXBUZW1wbGF0ZS50ZW1wbGF0ZVJlZiA6IG51bGwpO1xuICAgICAgICB0aGlzLnRlbXBsYXRlU2VydmljZS5zZXRTaGFyZWRUZW1wbGF0ZSh0aGlzLnNoYXJlZFRvb2x0aXBUZW1wbGF0ZSA/IHRoaXMuc2hhcmVkVG9vbHRpcFRlbXBsYXRlLnRlbXBsYXRlUmVmIDogbnVsbCk7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZChTZXJpZXNUb29sdGlwVGVtcGxhdGVEaXJlY3RpdmUsIHsgc3RhdGljOiBmYWxzZSB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU2VyaWVzVG9vbHRpcFRlbXBsYXRlRGlyZWN0aXZlKVxuXSwgVG9vbHRpcENvbXBvbmVudC5wcm90b3R5cGUsIFwic2VyaWVzVG9vbHRpcFRlbXBsYXRlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBDb250ZW50Q2hpbGQoU2hhcmVkVG9vbHRpcFRlbXBsYXRlRGlyZWN0aXZlLCB7IHN0YXRpYzogZmFsc2UgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFNoYXJlZFRvb2x0aXBUZW1wbGF0ZURpcmVjdGl2ZSlcbl0sIFRvb2x0aXBDb21wb25lbnQucHJvdG90eXBlLCBcInNoYXJlZFRvb2x0aXBUZW1wbGF0ZVwiLCB2b2lkIDApO1xuVG9vbHRpcENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtdG9vbHRpcCcsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgICAgIFRvb2x0aXBUZW1wbGF0ZVNlcnZpY2VdKVxuXSwgVG9vbHRpcENvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBWYWx1ZUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgQ29sbGVjdGlvbkl0ZW1Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvblNlcnZpY2UgPSBjb2xsZWN0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBWYWx1ZUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJheGlzQ3Jvc3NpbmdWYWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVmFsdWVBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVmFsdWVBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFZhbHVlQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxpbmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFZhbHVlQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1ham9yR3JpZExpbmVzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBWYWx1ZUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYWpvclRpY2tzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBWYWx1ZUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYWpvclVuaXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFZhbHVlQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1heFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVmFsdWVBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWluXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBWYWx1ZUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtaW5vckdyaWRMaW5lc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVmFsdWVBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWlub3JUaWNrc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgVmFsdWVBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWlub3JVbml0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBWYWx1ZUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVmFsdWVBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibmFycm93UmFuZ2VcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFZhbHVlQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhbmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgVmFsdWVBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGxvdEJhbmRzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVmFsdWVBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicmV2ZXJzZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVmFsdWVBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidHlwZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFZhbHVlQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFZhbHVlQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNyb3NzaGFpclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVmFsdWVBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibGFiZWxzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBWYWx1ZUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJub3Rlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVmFsdWVBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidGl0bGVcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBjb21wb25lbnQgZm9yIGEgdmFsdWUgYXhpcy5cbiAqL1xubGV0IFZhbHVlQXhpc0l0ZW1Db21wb25lbnQgPSBjbGFzcyBWYWx1ZUF4aXNJdGVtQ29tcG9uZW50IGV4dGVuZHMgVmFsdWVBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvblNlcnZpY2UgPSBjb2xsZWN0aW9uU2VydmljZTtcbiAgICB9XG59O1xuVmFsdWVBeGlzSXRlbUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBwcm92aWRlcnM6IFtDb25maWd1cmF0aW9uU2VydmljZV0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtdmFsdWUtYXhpcy1pdGVtJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZSxcbiAgICAgICAgQ29sbGVjdGlvblNlcnZpY2VdKVxuXSwgVmFsdWVBeGlzSXRlbUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBWYWx1ZUF4aXNDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBDb2xsZWN0aW9uQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ3ZhbHVlQXhpcycsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uU2VydmljZSA9IGNvbGxlY3Rpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihWYWx1ZUF4aXNJdGVtQ29tcG9uZW50KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgVmFsdWVBeGlzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjaGlsZHJlblwiLCB2b2lkIDApO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBvbmUgb3IgbW9yZSB2YWx1ZSBheGlzIGNvbmZpZ3VyYXRpb24gY29tcG9uZW50cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICB0ZW1wbGF0ZTogYFxuICogICAgIDxrZW5kby1jaGFydD5cbiAqICAgICAgIDxrZW5kby1jaGFydC12YWx1ZS1heGlzPlxuICogICAgICAgICA8a2VuZG8tY2hhcnQtdmFsdWUtYXhpcy1pdGVtPlxuICogICAgICAgICA8L2tlbmRvLWNoYXJ0LXZhbHVlLWF4aXMtaXRlbT5cbiAqICAgICAgICAgPGtlbmRvLWNoYXJ0LXZhbHVlLWF4aXMtaXRlbSBuYW1lPVwic2Vjb25kQXhpc1wiPlxuICogICAgICAgICA8L2tlbmRvLWNoYXJ0LXZhbHVlLWF4aXMtaXRlbT5cbiAqICAgICAgIDwva2VuZG8tY2hhcnQtdmFsdWUtYXhpcz5cbiAqICAgICAgIDxrZW5kby1jaGFydC1zZXJpZXM+XG4gKiAgICAgICAgIDxrZW5kby1jaGFydC1zZXJpZXMtaXRlbSB0eXBlPVwibGluZVwiIFtkYXRhXT1cIlsxLCAyLCAzXVwiPlxuICogICAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtPlxuICogICAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0gdHlwZT1cImxpbmVcIiBbZGF0YV09XCJbMC4xLCAwLjIsIDAuM11cIlxuICogICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXhpcz1cInNlY29uZEF4aXNcIj5cbiAqICAgICAgICAgPC9rZW5kby1jaGFydC1zZXJpZXMtaXRlbT5cbiAqICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzPlxuICogICAgIDwva2VuZG8tY2hhcnQ+XG4gKiAgIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogfVxuICpcbiAqIGBgYFxuICovXG5sZXQgVmFsdWVBeGlzQ29tcG9uZW50ID0gY2xhc3MgVmFsdWVBeGlzQ29tcG9uZW50IGV4dGVuZHMgVmFsdWVBeGlzQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uU2VydmljZSA9IGNvbGxlY3Rpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5WYWx1ZUF4aXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgcHJvdmlkZXJzOiBbQ29sbGVjdGlvblNlcnZpY2VdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXZhbHVlLWF4aXMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlLFxuICAgICAgICBDb2xsZWN0aW9uU2VydmljZV0pXG5dLCBWYWx1ZUF4aXNDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgVmFsdWVBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdjcm9zc2hhaXInLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBWYWx1ZUF4aXNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBWYWx1ZUF4aXNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBWYWx1ZUF4aXNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFZhbHVlQXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFZhbHVlQXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjcm9zc2hhaXIgY29uZmlndXJhdGlvbiBvcHRpb25zIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY3Jvc3NoYWlyc19jaGFydF9jaGFydHMgJX0pKS5cbiAqL1xubGV0IFZhbHVlQXhpc0Nyb3NzaGFpckNvbXBvbmVudCA9IGNsYXNzIFZhbHVlQXhpc0Nyb3NzaGFpckNvbXBvbmVudCBleHRlbmRzIFZhbHVlQXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG59O1xuVmFsdWVBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtdmFsdWUtYXhpcy1pdGVtLWNyb3NzaGFpcicsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgVmFsdWVBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFZhbHVlQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ2Nyb3NzaGFpci50b29sdGlwJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVmFsdWVBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVmFsdWVBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBWYWx1ZUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVmFsdWVBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9udFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVmFsdWVBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBWYWx1ZUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVmFsdWVBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb2YgdGhlIGNyb3NzaGFpciB0b29sdGlwIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgY3Jvc3NoYWlyc19jaGFydF9jaGFydHMgJX0pKS5cbiAqIFRoZSBjcm9zc2hhaXIgdG9vbHRpcCBpcyBkaXNwbGF5ZWQgd2hlbiB0aGUgYHZpc2libGVgIG9wdGlvbiBpcyBzZXQgdG8gYHRydWVgLlxuICovXG5sZXQgVmFsdWVBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCA9IGNsYXNzIFZhbHVlQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnQgZXh0ZW5kcyBWYWx1ZUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlLlxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG59O1xuVmFsdWVBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXZhbHVlLWF4aXMtaXRlbS1jcm9zc2hhaXItdG9vbHRpcCcsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgVmFsdWVBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBWYWx1ZUF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ2xhYmVscycsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFZhbHVlQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVmFsdWVBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFZhbHVlQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgVmFsdWVBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb250ZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBWYWx1ZUF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFZhbHVlQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBWYWx1ZUF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1hcmdpblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFZhbHVlQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWlycm9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBWYWx1ZUF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFZhbHVlQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFZhbHVlQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFZhbHVlQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic2tpcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgVmFsdWVBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzdGVwXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVmFsdWVBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFZhbHVlQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzdWFsXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGF4aXMgbGFiZWxzIGNvbmZpZ3VyYXRpb24uXG4gKi9cbmxldCBWYWx1ZUF4aXNMYWJlbHNDb21wb25lbnQgPSBjbGFzcyBWYWx1ZUF4aXNMYWJlbHNDb21wb25lbnQgZXh0ZW5kcyBWYWx1ZUF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuVmFsdWVBeGlzTGFiZWxzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtdmFsdWUtYXhpcy1pdGVtLWxhYmVscycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgVmFsdWVBeGlzTGFiZWxzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFZhbHVlQXhpc05vdGVzQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdub3RlcycsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgVmFsdWVBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFZhbHVlQXhpc05vdGVzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJsaW5lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBWYWx1ZUF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgVmFsdWVBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc3VhbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVmFsdWVBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImljb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFZhbHVlQXhpc05vdGVzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJsYWJlbFwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSB2YWx1ZSBheGlzIG5vdGVzIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgbm90ZXNfY2hhcnRfY2hhcnRzICV9I3RvYy1heGlzLW5vdGVzKSkuXG4gKi9cbmxldCBWYWx1ZUF4aXNOb3Rlc0NvbXBvbmVudCA9IGNsYXNzIFZhbHVlQXhpc05vdGVzQ29tcG9uZW50IGV4dGVuZHMgVmFsdWVBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuVmFsdWVBeGlzTm90ZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC12YWx1ZS1heGlzLWl0ZW0tbm90ZXMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFZhbHVlQXhpc05vdGVzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFZhbHVlQXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbm90ZXMuaWNvbicsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFZhbHVlQXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVmFsdWVBeGlzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFZhbHVlQXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVmFsdWVBeGlzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0eXBlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVmFsdWVBeGlzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGljb24gb2YgdGhlIG5vdGVzLlxuICovXG5sZXQgVmFsdWVBeGlzTm90ZXNJY29uQ29tcG9uZW50ID0gY2xhc3MgVmFsdWVBeGlzTm90ZXNJY29uQ29tcG9uZW50IGV4dGVuZHMgVmFsdWVBeGlzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcblZhbHVlQXhpc05vdGVzSWNvbkNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXZhbHVlLWF4aXMtaXRlbS1ub3Rlcy1pY29uJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBWYWx1ZUF4aXNOb3Rlc0ljb25Db21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgVmFsdWVBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbm90ZXMubGFiZWwnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBWYWx1ZUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBWYWx1ZUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFZhbHVlQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFZhbHVlQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbnRlbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFZhbHVlQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFZhbHVlQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVmFsdWVBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFZhbHVlQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgVmFsdWVBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBsYWJlbCBvZiB0aGUgbm90ZXMuXG4gKi9cbmxldCBWYWx1ZUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50ID0gY2xhc3MgVmFsdWVBeGlzTm90ZXNMYWJlbENvbXBvbmVudCBleHRlbmRzIFZhbHVlQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuVmFsdWVBeGlzTm90ZXNMYWJlbENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXZhbHVlLWF4aXMtaXRlbS1ub3Rlcy1sYWJlbCcsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgVmFsdWVBeGlzTm90ZXNMYWJlbENvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBWYWx1ZUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcigndGl0bGUnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBWYWx1ZUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVmFsdWVBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgVmFsdWVBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBWYWx1ZUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9udFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVmFsdWVBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1hcmdpblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgVmFsdWVBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFZhbHVlQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgVmFsdWVBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBWYWx1ZUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidGV4dFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFZhbHVlQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFZhbHVlQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXN1YWxcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgdGl0bGUgY29uZmlndXJhdGlvbiBvZiB0aGUgdmFsdWUgYXhpcy5cbiAqL1xubGV0IFZhbHVlQXhpc1RpdGxlQ29tcG9uZW50ID0gY2xhc3MgVmFsdWVBeGlzVGl0bGVDb21wb25lbnQgZXh0ZW5kcyBWYWx1ZUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5WYWx1ZUF4aXNUaXRsZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXZhbHVlLWF4aXMtaXRlbS10aXRsZScsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgVmFsdWVBeGlzVGl0bGVDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgWEF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgQ29sbGVjdGlvbkl0ZW1Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSwgaW50bCwgbG9jYWxlSWQpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubm90aWZ5Q2hhbmdlcyh7IHdlZWtTdGFydERheTogaW50bC5maXJzdERheShsb2NhbGVJZCkgfSk7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWEF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJheGlzQ3Jvc3NpbmdWYWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWEF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBYQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhc2VVbml0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBYQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBYQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxpbmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFhBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFqb3JHcmlkTGluZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFhBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFqb3JUaWNrc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgWEF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYWpvclVuaXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFhBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBYQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWEF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtaW5vckdyaWRMaW5lc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWEF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtaW5vclRpY2tzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBYQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1pbm9yVW5pdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWEF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgWEF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJuYXJyb3dSYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWEF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwYW5lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIFhBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGxvdEJhbmRzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgWEF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJyZXZlcnNlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBYQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInN0YXJ0QW5nbGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFhBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidHlwZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFhBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgWEF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ3ZWVrU3RhcnREYXlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFhBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY3Jvc3NoYWlyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBYQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxhYmVsc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWEF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJub3Rlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWEF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIGNvbXBvbmVudCBmb3IgYW4gWCBheGlzXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFwaV9jaGFydHNfeGF4aXNjb21wb25lbnQgJX0pKS5cbiAqL1xubGV0IFhBeGlzSXRlbUNvbXBvbmVudCA9IGNsYXNzIFhBeGlzSXRlbUNvbXBvbmVudCBleHRlbmRzIFhBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlLCBpbnRsLCBsb2NhbGVJZCkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UsIGludGwsIGxvY2FsZUlkKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuaW50bCA9IGludGw7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgWEF4aXNJdGVtQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjYXRlZ29yaWVzXCIsIHZvaWQgMCk7XG5YQXhpc0l0ZW1Db21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgcHJvdmlkZXJzOiBbQ29uZmlndXJhdGlvblNlcnZpY2VdLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXgtYXhpcy1pdGVtJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19wYXJhbSgzLCBJbmplY3QoTE9DQUxFX0lEKSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZSxcbiAgICAgICAgQ29sbGVjdGlvblNlcnZpY2UsXG4gICAgICAgIEludGxTZXJ2aWNlLCBTdHJpbmddKVxuXSwgWEF4aXNJdGVtQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFhBeGlzQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgQ29sbGVjdGlvbkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCd4QXhpcycsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uU2VydmljZSA9IGNvbGxlY3Rpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihYQXhpc0l0ZW1Db21wb25lbnQpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBRdWVyeUxpc3QpXG5dLCBYQXhpc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY2hpbGRyZW5cIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBBIGNvbGxlY3Rpb24gb2Ygb25lIG9yIG1vcmUgWC1heGlzIGNvbmZpZ3VyYXRpb24gY29tcG9uZW50cy5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHNcbiAqIGltcG9ydCB7IENvbXBvbmVudCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICpcbiAqIF9AQ29tcG9uZW50KHtcbiAqICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiB0ZW1wbGF0ZTogYFxuICogICA8a2VuZG8tY2hhcnQ+XG4gKiAgICAgPGtlbmRvLWNoYXJ0LXgtYXhpcz5cbiAqICAgICAgIDxrZW5kby1jaGFydC14LWF4aXMtaXRlbVxuICogICAgICAgICBbYmFja2dyb3VuZF09XCIncmdiYSgxMDAsIDEwMCwgMTAwLCAwLjIpJ1wiXG4gKiAgICAgICAgIGNvbG9yPVwicmVkXCJcbiAqICAgICAgICAgW25vdGVzXT1cIm5vdGVzQ29uZmlnXCJcbiAqICAgICAgICAgW2Nyb3NzaGFpcl09XCJjcm9zc2hhaXJDb25maWdcIj5cbiAqICAgICAgIDwva2VuZG8tY2hhcnQteC1heGlzLWl0ZW0+XG4gKiAgICAgICA8a2VuZG8tY2hhcnQteC1heGlzLWl0ZW0gbmFtZT1cInNlY29uZEF4aXNcIj5cbiAqICAgICAgIDwva2VuZG8tY2hhcnQteC1heGlzLWl0ZW0+XG4gKiAgICAgPC9rZW5kby1jaGFydC14LWF4aXM+XG4gKiAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICAgIDxrZW5kby1jaGFydC1zZXJpZXMtaXRlbSB0eXBlPVwic2NhdHRlclwiIFtkYXRhXT1cIltbMSwgMl1dXCI+XG4gKiAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtPlxuICogICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcy1pdGVtIHR5cGU9XCJzY2F0dGVyXCIgW2RhdGFdPVwiW1swLjEsIDAuMl1dXCJcbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4QXhpcz1cInNlY29uZEF4aXNcIj5cbiAqICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0+XG4gKiAgICAgPC9rZW5kby1jaGFydC1zZXJpZXM+XG4gKiAgIDwva2VuZG8tY2hhcnQ+XG4gKiBgXG4gKiB9KVxuICogZXhwb3J0IGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiBwdWJsaWMgbm90ZXNDb25maWcgPSB7XG4gKiAgIGRhdGE6IFt7XG4gKiAgICAgICB2YWx1ZTogMC4yLFxuICogICAgICAgdGV4dDogXCJmb29cIlxuICogICAgIH0sIHtcbiAqICAgICAgIHZhbHVlOiAwLjgsXG4gKiAgICAgICB0ZXh0OiBcImJhclwiXG4gKiAgICAgfV0sXG4gKiAgIGxhYmVsOiB7XG4gKiAgICAgY29udGVudDogKGFyZ3M6IGFueSkgPT4gYXJncy5kYXRhSXRlbS50ZXh0LFxuICogICAgIGJhY2tncm91bmQ6ICdyZWQnLFxuICogICAgIGNvbG9yOiAnd2hpdGUnXG4gKiAgIH0sXG4gKiAgIGxpbmU6IHtcbiAqICAgICBjb2xvcjogJ2JsdWUnLFxuICogICAgIGRhc2hUeXBlOiAnZGFzaCcsXG4gKiAgICAgbGVuZ3RoOiAxNTAsXG4gKiAgICAgd2lkdGg6IDJcbiAqICAgfSxcbiAqICAgcG9zaXRpb246ICd0b3AnXG4gKiB9O1xuICpcbiAqIHB1YmxpYyBjcm9zc2hhaXJDb25maWcgPSB7XG4gKiAgIGNvbG9yOiAnZ3JlZW4nLFxuICogICBvcGFjaXR5OiAwLjgsXG4gKiAgIHZpc2libGU6IHRydWUsXG4gKiAgIHdpZHRoOiAzXG4gKiB9O1xuICogfVxuICpcbiAqIGBgYFxuICovXG5sZXQgWEF4aXNDb21wb25lbnQgPSBjbGFzcyBYQXhpc0NvbXBvbmVudCBleHRlbmRzIFhBeGlzQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5jb2xsZWN0aW9uU2VydmljZSA9IGNvbGxlY3Rpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5YQXhpc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBwcm92aWRlcnM6IFtDb2xsZWN0aW9uU2VydmljZV0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQteC1heGlzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZSxcbiAgICAgICAgQ29sbGVjdGlvblNlcnZpY2VdKVxuXSwgWEF4aXNDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgWEF4aXNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ2Nyb3NzaGFpcicsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFhBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgWEF4aXNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm9wYWNpdHlcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBYQXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgWEF4aXNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIndpZHRoXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBYQXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidG9vbHRpcFwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjcm9zc2hhaXIgY29uZmlndXJhdGlvbiBvcHRpb25zXG4gKiAoW3NlZSBleGFtcGxlXSh7JSBzbHVnIGFwaV9jaGFydHNfeGF4aXNjb21wb25lbnQgJX0pKS5cbiAqL1xubGV0IFhBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50ID0gY2xhc3MgWEF4aXNDcm9zc2hhaXJDb21wb25lbnQgZXh0ZW5kcyBYQXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG59O1xuWEF4aXNDcm9zc2hhaXJDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC14LWF4aXMtaXRlbS1jcm9zc2hhaXInLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFhBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFhBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignY3Jvc3NoYWlyLnRvb2x0aXAnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBYQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFhBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBYQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBYQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFhBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9ybWF0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBYQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBhZGRpbmdcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBYQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIG9mIHRoZSBjcm9zc2hhaXIgdG9vbHRpcC5cbiAqIFRoZSBjcm9zc2hhaXIgdG9vbHRpcCBpcyBkaXNwbGF5ZWQgd2hlbiB0aGUgYHZpc2libGVgIG9wdGlvbiBpcyBzZXQgdG8gYHRydWVgLlxuICovXG5sZXQgWEF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50ID0gY2xhc3MgWEF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50IGV4dGVuZHMgWEF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlLlxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG59O1xuWEF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQteC1heGlzLWl0ZW0tY3Jvc3NoYWlyLXRvb2x0aXAnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFhBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBYQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbGFiZWxzJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWEF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFhBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFhBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb2xvclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBYQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29udGVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWEF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImN1bHR1cmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFhBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJkYXRlRm9ybWF0c1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWEF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFhBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFhBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYXJnaW5cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBYQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWlycm9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBYQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWEF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBYQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicm90YXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFhBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJza2lwXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBYQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic3RlcFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFhBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFhBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXN1YWxcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgYXhpcyBsYWJlbHMgY29uZmlndXJhdGlvbi5cbiAqL1xubGV0IFhBeGlzTGFiZWxzQ29tcG9uZW50ID0gY2xhc3MgWEF4aXNMYWJlbHNDb21wb25lbnQgZXh0ZW5kcyBYQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5YQXhpc0xhYmVsc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXgtYXhpcy1pdGVtLWxhYmVscycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgWEF4aXNMYWJlbHNDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgWEF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbm90ZXMnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIFhBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImRhdGFcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFhBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxpbmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFhBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInBvc2l0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFhBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc3VhbFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWEF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiaWNvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWEF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibGFiZWxcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvZiB0aGUgWC1heGlzIG5vdGVzLlxuICogRm9yIGFuIGV4YW1wbGUgb24gdGhlIGJhc2ljIHVzYWdlIG9mIHRoZSBYQXhpc05vdGVzQ29tcG9uZW50LFxuICogcmVmZXIgdG8gdGhlIFtkZW1vIG9uIHRoZSBYQXhpc0NvbXBvbmVudF0oeyUgc2x1ZyBhcGlfY2hhcnRzX3hheGlzY29tcG9uZW50ICV9KVxuICogb3IgdG8gdGhlIGRvY3VtZW50YXRpb24gYWJvdXQgdGhlXG4gKiBbYXhpcyBub3Rlc10oeyUgc2x1ZyBub3Rlc19jaGFydF9jaGFydHMgJX0jdG9jLWF4aXMtbm90ZXMpLlxuICovXG5sZXQgWEF4aXNOb3Rlc0NvbXBvbmVudCA9IGNsYXNzIFhBeGlzTm90ZXNDb21wb25lbnQgZXh0ZW5kcyBYQXhpc05vdGVzQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcblhBeGlzTm90ZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC14LWF4aXMtaXRlbS1ub3RlcycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgWEF4aXNOb3Rlc0NvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBYQXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbm90ZXMuaWNvbicsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFhBeGlzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBYQXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBYQXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWEF4aXNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBYQXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBpY29uIG9mIHRoZSBub3Rlcy5cbiAqL1xubGV0IFhBeGlzTm90ZXNJY29uQ29tcG9uZW50ID0gY2xhc3MgWEF4aXNOb3Rlc0ljb25Db21wb25lbnQgZXh0ZW5kcyBYQXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5YQXhpc05vdGVzSWNvbkNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXgtYXhpcy1pdGVtLW5vdGVzLWljb24nLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFhBeGlzTm90ZXNJY29uQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFhBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbm90ZXMubGFiZWwnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBYQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFhBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBYQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFhBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29udGVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWEF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb250XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBYQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWEF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgWEF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJyb3RhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFhBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBsYWJlbCBvZiB0aGUgbm90ZXMuXG4gKi9cbmxldCBYQXhpc05vdGVzTGFiZWxDb21wb25lbnQgPSBjbGFzcyBYQXhpc05vdGVzTGFiZWxDb21wb25lbnQgZXh0ZW5kcyBYQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuWEF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQteC1heGlzLWl0ZW0tbm90ZXMtbGFiZWwnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFhBeGlzTm90ZXNMYWJlbENvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBYQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCd0aXRsZScsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFhBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFhBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWEF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFhBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFhBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1hcmdpblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWEF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWEF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFhBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBYQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgWEF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBYQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXN1YWxcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgdGl0bGUgY29uZmlndXJhdGlvbiBvZiB0aGUgU2NhdHRlciBDaGFydCBYIGF4aXMuXG4gKi9cbmxldCBYQXhpc1RpdGxlQ29tcG9uZW50ID0gY2xhc3MgWEF4aXNUaXRsZUNvbXBvbmVudCBleHRlbmRzIFhBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuWEF4aXNUaXRsZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXgtYXhpcy1pdGVtLXRpdGxlJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBYQXhpc1RpdGxlQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIENvbGxlY3Rpb25JdGVtQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJheGlzQ3Jvc3NpbmdWYWx1ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBZQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhc2VVbml0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBZQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBZQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxpbmVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFqb3JHcmlkTGluZXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWFqb3JUaWNrc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgWUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtYWpvclVuaXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibWF4XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBZQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1pblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtaW5vckdyaWRMaW5lc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtaW5vclRpY2tzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBZQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1pbm9yVW5pdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJuYW1lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgWUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJuYXJyb3dSYW5nZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwYW5lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBBcnJheSlcbl0sIFlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGxvdEJhbmRzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgWUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJyZXZlcnNlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBZQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBZQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFlBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY3Jvc3NoYWlyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBZQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImxhYmVsc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJub3Rlc1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0aXRsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIGNvbXBvbmVudCBmb3IgdGhlIFkgYXhpc1xuICogKFtzZWUgZXhhbXBsZV0oeyUgc2x1ZyBhcGlfY2hhcnRzX3lheGlzY29tcG9uZW50ICV9KSkuXG4gKi9cbmxldCBZQXhpc0l0ZW1Db21wb25lbnQgPSBjbGFzcyBZQXhpc0l0ZW1Db21wb25lbnQgZXh0ZW5kcyBZQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvblNlcnZpY2UgPSBjb2xsZWN0aW9uU2VydmljZTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQXJyYXkpXG5dLCBZQXhpc0l0ZW1Db21wb25lbnQucHJvdG90eXBlLCBcImNhdGVnb3JpZXNcIiwgdm9pZCAwKTtcbllBeGlzSXRlbUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBwcm92aWRlcnM6IFtDb25maWd1cmF0aW9uU2VydmljZV0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQteS1heGlzLWl0ZW0nLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlLFxuICAgICAgICBDb2xsZWN0aW9uU2VydmljZV0pXG5dLCBZQXhpc0l0ZW1Db21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgWUF4aXNDb21wb25lbnRHZW5lcmF0ZWQgZXh0ZW5kcyBDb2xsZWN0aW9uQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ3lBeGlzJywgY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgQ29udGVudENoaWxkcmVuKFlBeGlzSXRlbUNvbXBvbmVudCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFF1ZXJ5TGlzdClcbl0sIFlBeGlzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjaGlsZHJlblwiLCB2b2lkIDApO1xuXG4vKipcbiAqIEEgY29sbGVjdGlvbiBvZiBvbmUgb3IgbW9yZSBZLWF4aXMgY29uZmlndXJhdGlvbiBjb21wb25lbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICB0ZW1wbGF0ZTogYFxuICogICAgPGtlbmRvLWNoYXJ0PlxuICogICAgIDxrZW5kby1jaGFydC15LWF4aXM+XG4gKiAgICAgICA8a2VuZG8tY2hhcnQteS1heGlzLWl0ZW1cbiAqICAgICAgICAgW2JhY2tncm91bmRdPVwiJ3JnYmEoMTAwLCAxMDAsIDEwMCwgMC4yKSdcIlxuICogICAgICAgICBjb2xvcj1cInJlZFwiXG4gKiAgICAgICAgIFtub3Rlc109XCJub3Rlc0NvbmZpZ1wiXG4gKiAgICAgICAgIFtjcm9zc2hhaXJdPVwiY3Jvc3NoYWlyQ29uZmlnXCI+XG4gKiAgICAgICA8L2tlbmRvLWNoYXJ0LXktYXhpcy1pdGVtPlxuICogICAgICAgPGtlbmRvLWNoYXJ0LXktYXhpcy1pdGVtIG5hbWU9XCJzZWNvbmRBeGlzXCI+XG4gKiAgICAgICA8L2tlbmRvLWNoYXJ0LXktYXhpcy1pdGVtPlxuICogICAgIDwva2VuZG8tY2hhcnQteS1heGlzPlxuICogICAgIDxrZW5kby1jaGFydC1zZXJpZXM+XG4gKiAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0gdHlwZT1cInNjYXR0ZXJcIiBbZGF0YV09XCJbWzEsIDJdXVwiPlxuICogICAgICAgPC9rZW5kby1jaGFydC1zZXJpZXMtaXRlbT5cbiAqICAgICAgIDxrZW5kby1jaGFydC1zZXJpZXMtaXRlbSB0eXBlPVwic2NhdHRlclwiIFtkYXRhXT1cIltbMC4xLCAwLjJdXVwiXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeUF4aXM9XCJzZWNvbmRBeGlzXCI+XG4gKiAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtPlxuICogICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzPlxuICogICA8L2tlbmRvLWNoYXJ0PlxuICogYFxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBDb21wb25lbnQge1xuICogcHVibGljIG5vdGVzQ29uZmlnID0ge1xuICogICBkYXRhOiBbe1xuICogICAgICAgdmFsdWU6IDAuMixcbiAqICAgICAgIHRleHQ6IFwiZm9vXCJcbiAqICAgICB9LCB7XG4gKiAgICAgICB2YWx1ZTogMC44LFxuICogICAgICAgdGV4dDogXCJiYXJcIlxuICogICAgIH1dLFxuICogICAgbGFiZWw6IHtcbiAqICAgICBjb250ZW50OiAoYXJnczogYW55KSA9PiBhcmdzLmRhdGFJdGVtLnRleHQsXG4gKiAgICAgYmFja2dyb3VuZDogJ3JlZCcsXG4gKiAgICAgY29sb3I6ICd3aGl0ZSdcbiAqICAgfSxcbiAqICAgbGluZToge1xuICogICAgIGNvbG9yOiAnYmx1ZScsXG4gKiAgICAgZGFzaFR5cGU6ICdkYXNoJyxcbiAqICAgICBsZW5ndGg6IDE1MCxcbiAqICAgICB3aWR0aDogMlxuICogICB9LFxuICogICBwb3NpdGlvbjogJ3RvcCdcbiAqIH07XG4gKlxuICogcHVibGljIGNyb3NzaGFpckNvbmZpZyA9IHtcbiAqICAgY29sb3I6ICdncmVlbicsXG4gKiAgIG9wYWNpdHk6IDAuOCxcbiAqICAgdmlzaWJsZTogdHJ1ZSxcbiAqICAgd2lkdGg6IDNcbiAqIH07XG4gKiB9XG4gKlxuICogYGBgXG4gKi9cbmxldCBZQXhpc0NvbXBvbmVudCA9IGNsYXNzIFlBeGlzQ29tcG9uZW50IGV4dGVuZHMgWUF4aXNDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UsIGNvbGxlY3Rpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLmNvbGxlY3Rpb25TZXJ2aWNlID0gY29sbGVjdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbllBeGlzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHByb3ZpZGVyczogW0NvbGxlY3Rpb25TZXJ2aWNlXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC15LWF4aXMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlLFxuICAgICAgICBDb2xsZWN0aW9uU2VydmljZV0pXG5dLCBZQXhpc0NvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBZQXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignY3Jvc3NoYWlyJywgY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufVxuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBZQXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwib3BhY2l0eVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBZQXhpc0Nyb3NzaGFpckNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwid2lkdGhcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0b29sdGlwXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogVGhlIGNyb3NzaGFpciBjb25maWd1cmF0aW9uIG9wdGlvbnNcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYXBpX2NoYXJ0c195YXhpc2NvbXBvbmVudCAlfSkpLlxuICovXG5sZXQgWUF4aXNDcm9zc2hhaXJDb21wb25lbnQgPSBjbGFzcyBZQXhpc0Nyb3NzaGFpckNvbXBvbmVudCBleHRlbmRzIFlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubWFya0FzVmlzaWJsZSgpO1xuICAgIH1cbn07XG5ZQXhpc0Nyb3NzaGFpckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXktYXhpcy1pdGVtLWNyb3NzaGFpcicsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgWUF4aXNDcm9zc2hhaXJDb21wb25lbnQpO1xuXG4vKipcbiAqIEBoaWRkZW5cbiAqL1xuY2xhc3MgWUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdjcm9zc2hhaXIudG9vbHRpcCcsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJib3JkZXJcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9udFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgb2YgdGhlIGNyb3NzaGFpciB0b29sdGlwLlxuICogVGhlIGNyb3NzaGFpciB0b29sdGlwIGlzIGRpc3BsYXllZCB3aGVuIHRoZSBgdmlzaWJsZWAgb3B0aW9uIGlzIHNldCB0byBgdHJ1ZWAuXG4gKi9cbmxldCBZQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnQgPSBjbGFzcyBZQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnQgZXh0ZW5kcyBZQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmUuXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubWFya0FzVmlzaWJsZSgpO1xuICAgIH1cbn07XG5ZQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC15LWF4aXMtaXRlbS1jcm9zc2hhaXItdG9vbHRpcCcsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgWUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFlBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdsYWJlbHMnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBZQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYmFja2dyb3VuZFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWUF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFlBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJjb250ZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBZQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY3VsdHVyZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWUF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImRhdGVGb3JtYXRzXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBZQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZm9udFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWUF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1hcmdpblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFlBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtaXJyb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFlBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwYWRkaW5nXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBZQXhpc0xhYmVsc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFlBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJyb3RhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgWUF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInNraXBcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFlBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJzdGVwXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgWUF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc2libGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgWUF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInZpc3VhbFwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBheGlzIGxhYmVscyBjb25maWd1cmF0aW9uLlxuICovXG5sZXQgWUF4aXNMYWJlbHNDb21wb25lbnQgPSBjbGFzcyBZQXhpc0xhYmVsc0NvbXBvbmVudCBleHRlbmRzIFlBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbllBeGlzTGFiZWxzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQteS1heGlzLWl0ZW0tbGFiZWxzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBZQXhpc0xhYmVsc0NvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBZQXhpc05vdGVzQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdub3RlcycsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgWUF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiZGF0YVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWUF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwibGluZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEZ1bmN0aW9uKVxuXSwgWUF4aXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzdWFsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBZQXhpc05vdGVzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJpY29uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBZQXhpc05vdGVzQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJsYWJlbFwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBZIGF4aXMgbm90ZXNcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgYXBpX2NoYXJ0c195YXhpc2NvbXBvbmVudCAlfSkpLlxuICovXG5sZXQgWUF4aXNOb3Rlc0NvbXBvbmVudCA9IGNsYXNzIFlBeGlzTm90ZXNDb21wb25lbnQgZXh0ZW5kcyBZQXhpc05vdGVzQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICAvLyBQbGFjZSBjdXN0b20gcHJvcGVydGllcyBoZXJlXG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbllBeGlzTm90ZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC15LWF4aXMtaXRlbS1ub3RlcycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgWUF4aXNOb3Rlc0NvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBZQXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbm90ZXMuaWNvbicsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFlBeGlzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJiYWNrZ3JvdW5kXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBZQXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBOdW1iZXIpXG5dLCBZQXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic2l6ZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBZQXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBpY29uIG9mIHRoZSBub3Rlcy5cbiAqL1xubGV0IFlBeGlzTm90ZXNJY29uQ29tcG9uZW50ID0gY2xhc3MgWUF4aXNOb3Rlc0ljb25Db21wb25lbnQgZXh0ZW5kcyBZQXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5ZQXhpc05vdGVzSWNvbkNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXktYXhpcy1pdGVtLW5vdGVzLWljb24nLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFlBeGlzTm90ZXNJY29uQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFlBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZCBleHRlbmRzIFNldHRpbmdzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcignbm90ZXMubGFiZWwnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBZQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFlBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiYm9yZGVyXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBZQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImNvbG9yXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBGdW5jdGlvbilcbl0sIFlBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29udGVudFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJmb250XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBZQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvcm1hdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJwb3NpdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgTnVtYmVyKVxuXSwgWUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJyb3RhdGlvblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIFlBeGlzTm90ZXNMYWJlbENvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuXG4vKipcbiAqIFRoZSBsYWJlbCBvZiB0aGUgbm90ZXMuXG4gKi9cbmxldCBZQXhpc05vdGVzTGFiZWxDb21wb25lbnQgPSBjbGFzcyBZQXhpc05vdGVzTGFiZWxDb21wb25lbnQgZXh0ZW5kcyBZQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuWUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQteS1heGlzLWl0ZW0tbm90ZXMtbGFiZWwnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIFlBeGlzTm90ZXNMYWJlbENvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBZQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCd0aXRsZScsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFlBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJhY2tncm91bmRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFlBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImJvcmRlclwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwiY29sb3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIFN0cmluZylcbl0sIFlBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcImZvbnRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFlBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcIm1hcmdpblwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgWUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicGFkZGluZ1wiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgU3RyaW5nKVxuXSwgWUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwicG9zaXRpb25cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE51bWJlcilcbl0sIFlBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQucHJvdG90eXBlLCBcInJvdGF0aW9uXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBZQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ0ZXh0XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBCb29sZWFuKVxuXSwgWUF4aXNUaXRsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBZQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJ2aXN1YWxcIiwgdm9pZCAwKTtcblxuLyoqXG4gKiBUaGUgdGl0bGUgY29uZmlndXJhdGlvbiBvZiB0aGUgU2NhdHRlciBDaGFydCBZIGF4aXMuXG4gKi9cbmxldCBZQXhpc1RpdGxlQ29tcG9uZW50ID0gY2xhc3MgWUF4aXNUaXRsZUNvbXBvbmVudCBleHRlbmRzIFlBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQge1xuICAgIC8vIFBsYWNlIGN1c3RvbSBwcm9wZXJ0aWVzIGhlcmVcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuWUF4aXNUaXRsZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXktYXhpcy1pdGVtLXRpdGxlJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBZQXhpc1RpdGxlQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNsYXNzIFpvb21hYmxlQ29tcG9uZW50R2VuZXJhdGVkIGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCd6b29tYWJsZScsIGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn1cbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFpvb21hYmxlQ29tcG9uZW50R2VuZXJhdGVkLnByb3RvdHlwZSwgXCJtb3VzZXdoZWVsXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBab29tYWJsZUNvbXBvbmVudEdlbmVyYXRlZC5wcm90b3R5cGUsIFwic2VsZWN0aW9uXCIsIHZvaWQgMCk7XG5cbi8qKlxuICogU3BlY2lmaWVzIGlmIHRoZSBDaGFydCBjYW4gYmUgem9vbWVkLlxuICpcbiAqIEBleGFtcGxlXG4gKlxuICogYGBgaHRtbC1uby1ydW5cbiAqIDxrZW5kby1jaGFydD5cbiAqICAgPGtlbmRvLWNoYXJ0LXpvb21hYmxlIFttb3VzZXdoZWVsXT1cImZhbHNlXCI+PC9rZW5kby1jaGFydC16b29tYWJsZT5cbiAqIDwva2VuZG8tY2hhcnQ+XG4gKiBgYGBcbiAqL1xubGV0IFpvb21hYmxlQ29tcG9uZW50ID0gY2xhc3MgWm9vbWFibGVDb21wb25lbnQgZXh0ZW5kcyBab29tYWJsZUNvbXBvbmVudEdlbmVyYXRlZCB7XG4gICAgLy8gUGxhY2UgY3VzdG9tIHByb3BlcnRpZXMgaGVyZVxuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5ab29tYWJsZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LXpvb21hYmxlJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBab29tYWJsZUNvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBDSEFSVF9ESVJFQ1RJVkVTID0gW1xuICAgIENoYXJ0Q29tcG9uZW50LFxuICAgIFRvb2x0aXBQb3B1cENvbXBvbmVudCxcbiAgICBTZXJpZXNUb29sdGlwVGVtcGxhdGVEaXJlY3RpdmUsXG4gICAgU2hhcmVkVG9vbHRpcFRlbXBsYXRlRGlyZWN0aXZlLFxuICAgIENyb3NzaGFpclRvb2x0aXBzQ29udGFpbmVyQ29tcG9uZW50LFxuICAgIENyb3NzaGFpclRvb2x0aXBDb21wb25lbnQsXG4gICAgRG9udXRDZW50ZXJUZW1wbGF0ZURpcmVjdGl2ZSxcbiAgICBBeGlzRGVmYXVsdHNDb21wb25lbnQsXG4gICAgQXhpc0RlZmF1bHRzQ3Jvc3NoYWlyQ29tcG9uZW50LFxuICAgIEF4aXNEZWZhdWx0c0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnQsXG4gICAgQXhpc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50LFxuICAgIEF4aXNEZWZhdWx0c1RpdGxlQ29tcG9uZW50LFxuICAgIENhdGVnb3J5QXhpc0NvbXBvbmVudCxcbiAgICBDYXRlZ29yeUF4aXNDcm9zc2hhaXJDb21wb25lbnQsXG4gICAgQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCxcbiAgICBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50LFxuICAgIENhdGVnb3J5QXhpc0xhYmVsc0NvbXBvbmVudCxcbiAgICBDYXRlZ29yeUF4aXNSYW5nZUxhYmVsc0NvbXBvbmVudCxcbiAgICBDYXRlZ29yeUF4aXNOb3Rlc0NvbXBvbmVudCxcbiAgICBDYXRlZ29yeUF4aXNOb3Rlc0ljb25Db21wb25lbnQsXG4gICAgQ2F0ZWdvcnlBeGlzTm90ZXNMYWJlbENvbXBvbmVudCxcbiAgICBDYXRlZ29yeUF4aXNTZWxlY3RDb21wb25lbnQsXG4gICAgQ2F0ZWdvcnlBeGlzVGl0bGVDb21wb25lbnQsXG4gICAgQ2hhcnRBcmVhQ29tcG9uZW50LFxuICAgIExlZ2VuZENvbXBvbmVudCxcbiAgICBMZWdlbmRJbmFjdGl2ZUl0ZW1zQ29tcG9uZW50LFxuICAgIExlZ2VuZEl0ZW1Db21wb25lbnQsXG4gICAgUGFuZUNvbXBvbmVudCxcbiAgICBQYW5lRGVmYXVsdHNDb21wb25lbnQsXG4gICAgUGFuZURlZmF1bHRzVGl0bGVDb21wb25lbnQsXG4gICAgUGFuZXNDb21wb25lbnQsXG4gICAgUGFuZXNUaXRsZUNvbXBvbmVudCxcbiAgICBQbG90QXJlYUNvbXBvbmVudCxcbiAgICBTZXJpZXNDb21wb25lbnQsXG4gICAgU2VyaWVzRGVmYXVsdHNDb21wb25lbnQsXG4gICAgU2VyaWVzRGVmYXVsdHNMYWJlbHNDb21wb25lbnQsXG4gICAgU2VyaWVzRGVmYXVsdHNMYWJlbHNGcm9tQ29tcG9uZW50LFxuICAgIFNlcmllc0RlZmF1bHRzTGFiZWxzVG9Db21wb25lbnQsXG4gICAgU2VyaWVzRGVmYXVsdHNOb3Rlc0NvbXBvbmVudCxcbiAgICBTZXJpZXNEZWZhdWx0c05vdGVzSWNvbkNvbXBvbmVudCxcbiAgICBTZXJpZXNEZWZhdWx0c05vdGVzTGFiZWxDb21wb25lbnQsXG4gICAgU2VyaWVzRGVmYXVsdHNUb29sdGlwQ29tcG9uZW50LFxuICAgIFNlcmllc0Vycm9yQmFyc0NvbXBvbmVudCxcbiAgICBTZXJpZXNFeHRyZW1lc0NvbXBvbmVudCxcbiAgICBTZXJpZXNIaWdobGlnaHRDb21wb25lbnQsXG4gICAgU2VyaWVzSXRlbUNvbXBvbmVudCxcbiAgICBTZXJpZXNMYWJlbHNDb21wb25lbnQsXG4gICAgU2VyaWVzTGFiZWxzRnJvbUNvbXBvbmVudCxcbiAgICBTZXJpZXNMYWJlbHNUb0NvbXBvbmVudCxcbiAgICBTZXJpZXNNYXJrZXJzQ29tcG9uZW50LFxuICAgIFNlcmllc05vdGVzQ29tcG9uZW50LFxuICAgIFNlcmllc05vdGVzSWNvbkNvbXBvbmVudCxcbiAgICBTZXJpZXNOb3Rlc0xhYmVsQ29tcG9uZW50LFxuICAgIFNlcmllc091dGxpZXJzQ29tcG9uZW50LFxuICAgIFNlcmllc1Rvb2x0aXBDb21wb25lbnQsXG4gICAgVGl0bGVDb21wb25lbnQsXG4gICAgVG9vbHRpcENvbXBvbmVudCxcbiAgICBWYWx1ZUF4aXNDb21wb25lbnQsXG4gICAgVmFsdWVBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50LFxuICAgIFZhbHVlQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnQsXG4gICAgVmFsdWVBeGlzSXRlbUNvbXBvbmVudCxcbiAgICBWYWx1ZUF4aXNMYWJlbHNDb21wb25lbnQsXG4gICAgVmFsdWVBeGlzTm90ZXNDb21wb25lbnQsXG4gICAgVmFsdWVBeGlzTm90ZXNJY29uQ29tcG9uZW50LFxuICAgIFZhbHVlQXhpc05vdGVzTGFiZWxDb21wb25lbnQsXG4gICAgVmFsdWVBeGlzVGl0bGVDb21wb25lbnQsXG4gICAgWEF4aXNDb21wb25lbnQsXG4gICAgWEF4aXNDcm9zc2hhaXJDb21wb25lbnQsXG4gICAgWEF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50LFxuICAgIFhBeGlzSXRlbUNvbXBvbmVudCxcbiAgICBYQXhpc0xhYmVsc0NvbXBvbmVudCxcbiAgICBYQXhpc05vdGVzQ29tcG9uZW50LFxuICAgIFhBeGlzTm90ZXNJY29uQ29tcG9uZW50LFxuICAgIFhBeGlzTm90ZXNMYWJlbENvbXBvbmVudCxcbiAgICBYQXhpc1RpdGxlQ29tcG9uZW50LFxuICAgIFlBeGlzQ29tcG9uZW50LFxuICAgIFlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50LFxuICAgIFlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCxcbiAgICBZQXhpc0l0ZW1Db21wb25lbnQsXG4gICAgWUF4aXNMYWJlbHNDb21wb25lbnQsXG4gICAgWUF4aXNOb3Rlc0NvbXBvbmVudCxcbiAgICBZQXhpc05vdGVzSWNvbkNvbXBvbmVudCxcbiAgICBZQXhpc05vdGVzTGFiZWxDb21wb25lbnQsXG4gICAgWUF4aXNUaXRsZUNvbXBvbmVudCxcbiAgICBab29tYWJsZUNvbXBvbmVudFxuXTtcblxuLy8gUmUtZXhwb3J0IGV2ZW50IHR5cGVzXG5cbi8qKlxuICogVGhlIGFyZ3VtZW50cyBmb3IgdGhlIGBuYXZpZ2F0b3JGaWx0ZXJgIGV2ZW50LlxuICovXG5jbGFzcyBOYXZpZ2F0b3JGaWx0ZXJFdmVudCBleHRlbmRzIEJhc2VFdmVudCB7XG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0cyB0aGUgZXZlbnQgYXJndW1lbnRzIGZyb20gYSByYXcgb2JqZWN0LlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGUsIHNlbmRlcikge1xuICAgICAgICBzdXBlcihzZW5kZXIpO1xuICAgICAgICB0aGlzLmZyb20gPSBlLmZyb207XG4gICAgICAgIHRoaXMudG8gPSBlLnRvO1xuICAgIH1cbn1cblxuLy8gUmUtZXhwb3J0IGV2ZW50IHR5cGVzXG5cbi8qKlxuICogQGhpZGRlblxuICovXG5sZXQgUm9vdENvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY2xhc3MgUm9vdENvbmZpZ3VyYXRpb25TZXJ2aWNlIGV4dGVuZHMgQ29uZmlndXJhdGlvblNlcnZpY2Uge1xufTtcblJvb3RDb25maWd1cmF0aW9uU2VydmljZSA9IF9fZGVjb3JhdGUoW1xuICAgIEluamVjdGFibGUoKVxuXSwgUm9vdENvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcblxuY29uc3QgRVZFTlRfTUFQJDEgPSB7XG4gICAgbmF2aWdhdG9yRmlsdGVyOiBOYXZpZ2F0b3JGaWx0ZXJFdmVudFxufTtcbi8qKlxuICogQGhpZGRlblxuICovXG5jbGFzcyBTdG9ja0luc3RhbmNlRXZlbnRTZXJ2aWNlIGV4dGVuZHMgSW5zdGFuY2VFdmVudFNlcnZpY2Uge1xuICAgIGNyZWF0ZShuYW1lLCBhcmdzLCBzZW5kZXIpIHtcbiAgICAgICAgaWYgKEVWRU5UX01BUCQxW25hbWVdKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IEVWRU5UX01BUCQxW25hbWVdKGFyZ3MsIHNlbmRlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1cGVyLmNyZWF0ZShuYW1lLCBhcmdzLCBzZW5kZXIpO1xuICAgIH1cbn1cblxuY29uc3QgTkFWSUdBVE9SX0RFRkFVTFRTID0ge1xuICAgIGF1dG9CaW5kRWxlbWVudHM6IHRydWUsXG4gICAgbGl2ZURyYWc6IGZhbHNlLFxuICAgIHBhcnRpYWxSZWRyYXc6IHRydWVcbn07XG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby1hY2Nlc3MtbWlzc2luZy1tZW1iZXIgKi9cbi8qKlxuICogVGhlIHJvb3QgU3RvY2tDaGFydCBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICA8a2VuZG8tc3RvY2tjaGFydD5cbiAqICAgICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcz5cbiAqICAgICAgICAgICAgIDxrZW5kby1jaGFydC1zZXJpZXMtaXRlbSB0eXBlPVwibGluZVwiIFtkYXRhXT1cImRhdGFcIiBmaWVsZD1cInZhbHVlXCIgY2F0ZWdvcnlGaWVsZD1cImRhdGVcIj5cbiAqICAgICAgICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzLWl0ZW0+XG4gKiAgICAgICAgIDwva2VuZG8tY2hhcnQtc2VyaWVzPlxuICogICAgICAgICA8a2VuZG8tY2hhcnQtbmF2aWdhdG9yPlxuICogICAgICAgICAgICAgPGtlbmRvLWNoYXJ0LW5hdmlnYXRvci1zZWxlY3QgdG89XCIyMDE3LzAyLzAxXCI+XG4gKiAgICAgICAgICAgICA8L2tlbmRvLWNoYXJ0LW5hdmlnYXRvci1zZWxlY3Q+XG4gKiAgICAgICAgICAgICA8a2VuZG8tY2hhcnQtbmF2aWdhdG9yLXNlcmllcz5cbiAqICAgICAgICAgICAgICAgICA8a2VuZG8tY2hhcnQtbmF2aWdhdG9yLXNlcmllcy1pdGVtIHR5cGU9XCJhcmVhXCIgW2RhdGFdPVwiZGF0YVwiIGZpZWxkPVwidmFsdWVcIiBjYXRlZ29yeUZpZWxkPVwiZGF0ZVwiPlxuICogICAgICAgICAgICAgICAgIDwva2VuZG8tY2hhcnQtbmF2aWdhdG9yLXNlcmllcy1pdGVtPlxuICogICAgICAgICAgICAgPC9rZW5kby1jaGFydC1uYXZpZ2F0b3Itc2VyaWVzPlxuICogICAgICAgICA8L2tlbmRvLWNoYXJ0LW5hdmlnYXRvcj5cbiAqICAgICA8L2tlbmRvLXN0b2NrY2hhcnQ+XG4gKiAgIGBcbiAqIH0pXG4gKiBjbGFzcyBBcHBDb21wb25lbnQge1xuICogICBwdWJsaWMgZGF0YTogYW55W10gPSBbXTtcbiAqXG4gKiAgIGNvbnN0cnVjdG9yKCkge1xuICogICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCAxMDA7IGlkeCsrKSB7XG4gKiAgICAgICAgICB0aGlzLmRhdGEucHVzaCh7XG4gKiAgICAgICAgICAgICAgZGF0ZTogbmV3IERhdGUoMjAxNywgMCwgaWR4KSxcbiAqICAgICAgICAgICAgICB2YWx1ZTogTWF0aC5yYW5kb20oKSAqIDEwMFxuICogICAgICAgICAgfSk7XG4gKiAgICAgIH1cbiAqICAgfVxuICogfVxuICpcbiAqIGBgYFxuICovXG5sZXQgU3RvY2tDaGFydENvbXBvbmVudCA9IGNsYXNzIFN0b2NrQ2hhcnRDb21wb25lbnQgZXh0ZW5kcyBDaGFydENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UsIHRoZW1lU2VydmljZSwgZWxlbWVudCwgaW50bCwgbG9jYWxpemF0aW9uU2VydmljZSwgbmdab25lLCBpbnN0YW5jZUV2ZW50U2VydmljZSwgY2hhbmdlRGV0ZWN0b3IsIHJlbmRlcmVyKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCB0aGVtZVNlcnZpY2UsIGVsZW1lbnQsIGludGwsIGxvY2FsaXphdGlvblNlcnZpY2UsIG5nWm9uZSwgaW5zdGFuY2VFdmVudFNlcnZpY2UsIGNoYW5nZURldGVjdG9yLCByZW5kZXJlcik7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy50aGVtZVNlcnZpY2UgPSB0aGVtZVNlcnZpY2U7XG4gICAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICAgIHRoaXMuaW50bCA9IGludGw7XG4gICAgICAgIHRoaXMubG9jYWxpemF0aW9uU2VydmljZSA9IGxvY2FsaXphdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubmdab25lID0gbmdab25lO1xuICAgICAgICB0aGlzLmluc3RhbmNlRXZlbnRTZXJ2aWNlID0gaW5zdGFuY2VFdmVudFNlcnZpY2U7XG4gICAgICAgIHRoaXMuY2hhbmdlRGV0ZWN0b3IgPSBjaGFuZ2VEZXRlY3RvcjtcbiAgICAgICAgdGhpcy5yZW5kZXJlciA9IHJlbmRlcmVyO1xuICAgICAgICAvKipcbiAgICAgICAgICogRmlyZXMgd2hlbiB0aGUgbmF2aWdhdG9yIHJhbmdlIGlzIGNoYW5nZWQuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLm5hdmlnYXRvckZpbHRlciA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcbiAgICAgICAgdGhpcy5yZWRyYXdTbGF2ZXMgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5ob3N0Q2xhc3NlcyA9IFsnay1jaGFydCcsICdrLXN0b2NrY2hhcnQnXTtcbiAgICAgICAgdmFsaWRhdGVQYWNrYWdlKHBhY2thZ2VNZXRhZGF0YSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIElmIGNhbGxlZCwgdGhlIG5hdmlnYXRvciBwYW5lIGlzIG5vdCByZWRyYXduIHRoZSBuZXh0IHRpbWUgdGhlIFN0b2NrQ2hhcnQgb3B0aW9ucyBhcmUgdXBkYXRlZC5cbiAgICAgKiBUaGUgbWV0aG9kIGlzIHVzZWZ1bCBpZiB5b3UgbmVlZCB0byB1cGRhdGUgb25seSB0aGUgbWFpbiBzZXJpZXMgZGF0YSBmb3IgdGhlIHNlbGVjdGVkIHBlcmlvZC5cbiAgICAgKi9cbiAgICBza2lwTmF2aWdhdG9yUmVkcmF3KCkge1xuICAgICAgICB0aGlzLnJlZHJhd1NsYXZlcyA9IHRydWU7XG4gICAgfVxuICAgIGNyZWF0ZUluc3RhbmNlKGVsZW1lbnQsIG9ic2VydmVyKSB7XG4gICAgICAgIHRoaXMuYXBwbHlOYXZpZ2F0b3JEZWZhdWx0cygpO1xuICAgICAgICBpZiAodGhpcy5pc0Rldk1vZGUoKSAmJiAodGhpcy5vcHRpb25zLnpvb21hYmxlIHx8IHRoaXMub3B0aW9ucy5wYW5uYWJsZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVGhlIHBhbm5hYmxlIGFuZCB6b29tYWJsZSBvcHRpb25zIGFyZSBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBTdG9ja0NoYXJ0IGNvbXBvbmVudC4nKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IFN0b2NrQ2hhcnQoZWxlbWVudCwgdGhpcy5vcHRpb25zLCB0aGlzLnRoZW1lLCB7XG4gICAgICAgICAgICBpbnRsU2VydmljZTogdGhpcy5pbnRsLFxuICAgICAgICAgICAgb2JzZXJ2ZXI6IG9ic2VydmVyLFxuICAgICAgICAgICAgcnRsOiB0aGlzLnJ0bCxcbiAgICAgICAgICAgIHNlbmRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlT3B0aW9ucygpIHtcbiAgICAgICAgdGhpcy5hcHBseU5hdmlnYXRvckRlZmF1bHRzKCk7XG4gICAgICAgIGlmICh0aGlzLnJlZHJhd1NsYXZlcykge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5hcHBseU9wdGlvbnModGhpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UuYmluZENhdGVnb3JpZXMoKTtcbiAgICAgICAgICAgIHRoaXMuaW5zdGFuY2UubmF2aWdhdG9yLnJlZHJhd1NsYXZlcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRPcHRpb25zKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZWRyYXdTbGF2ZXMgPSBmYWxzZTtcbiAgICB9XG4gICAgYXBwbHlOYXZpZ2F0b3JEZWZhdWx0cygpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zLm5hdmlnYXRvciA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMub3B0aW9ucy5uYXZpZ2F0b3IsIE5BVklHQVRPUl9ERUZBVUxUUyk7XG4gICAgfVxuICAgIGlzRGV2TW9kZSgpIHtcbiAgICAgICAgcmV0dXJuIGlzRGV2TW9kZSgpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTdG9ja0NoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJuYXZpZ2F0b3JcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIFN0b2NrQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcInBhbm5hYmxlXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBTdG9ja0NoYXJ0Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ6b29tYWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgT3V0cHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEV2ZW50RW1pdHRlcilcbl0sIFN0b2NrQ2hhcnRDb21wb25lbnQucHJvdG90eXBlLCBcIm5hdmlnYXRvckZpbHRlclwiLCB2b2lkIDApO1xuU3RvY2tDaGFydENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBleHBvcnRBczogJ2tlbmRvU3RvY2tDaGFydCcsXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgICAgICAgICBUb29sdGlwVGVtcGxhdGVTZXJ2aWNlLFxuICAgICAgICAgICAgeyBwcm92aWRlOiBSb290Q29uZmlndXJhdGlvblNlcnZpY2UsIHVzZUV4aXN0aW5nOiBDb25maWd1cmF0aW9uU2VydmljZSB9LFxuICAgICAgICAgICAgU3RvY2tJbnN0YW5jZUV2ZW50U2VydmljZSxcbiAgICAgICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogTDEwTl9QUkVGSVgsXG4gICAgICAgICAgICAgICAgdXNlVmFsdWU6ICdrZW5kby5jaGFydCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1zdG9ja2NoYXJ0JyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGRpdiAjc3VyZmFjZSBjbGFzcz1cImstY2hhcnQtc3VyZmFjZVwiPjwvZGl2PlxuICAgICAgICA8a2VuZG8tY2hhcnQtY3Jvc3NoYWlyLXRvb2x0aXBzLWNvbnRhaW5lciBbcG9wdXBTZXR0aW5nc109XCJwb3B1cFNldHRpbmdzXCI+XG4gICAgICAgIDwva2VuZG8tY2hhcnQtY3Jvc3NoYWlyLXRvb2x0aXBzLWNvbnRhaW5lcj5cbiAgICAgICAgPGtlbmRvLWNoYXJ0LXRvb2x0aXAtcG9wdXAgKGxlYXZlKT1cInRvb2x0aXBNb3VzZWxlYXZlKCRldmVudClcIiBbcG9wdXBTZXR0aW5nc109XCJwb3B1cFNldHRpbmdzXCI+XG4gICAgICAgIDwva2VuZG8tY2hhcnQtdG9vbHRpcC1wb3B1cD5cbiAgICAgICAgPGtlbmRvLXJlc2l6ZS1zZW5zb3IgKHJlc2l6ZSk9XCJvblJlc2l6ZSgkZXZlbnQpXCI+PC9rZW5kby1yZXNpemUtc2Vuc29yPlxuICAgIGBcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlLFxuICAgICAgICBUaGVtZVNlcnZpY2UsXG4gICAgICAgIEVsZW1lbnRSZWYsXG4gICAgICAgIEludGxTZXJ2aWNlLFxuICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICBOZ1pvbmUsXG4gICAgICAgIFN0b2NrSW5zdGFuY2VFdmVudFNlcnZpY2UsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBSZW5kZXJlcjJdKVxuXSwgU3RvY2tDaGFydENvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBQUkVGSVggPSBuZXcgSW5qZWN0aW9uVG9rZW4oJ2NvbmZpZ3VyYXRpb24gcHJlZml4Jyk7XG4vKipcbiAqIEBoaWRkZW5cbiAqL1xubGV0IFByZWZpeENvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY2xhc3MgUHJlZml4Q29uZmlndXJhdGlvblNlcnZpY2UgZXh0ZW5kcyBDb25maWd1cmF0aW9uU2VydmljZSB7XG4gICAgY29uc3RydWN0b3Iocm9vdFNlcnZpY2UsIHByZWZpeCwgbmdab25lKSB7XG4gICAgICAgIHN1cGVyKG5nWm9uZSk7XG4gICAgICAgIHRoaXMucm9vdFNlcnZpY2UgPSByb290U2VydmljZTtcbiAgICAgICAgdGhpcy5wcmVmaXggPSBwcmVmaXg7XG4gICAgfVxuICAgIHB1c2goc3RvcmUpIHtcbiAgICAgICAgdGhpcy5yb290U2VydmljZS5ub3RpZnkobmV3IENoYW5nZSh0aGlzLnByZWZpeCwgc3RvcmUpKTtcbiAgICB9XG4gICAgbm90aWZ5KGNoYW5nZSkge1xuICAgICAgICBjaGFuZ2Uua2V5ID0gdGhpcy5wcmVmaXggKyAoY2hhbmdlLmtleSA/IGAuJHtjaGFuZ2Uua2V5fWAgOiAnJyk7XG4gICAgICAgIHRoaXMucm9vdFNlcnZpY2Uubm90aWZ5KGNoYW5nZSk7XG4gICAgfVxufTtcblByZWZpeENvbmZpZ3VyYXRpb25TZXJ2aWNlID0gX19kZWNvcmF0ZShbXG4gICAgSW5qZWN0YWJsZSgpLFxuICAgIF9fcGFyYW0oMCwgSW5qZWN0KFJvb3RDb25maWd1cmF0aW9uU2VydmljZSkpLFxuICAgIF9fcGFyYW0oMSwgSW5qZWN0KFBSRUZJWCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbUm9vdENvbmZpZ3VyYXRpb25TZXJ2aWNlLCBTdHJpbmcsIE5nWm9uZV0pXG5dLCBQcmVmaXhDb25maWd1cmF0aW9uU2VydmljZSk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvZiB0aGUgbmF2aWdhdG9yXG4gKiAoW3NlZSBydW5uYWJsZSBleGFtcGxlXSh7JSBzbHVnIG92ZXJ2aWV3X3N0b2NrY2hhcnRfY2hhcnRzICV9I3RvYy1uYXZpZ2F0b3IpKS5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtbm8tcnVuXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgICAgc2VsZWN0b3I6ICdteS1hcHAnLFxuICogICAgICAgdGVtcGxhdGU6IGBcbiAqICAgICAgICAgPGtlbmRvLXN0b2NrY2hhcnQgKG5hdmlnYXRvckZpbHRlcik9XCJvbk5hdmlnYXRvckZpbHRlcigkZXZlbnQpXCI+XG4gKiAgICAgICAgICAgICA8a2VuZG8tY2hhcnQtc2VyaWVzPlxuICogICAgICAgICAgICAgICAgPGtlbmRvLWNoYXJ0LXNlcmllcy1pdGVtXG4gKiAgICAgICAgICAgICAgICB0eXBlPVwiY2FuZGxlc3RpY2tcIlxuICogICAgICAgICAgICAgICAgIFtkYXRhXT1cInNlcmllc0RhdGFcIlxuICogICAgICAgICAgICAgICAgIG9wZW5GaWVsZD1cIk9wZW5cIlxuICogICAgICAgICAgICAgICAgIGNsb3NlRmllbGQ9XCJDbG9zZVwiXG4gKiAgICAgICAgICAgICAgICAgbG93RmllbGQ9XCJMb3dcIlxuICogICAgICAgICAgICAgICAgIGhpZ2hGaWVsZD1cIkhpZ2hcIlxuICogICAgICAgICAgICAgICAgIGNhdGVnb3J5RmllbGQ9XCJEYXRlXCI+XG4gKiAgICAgICAgICAgICA8L2tlbmRvLWNoYXJ0LXNlcmllcy1pdGVtPlxuICogICAgICAgICAgPC9rZW5kby1jaGFydC1zZXJpZXM+XG4gKiAgICAgICAgICA8a2VuZG8tY2hhcnQtbmF2aWdhdG9yXG4gKiAgICAgICAgICAgIFtjYXRlZ29yeUF4aXNdPVwiY2F0ZWdvcnlBeGlzT3B0aW9uc1wiXG4gKiAgICAgICAgICAgIFtoaW50XT1cImhpbnRPcHRpb25zXCJcbiAqICAgICAgICAgICAgW3BhbmVdPVwicGFuZU9wdGlvbnNcIlxuICogICAgICAgICAgICBbdmlzaWJsZV09XCJpc1Zpc2libGVcIj5cbiAqICAgICAgICAgICAgPGtlbmRvLWNoYXJ0LW5hdmlnYXRvci1zZWxlY3QgW2Zyb21dPVwiZnJvbVwiIFt0b109XCJ0b1wiPlxuICogICAgICAgICAgICA8L2tlbmRvLWNoYXJ0LW5hdmlnYXRvci1zZWxlY3Q+XG4gKiAgICAgICAgICAgIDxrZW5kby1jaGFydC1uYXZpZ2F0b3Itc2VyaWVzPlxuICogICAgICAgICAgICAgIDxrZW5kby1jaGFydC1uYXZpZ2F0b3Itc2VyaWVzLWl0ZW0gdHlwZT1cImFyZWFcIiBbZGF0YV09XCJuYXZpZ2F0b3JEYXRhXCIgZmllbGQ9XCJDbG9zZVwiIGNhdGVnb3J5RmllbGQ9XCJEYXRlXCI+XG4gKiAgICAgICAgICAgICAgPC9rZW5kby1jaGFydC1uYXZpZ2F0b3Itc2VyaWVzLWl0ZW0+XG4gKiAgICAgICAgICAgPC9rZW5kby1jaGFydC1uYXZpZ2F0b3Itc2VyaWVzPlxuICogICAgICAgICAgPC9rZW5kby1jaGFydC1uYXZpZ2F0b3I+XG4gKiAgICAgICAgPC9rZW5kby1zdG9ja2NoYXJ0PlxuICogICAgICAgIDxiciAvPjxiciAvPlxuICogICAgICAgIDxidXR0b24gY2xhc3M9XCJrLWJ1dHRvblwiIChjbGljayk9XCJpc1Zpc2libGUgPSAhaXNWaXNpYmxlXCI+VG9nZ2xlIE5hdmlnYXRvcjwvYnV0dG9uPlxuICogICAgYFxuICogfSlcbiAqIGBgYFxuICovXG5sZXQgTmF2aWdhdG9yQ29tcG9uZW50ID0gY2xhc3MgTmF2aWdhdG9yQ29tcG9uZW50IGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCcnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgQm9vbGVhbilcbl0sIE5hdmlnYXRvckNvbXBvbmVudC5wcm90b3R5cGUsIFwidmlzaWJsZVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmF2aWdhdG9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjYXRlZ29yeUF4aXNcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5hdmlnYXRvckNvbXBvbmVudC5wcm90b3R5cGUsIFwiaGludFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmF2aWdhdG9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJwYW5lXCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBPYmplY3QpXG5dLCBOYXZpZ2F0b3JDb21wb25lbnQucHJvdG90eXBlLCBcInNlbGVjdFwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgT2JqZWN0KVxuXSwgTmF2aWdhdG9yQ29tcG9uZW50LnByb3RvdHlwZSwgXCJzZXJpZXNcIiwgdm9pZCAwKTtcbk5hdmlnYXRvckNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IFBSRUZJWCwgdXNlVmFsdWU6ICduYXZpZ2F0b3InIH0sIHsgcHJvdmlkZTogQ29uZmlndXJhdGlvblNlcnZpY2UsIHVzZUNsYXNzOiBQcmVmaXhDb25maWd1cmF0aW9uU2VydmljZSB9XSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1uYXZpZ2F0b3InLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIE5hdmlnYXRvckNvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gY29tcG9uZW50IG9mIHRoZSBuYXZpZ2F0b3IgY2F0ZWdvcnkgYXhpcy5cbiAqXG4gKiBAZXhhbXBsZVxuICpcbiAqIGBgYGh0bWwtbm8tcnVuXG4gKiA8a2VuZG8tc3RvY2tjaGFydD5cbiAqICAgPGtlbmRvLWNoYXJ0LW5hdmlnYXRvcj5cbiAqICAgICA8a2VuZG8tY2hhcnQtbmF2aWdhdG9yLWNhdGVnb3J5LWF4aXNcbiAqICAgICAgIGNvbG9yPVwibWFyb29uXCJcbiAqICAgICAgIFtsYWJlbHNdPVwie2NvbG9yOiAnZ3JlZW4nfVwiPlxuICogICAgIDwva2VuZG8tY2hhcnQtbmF2aWdhdG9yLWNhdGVnb3J5LWF4aXM+XG4gKiAgIDwva2VuZG8tY2hhcnQtbmF2aWdhdG9yPlxuICogPC9rZW5kby1zdG9ja2NoYXJ0PlxuICogYGBgXG4gKi9cbmxldCBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNDb21wb25lbnQgPSBjbGFzcyBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNDb21wb25lbnQgZXh0ZW5kcyBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgaW50bCwgbG9jYWxlSWQpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UsIG51bGwsIGludGwsIGxvY2FsZUlkKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5OYXZpZ2F0b3JDYXRlZ29yeUF4aXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgcHJvdmlkZXJzOiBbe1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IFBSRUZJWCxcbiAgICAgICAgICAgICAgICB1c2VWYWx1ZTogJ25hdmlnYXRvci5jYXRlZ29yeUF4aXMnXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZTogQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgICAgICAgICAgICAgdXNlQ2xhc3M6IFByZWZpeENvbmZpZ3VyYXRpb25TZXJ2aWNlXG4gICAgICAgICAgICB9XSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1uYXZpZ2F0b3ItY2F0ZWdvcnktYXhpcycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fcGFyYW0oMiwgSW5qZWN0KExPQ0FMRV9JRCkpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgICAgIEludGxTZXJ2aWNlLCBTdHJpbmddKVxuXSwgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIG9mIHRoZSBjcm9zc2hhaXIuXG4gKi9cbmxldCBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNDcm9zc2hhaXJDb21wb25lbnQgPSBjbGFzcyBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNDcm9zc2hhaXJDb21wb25lbnQgZXh0ZW5kcyBDYXRlZ29yeUF4aXNDcm9zc2hhaXJDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5OYXZpZ2F0b3JDYXRlZ29yeUF4aXNDcm9zc2hhaXJDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1uYXZpZ2F0b3ItY2F0ZWdvcnktYXhpcy1jcm9zc2hhaXInLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIE5hdmlnYXRvckNhdGVnb3J5QXhpc0Nyb3NzaGFpckNvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyBvZiB0aGUgY3Jvc3NoYWlyIHRvb2x0aXAuXG4gKiBUaGUgY3Jvc3NoYWlyIHRvb2x0aXAgaXMgZGlzcGxheWVkIHdoZW4gdGhlIGB2aXNpYmxlYCBvcHRpb24gaXMgc2V0IHRvIGB0cnVlYC5cbiAqL1xubGV0IE5hdmlnYXRvckNhdGVnb3J5QXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnQgPSBjbGFzcyBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50IGV4dGVuZHMgQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbk5hdmlnYXRvckNhdGVnb3J5QXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1uYXZpZ2F0b3ItY2F0ZWdvcnktYXhpcy1jcm9zc2hhaXItdG9vbHRpcCcsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIGNvbmZpZ3VyYXRpb24gb2YgdGhlIGF4aXMgbGFiZWxzLlxuICovXG5sZXQgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzTGFiZWxzQ29tcG9uZW50ID0gY2xhc3MgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzTGFiZWxzQ29tcG9uZW50IGV4dGVuZHMgQ2F0ZWdvcnlBeGlzTGFiZWxzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzTGFiZWxzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbmF2aWdhdG9yLWNhdGVnb3J5LWF4aXMtbGFiZWxzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIG9mIHRoZSBjYXRlZ29yeSBheGlzIG5vdGVzLlxuICovXG5sZXQgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzTm90ZXNDb21wb25lbnQgPSBjbGFzcyBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNOb3Rlc0NvbXBvbmVudCBleHRlbmRzIENhdGVnb3J5QXhpc05vdGVzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzTm90ZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1uYXZpZ2F0b3ItY2F0ZWdvcnktYXhpcy1ub3RlcycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzTm90ZXNDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBpY29uIG9mIHRoZSBub3Rlcy5cbiAqL1xubGV0IE5hdmlnYXRvckNhdGVnb3J5QXhpc05vdGVzSWNvbkNvbXBvbmVudCA9IGNsYXNzIE5hdmlnYXRvckNhdGVnb3J5QXhpc05vdGVzSWNvbkNvbXBvbmVudCBleHRlbmRzIENhdGVnb3J5QXhpc05vdGVzSWNvbkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbk5hdmlnYXRvckNhdGVnb3J5QXhpc05vdGVzSWNvbkNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LW5hdmlnYXRvci1jYXRlZ29yeS1heGlzLW5vdGVzLWljb24nLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIE5hdmlnYXRvckNhdGVnb3J5QXhpc05vdGVzSWNvbkNvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIGxhYmVsIG9mIHRoZSBub3Rlcy5cbiAqL1xubGV0IE5hdmlnYXRvckNhdGVnb3J5QXhpc05vdGVzTGFiZWxDb21wb25lbnQgPSBjbGFzcyBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50IGV4dGVuZHMgQ2F0ZWdvcnlBeGlzTm90ZXNMYWJlbENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbk5hdmlnYXRvckNhdGVnb3J5QXhpc05vdGVzTGFiZWxDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1uYXZpZ2F0b3ItY2F0ZWdvcnktYXhpcy1ub3Rlcy1sYWJlbCcsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzTm90ZXNMYWJlbENvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIHNlbGVjdGVkIGF4aXMgcmFuZ2UuIElmIHNldCwgdGhlIGF4aXMgc2VsZWN0aW9uIGlzIGVuYWJsZWQuIFRoZSByYW5nZSBpcyBpbmRleC1iYXNlZCBhbmQgc3RhcnRzIGZyb20gemVyby5cbiAqIENhdGVnb3JpZXMgd2l0aCBpbmRleGVzIGluIHRoZSByYW5nZSAoYHNlbGVjdC5mcm9tYCwgYHNlbGVjdC50b2ApIHdpbGwgYmUgc2VsZWN0ZWQuXG4gKiBUaGlzIG1lYW5zIHRoYXQgdGhlIGxhc3QgY2F0ZWdvcnkgaW4gdGhlIHJhbmdlIHdpbGwgbm90IGJlIGluY2x1ZGVkIGluIHRoZSBzZWxlY3Rpb24uXG4gKiBJZiB0aGUgY2F0ZWdvcmllcyBhcmUgZGF0ZXMsIHRoZSByYW5nZSBoYXMgYWxzbyB0byBiZSBzcGVjaWZpZWQgd2l0aCBkYXRlIHZhbHVlcy5cbiAqL1xubGV0IE5hdmlnYXRvckNhdGVnb3J5QXhpc1NlbGVjdENvbXBvbmVudCA9IGNsYXNzIE5hdmlnYXRvckNhdGVnb3J5QXhpc1NlbGVjdENvbXBvbmVudCBleHRlbmRzIENhdGVnb3J5QXhpc1NlbGVjdENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbk5hdmlnYXRvckNhdGVnb3J5QXhpc1NlbGVjdENvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LW5hdmlnYXRvci1jYXRlZ29yeS1heGlzLXNlbGVjdCcsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzU2VsZWN0Q29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgdGl0bGUgY29uZmlndXJhdGlvbiBvZiB0aGUgbmF2aWdhdG9yIGNhdGVnb3J5IGF4aXMuXG4gKi9cbmxldCBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNUaXRsZUNvbXBvbmVudCA9IGNsYXNzIE5hdmlnYXRvckNhdGVnb3J5QXhpc1RpdGxlQ29tcG9uZW50IGV4dGVuZHMgQ2F0ZWdvcnlBeGlzVGl0bGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5OYXZpZ2F0b3JDYXRlZ29yeUF4aXNUaXRsZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LW5hdmlnYXRvci1jYXRlZ29yeS1heGlzLXRpdGxlJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNUaXRsZUNvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIGRlZmF1bHQgb3B0aW9ucyBvZiB0aGUgbmF2aWdhdG9yIGhpbnRcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfc3RvY2tjaGFydF9jaGFydHMgJX0jdG9jLW5hdmlnYXRvcikpLlxuICovXG5sZXQgTmF2aWdhdG9ySGludENvbXBvbmVudCA9IGNsYXNzIE5hdmlnYXRvckhpbnRDb21wb25lbnQgZXh0ZW5kcyBTZXR0aW5nc0NvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoJ2hpbnQnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRnVuY3Rpb24pXG5dLCBOYXZpZ2F0b3JIaW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJjb250ZW50XCIsIHZvaWQgMCk7XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBOYXZpZ2F0b3JIaW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJmb3JtYXRcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEJvb2xlYW4pXG5dLCBOYXZpZ2F0b3JIaW50Q29tcG9uZW50LnByb3RvdHlwZSwgXCJ2aXNpYmxlXCIsIHZvaWQgMCk7XG5OYXZpZ2F0b3JIaW50Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbmF2aWdhdG9yLWhpbnQnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIE5hdmlnYXRvckhpbnRDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBjb25maWd1cmF0aW9uIGNvbXBvbmVudCBvZiB0aGUgbmF2aWdhdG9yIHBhbmVcbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgb3ZlcnZpZXdfc3RvY2tjaGFydF9jaGFydHMgJX0jdG9jLW5hdmlnYXRvcikpLlxuICovXG5sZXQgTmF2aWdhdG9yUGFuZUNvbXBvbmVudCA9IGNsYXNzIE5hdmlnYXRvclBhbmVDb21wb25lbnQgZXh0ZW5kcyBQYW5lQ29tcG9uZW50R2VuZXJhdGVkIHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSwgbnVsbCk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuTmF2aWdhdG9yUGFuZUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBwcm92aWRlcnM6IFt7IHByb3ZpZGU6IFBSRUZJWCwgdXNlVmFsdWU6ICduYXZpZ2F0b3IucGFuZScgfSwgeyBwcm92aWRlOiBDb25maWd1cmF0aW9uU2VydmljZSwgdXNlQ2xhc3M6IFByZWZpeENvbmZpZ3VyYXRpb25TZXJ2aWNlIH1dLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LW5hdmlnYXRvci1wYW5lJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBOYXZpZ2F0b3JQYW5lQ29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgdGl0bGUgY29uZmlndXJhdGlvbiBvZiB0aGUgU3RvY2tDaGFydCBuYXZpZ2F0b3IgcGFuZS5cbiAqL1xubGV0IE5hdmlnYXRvclBhbmVUaXRsZUNvbXBvbmVudCA9IGNsYXNzIE5hdmlnYXRvclBhbmVUaXRsZUNvbXBvbmVudCBleHRlbmRzIFBhbmVzVGl0bGVDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5OYXZpZ2F0b3JQYW5lVGl0bGVDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1uYXZpZ2F0b3ItcGFuZS10aXRsZScsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgTmF2aWdhdG9yUGFuZVRpdGxlQ29tcG9uZW50KTtcblxuLyoqXG4gKiBTcGVjaWZpZXMgdGhlIGluaXRpYWxseSBzZWxlY3RlZCByYW5nZS5cbiAqIElmIG5vIHJhbmdlIGlzIHNwZWNpZmllZCwgdGhlIGZ1bGwgcmFuZ2Ugb2YgdmFsdWVzIGlzIHJlbmRlcmVkLlxuICovXG5sZXQgTmF2aWdhdG9yU2VsZWN0Q29tcG9uZW50ID0gY2xhc3MgTmF2aWdhdG9yU2VsZWN0Q29tcG9uZW50IGV4dGVuZHMgU2V0dGluZ3NDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKCdzZWxlY3QnLCBjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSlcbl0sIE5hdmlnYXRvclNlbGVjdENvbXBvbmVudC5wcm90b3R5cGUsIFwiZnJvbVwiLCB2b2lkIDApO1xuX19kZWNvcmF0ZShbXG4gICAgSW5wdXQoKSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgRGF0ZSlcbl0sIE5hdmlnYXRvclNlbGVjdENvbXBvbmVudC5wcm90b3R5cGUsIFwidG9cIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIE9iamVjdClcbl0sIE5hdmlnYXRvclNlbGVjdENvbXBvbmVudC5wcm90b3R5cGUsIFwibW91c2V3aGVlbFwiLCB2b2lkIDApO1xuTmF2aWdhdG9yU2VsZWN0Q29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbmF2aWdhdG9yLXNlbGVjdCcsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgTmF2aWdhdG9yU2VsZWN0Q29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBjb21wb25lbnQgb2YgYSBuYXZpZ2F0b3Igc2VyaWVzIGl0ZW1cbiAqIChbc2VlIGV4YW1wbGVdKHslIHNsdWcgbmF2aWdhdG9yX3N0b2NrY2hhcnRfY2hhcnRzICV9KSkuXG4gKi9cbmxldCBOYXZpZ2F0b3JTZXJpZXNJdGVtQ29tcG9uZW50ID0gY2xhc3MgTmF2aWdhdG9yU2VyaWVzSXRlbUNvbXBvbmVudCBleHRlbmRzIFNlcmllc0l0ZW1Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvblNlcnZpY2UgPSBjb2xsZWN0aW9uU2VydmljZTtcbiAgICB9XG59O1xuTmF2aWdhdG9yU2VyaWVzSXRlbUNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBwcm92aWRlcnM6IFtDb25maWd1cmF0aW9uU2VydmljZV0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbmF2aWdhdG9yLXNlcmllcy1pdGVtJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZSxcbiAgICAgICAgQ29sbGVjdGlvblNlcnZpY2VdKVxuXSwgTmF2aWdhdG9yU2VyaWVzSXRlbUNvbXBvbmVudCk7XG5cbi8qKlxuICogQSBjb2xsZWN0aW9uIG9mIG9uZSBvciBtb3JlIG5hdmlnYXRvciBzZXJpZXMgaXRlbXMuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzXG4gKiBpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqXG4gKiBfQENvbXBvbmVudCh7XG4gKiAgIHNlbGVjdG9yOiAnbXktYXBwJyxcbiAqICAgdGVtcGxhdGU6IGBcbiAqICAgICA8a2VuZG8tc3RvY2tjaGFydD5cbiAqICAgICAgICAgPGtlbmRvLWNoYXJ0LW5hdmlnYXRvcj5cbiAqICAgICAgICAgICAgIDxrZW5kby1jaGFydC1uYXZpZ2F0b3Itc2VyaWVzPlxuICogICAgICAgICAgICAgICAgIDxrZW5kby1jaGFydC1uYXZpZ2F0b3Itc2VyaWVzLWl0ZW0gdHlwZT1cImFyZWFcIiBbZGF0YV09XCJkYXRhXCIgZmllbGQ9XCJ2YWx1ZVwiIGNhdGVnb3J5RmllbGQ9XCJkYXRlXCI+XG4gKiAgICAgICAgICAgICAgICAgPC9rZW5kby1jaGFydC1uYXZpZ2F0b3Itc2VyaWVzLWl0ZW0+XG4gKiAgICAgICAgICAgICA8L2tlbmRvLWNoYXJ0LW5hdmlnYXRvci1zZXJpZXM+XG4gKiAgICAgICAgIDwva2VuZG8tY2hhcnQtbmF2aWdhdG9yPlxuICogICAgIDwva2VuZG8tc3RvY2tjaGFydD5cbiAqICAgYFxuICogfSlcbiAqIGNsYXNzIEFwcENvbXBvbmVudCB7XG4gKiAgIHB1YmxpYyBkYXRhOiBhbnlbXSA9IFtdO1xuICpcbiAqICAgY29uc3RydWN0b3IoKSB7XG4gKiAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IDEwMDsgaWR4KyspIHtcbiAqICAgICAgICAgIHRoaXMuZGF0YS5wdXNoKHtcbiAqICAgICAgICAgICAgICBkYXRlOiBuZXcgRGF0ZSgyMDE3LCAwLCBpZHgpLFxuICogICAgICAgICAgICAgIHZhbHVlOiBNYXRoLnJhbmRvbSgpICogMTAwXG4gKiAgICAgICAgICB9KTtcbiAqICAgICAgfVxuICogICB9XG4gKiB9XG4gKlxuICogYGBgXG4gKi9cbmxldCBOYXZpZ2F0b3JTZXJpZXNDb21wb25lbnQgPSBjbGFzcyBOYXZpZ2F0b3JTZXJpZXNDb21wb25lbnQgZXh0ZW5kcyBTZXJpZXNDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlLCBjb2xsZWN0aW9uU2VydmljZSwgdG9vbHRpcFRlbXBsYXRlU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSwgY29sbGVjdGlvblNlcnZpY2UsIHRvb2x0aXBUZW1wbGF0ZVNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMuY29sbGVjdGlvblNlcnZpY2UgPSBjb2xsZWN0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy50b29sdGlwVGVtcGxhdGVTZXJ2aWNlID0gdG9vbHRpcFRlbXBsYXRlU2VydmljZTtcbiAgICB9XG4gICAgcmVhZFRvb2x0aXBUZW1wbGF0ZXMoKSB7XG4gICAgfVxufTtcbl9fZGVjb3JhdGUoW1xuICAgIENvbnRlbnRDaGlsZHJlbihOYXZpZ2F0b3JTZXJpZXNJdGVtQ29tcG9uZW50KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnR5cGVcIiwgUXVlcnlMaXN0KVxuXSwgTmF2aWdhdG9yU2VyaWVzQ29tcG9uZW50LnByb3RvdHlwZSwgXCJjaGlsZHJlblwiLCB2b2lkIDApO1xuTmF2aWdhdG9yU2VyaWVzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHByb3ZpZGVyczogW0NvbGxlY3Rpb25TZXJ2aWNlXSxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1uYXZpZ2F0b3Itc2VyaWVzJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZSxcbiAgICAgICAgQ29sbGVjdGlvblNlcnZpY2UsXG4gICAgICAgIFRvb2x0aXBUZW1wbGF0ZVNlcnZpY2VdKVxuXSwgTmF2aWdhdG9yU2VyaWVzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgZXJyb3IgYmFycyBvZiB0aGUgU3RvY2tDaGFydCBuYXZpZ2F0b3Igc2VyaWVzLlxuICovXG5sZXQgTmF2aWdhdG9yU2VyaWVzRXJyb3JCYXJzQ29tcG9uZW50ID0gY2xhc3MgTmF2aWdhdG9yU2VyaWVzRXJyb3JCYXJzQ29tcG9uZW50IGV4dGVuZHMgU2VyaWVzRXJyb3JCYXJzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuTmF2aWdhdG9yU2VyaWVzRXJyb3JCYXJzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbmF2aWdhdG9yLXNlcmllcy1pdGVtLWVycm9yLWJhcnMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIE5hdmlnYXRvclNlcmllc0Vycm9yQmFyc0NvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIGV4dHJlbWVzIGNvbmZpZ3VyYXRpb24gb2YgdGhlIFN0b2NrQ2hhcnQgbmF2aWdhdG9yIHNlcmllcy4gQXBwbGllcyB0byBleHRyZW1lIG91dGxpZXJzLlxuICovXG5sZXQgTmF2aWdhdG9yU2VyaWVzRXh0cmVtZXNDb21wb25lbnQgPSBjbGFzcyBOYXZpZ2F0b3JTZXJpZXNFeHRyZW1lc0NvbXBvbmVudCBleHRlbmRzIFNlcmllc0V4dHJlbWVzQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSkge1xuICAgICAgICBzdXBlcihjb25maWd1cmF0aW9uU2VydmljZSk7XG4gICAgICAgIHRoaXMuY29uZmlndXJhdGlvblNlcnZpY2UgPSBjb25maWd1cmF0aW9uU2VydmljZTtcbiAgICB9XG59O1xuTmF2aWdhdG9yU2VyaWVzRXh0cmVtZXNDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1uYXZpZ2F0b3Itc2VyaWVzLWl0ZW0tZXh0cmVtZXMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIE5hdmlnYXRvclNlcmllc0V4dHJlbWVzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIG9mIHRoZSBTdG9ja0NoYXJ0IHNlcmllcyBoaWdobGlnaHQuXG4gKi9cbmxldCBOYXZpZ2F0b3JTZXJpZXNIaWdobGlnaHRDb21wb25lbnQgPSBjbGFzcyBOYXZpZ2F0b3JTZXJpZXNIaWdobGlnaHRDb21wb25lbnQgZXh0ZW5kcyBTZXJpZXNIaWdobGlnaHRDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5OYXZpZ2F0b3JTZXJpZXNIaWdobGlnaHRDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1uYXZpZ2F0b3Itc2VyaWVzLWl0ZW0taGlnaGxpZ2h0JyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBOYXZpZ2F0b3JTZXJpZXNIaWdobGlnaHRDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBsYWJlbCBjb25maWd1cmF0aW9uIG9mIHRoZSBTdG9ja0NoYXJ0IG5hdmlnYXRvciBzZXJpZXMuXG4gKi9cbmxldCBOYXZpZ2F0b3JTZXJpZXNMYWJlbHNDb21wb25lbnQgPSBjbGFzcyBOYXZpZ2F0b3JTZXJpZXNMYWJlbHNDb21wb25lbnQgZXh0ZW5kcyBTZXJpZXNMYWJlbHNDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG59O1xuTmF2aWdhdG9yU2VyaWVzTGFiZWxzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbmF2aWdhdG9yLXNlcmllcy1pdGVtLWxhYmVscycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgTmF2aWdhdG9yU2VyaWVzTGFiZWxzQ29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgYGZyb21gIGxhYmVsIGNvbmZpZ3VyYXRpb24gb2YgdGhlIFN0b2NrQ2hhcnQgbmF2aWdhdG9yIHNlcmllcy5cbiAqL1xubGV0IE5hdmlnYXRvclNlcmllc0xhYmVsc0Zyb21Db21wb25lbnQgPSBjbGFzcyBOYXZpZ2F0b3JTZXJpZXNMYWJlbHNGcm9tQ29tcG9uZW50IGV4dGVuZHMgU2VyaWVzTGFiZWxzRnJvbUNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgICAgIHRoaXMubWFya0FzVmlzaWJsZSgpO1xuICAgIH1cbn07XG5OYXZpZ2F0b3JTZXJpZXNMYWJlbHNGcm9tQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbmF2aWdhdG9yLXNlcmllcy1pdGVtLWxhYmVscy1mcm9tJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBOYXZpZ2F0b3JTZXJpZXNMYWJlbHNGcm9tQ29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgYHRvYCBsYWJlbCBjb25maWd1cmF0aW9uIG9mIHRoZSBTdG9ja0NoYXJ0IG5hdmlnYXRvciBzZXJpZXMuXG4gKi9cbmxldCBOYXZpZ2F0b3JTZXJpZXNMYWJlbHNUb0NvbXBvbmVudCA9IGNsYXNzIE5hdmlnYXRvclNlcmllc0xhYmVsc1RvQ29tcG9uZW50IGV4dGVuZHMgU2VyaWVzTGFiZWxzVG9Db21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLm1hcmtBc1Zpc2libGUoKTtcbiAgICB9XG59O1xuTmF2aWdhdG9yU2VyaWVzTGFiZWxzVG9Db21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1uYXZpZ2F0b3Itc2VyaWVzLWl0ZW0tbGFiZWxzLXRvJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBOYXZpZ2F0b3JTZXJpZXNMYWJlbHNUb0NvbXBvbmVudCk7XG5cbi8qKlxuICogVGhlIG1hcmtlciBjb25maWd1cmF0aW9uIG9mIHRoZSBTdG9ja0NoYXJ0IG5hdmlnYXRvciBzZXJpZXMuXG4gKi9cbmxldCBOYXZpZ2F0b3JTZXJpZXNNYXJrZXJzQ29tcG9uZW50ID0gY2xhc3MgTmF2aWdhdG9yU2VyaWVzTWFya2Vyc0NvbXBvbmVudCBleHRlbmRzIFNlcmllc01hcmtlcnNDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5OYXZpZ2F0b3JTZXJpZXNNYXJrZXJzQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbmF2aWdhdG9yLXNlcmllcy1pdGVtLW1hcmtlcnMnLFxuICAgICAgICB0ZW1wbGF0ZTogJydcbiAgICB9KSxcbiAgICBfX21ldGFkYXRhKFwiZGVzaWduOnBhcmFtdHlwZXNcIiwgW0NvbmZpZ3VyYXRpb25TZXJ2aWNlXSlcbl0sIE5hdmlnYXRvclNlcmllc01hcmtlcnNDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBub3RlcyBjb25maWd1cmF0aW9uIG9mIHRoZSBTdG9ja0NoYXJ0IG5hdmlnYXRvciBzZXJpZXMuXG4gKi9cbmxldCBOYXZpZ2F0b3JTZXJpZXNOb3Rlc0NvbXBvbmVudCA9IGNsYXNzIE5hdmlnYXRvclNlcmllc05vdGVzQ29tcG9uZW50IGV4dGVuZHMgU2VyaWVzTm90ZXNDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5OYXZpZ2F0b3JTZXJpZXNOb3Rlc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LW5hdmlnYXRvci1zZXJpZXMtaXRlbS1ub3RlcycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgTmF2aWdhdG9yU2VyaWVzTm90ZXNDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBpY29uIG9mIHRoZSBub3Rlcy5cbiAqL1xubGV0IE5hdmlnYXRvclNlcmllc05vdGVzSWNvbkNvbXBvbmVudCA9IGNsYXNzIE5hdmlnYXRvclNlcmllc05vdGVzSWNvbkNvbXBvbmVudCBleHRlbmRzIFNlcmllc05vdGVzSWNvbkNvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbk5hdmlnYXRvclNlcmllc05vdGVzSWNvbkNvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LW5hdmlnYXRvci1zZXJpZXMtaXRlbS1ub3Rlcy1pY29uJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBOYXZpZ2F0b3JTZXJpZXNOb3Rlc0ljb25Db21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSBsYWJlbCBvZiB0aGUgbm90ZXMuXG4gKi9cbmxldCBOYXZpZ2F0b3JTZXJpZXNOb3Rlc0xhYmVsQ29tcG9uZW50ID0gY2xhc3MgTmF2aWdhdG9yU2VyaWVzTm90ZXNMYWJlbENvbXBvbmVudCBleHRlbmRzIFNlcmllc05vdGVzTGFiZWxDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5OYXZpZ2F0b3JTZXJpZXNOb3Rlc0xhYmVsQ29tcG9uZW50ID0gX19kZWNvcmF0ZShbXG4gICAgQ29tcG9uZW50KHtcbiAgICAgICAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2gsXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tY2hhcnQtbmF2aWdhdG9yLXNlcmllcy1pdGVtLW5vdGVzLWxhYmVsJyxcbiAgICAgICAgdGVtcGxhdGU6ICcnXG4gICAgfSksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjpwYXJhbXR5cGVzXCIsIFtDb25maWd1cmF0aW9uU2VydmljZV0pXG5dLCBOYXZpZ2F0b3JTZXJpZXNOb3Rlc0xhYmVsQ29tcG9uZW50KTtcblxuLyoqXG4gKiBUaGUgb3V0bGllcnMgY29uZmlndXJhdGlvbiBvZiB0aGUgU3RvY2tDaGFydCBuYXZpZ2F0b3Igc2VyaWVzLiBBcHBsaWVzIHRvIG1pbGQgb3V0bGllcnMuXG4gKi9cbmxldCBOYXZpZ2F0b3JTZXJpZXNPdXRsaWVyc0NvbXBvbmVudCA9IGNsYXNzIE5hdmlnYXRvclNlcmllc091dGxpZXJzQ29tcG9uZW50IGV4dGVuZHMgU2VyaWVzT3V0bGllcnNDb21wb25lbnQge1xuICAgIGNvbnN0cnVjdG9yKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGNvbmZpZ3VyYXRpb25TZXJ2aWNlKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgIH1cbn07XG5OYXZpZ2F0b3JTZXJpZXNPdXRsaWVyc0NvbXBvbmVudCA9IF9fZGVjb3JhdGUoW1xuICAgIENvbXBvbmVudCh7XG4gICAgICAgIGNoYW5nZURldGVjdGlvbjogQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3kuT25QdXNoLFxuICAgICAgICBzZWxlY3RvcjogJ2tlbmRvLWNoYXJ0LW5hdmlnYXRvci1zZXJpZXMtaXRlbS1vdXRsaWVycycsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgTmF2aWdhdG9yU2VyaWVzT3V0bGllcnNDb21wb25lbnQpO1xuXG4vKipcbiAqIFRoZSB0b29sdGlwIGNvbmZpZ3VyYXRpb24gb2YgdGhlIFN0b2NrQ2hhcnQgbmF2aWdhdG9yIHNlcmllcy5cbiAqIFRoZSBTdG9ja0NoYXJ0IG5hdmlnYXRvciBzZXJpZXMgdG9vbHRpcCBpcyBkaXNwbGF5ZWQgd2hlbiB0aGUgYG5hdmlnYXRvci5zZXJpZXMudG9vbHRpcC52aXNpYmxlYCBvcHRpb24gaXMgc2V0IHRvIGB0cnVlYC5cbiAqL1xubGV0IE5hdmlnYXRvclNlcmllc1Rvb2x0aXBDb21wb25lbnQgPSBjbGFzcyBOYXZpZ2F0b3JTZXJpZXNUb29sdGlwQ29tcG9uZW50IGV4dGVuZHMgU2VyaWVzVG9vbHRpcENvbXBvbmVudCB7XG4gICAgY29uc3RydWN0b3IoY29uZmlndXJhdGlvblNlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UpO1xuICAgICAgICB0aGlzLmNvbmZpZ3VyYXRpb25TZXJ2aWNlID0gY29uZmlndXJhdGlvblNlcnZpY2U7XG4gICAgfVxufTtcbk5hdmlnYXRvclNlcmllc1Rvb2x0aXBDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgc2VsZWN0b3I6ICdrZW5kby1jaGFydC1uYXZpZ2F0b3Itc2VyaWVzLWl0ZW0tdG9vbHRpcCcsXG4gICAgICAgIHRlbXBsYXRlOiAnJ1xuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2VdKVxuXSwgTmF2aWdhdG9yU2VyaWVzVG9vbHRpcENvbXBvbmVudCk7XG5cbi8qKlxuICogQGhpZGRlblxuICovXG5jb25zdCBTVE9DS19DSEFSVF9ESVJFQ1RJVkVTID0gW1xuICAgIFN0b2NrQ2hhcnRDb21wb25lbnQsXG4gICAgTmF2aWdhdG9yQ29tcG9uZW50LFxuICAgIE5hdmlnYXRvckNhdGVnb3J5QXhpc0NvbXBvbmVudCxcbiAgICBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNDcm9zc2hhaXJDb21wb25lbnQsXG4gICAgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCxcbiAgICBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQsXG4gICAgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzTm90ZXNDb21wb25lbnQsXG4gICAgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzTm90ZXNJY29uQ29tcG9uZW50LFxuICAgIE5hdmlnYXRvckNhdGVnb3J5QXhpc05vdGVzTGFiZWxDb21wb25lbnQsXG4gICAgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzU2VsZWN0Q29tcG9uZW50LFxuICAgIE5hdmlnYXRvckNhdGVnb3J5QXhpc1RpdGxlQ29tcG9uZW50LFxuICAgIE5hdmlnYXRvckhpbnRDb21wb25lbnQsXG4gICAgTmF2aWdhdG9yUGFuZUNvbXBvbmVudCxcbiAgICBOYXZpZ2F0b3JQYW5lVGl0bGVDb21wb25lbnQsXG4gICAgTmF2aWdhdG9yU2VsZWN0Q29tcG9uZW50LFxuICAgIE5hdmlnYXRvclNlcmllc0NvbXBvbmVudCxcbiAgICBOYXZpZ2F0b3JTZXJpZXNJdGVtQ29tcG9uZW50LFxuICAgIE5hdmlnYXRvclNlcmllc0Vycm9yQmFyc0NvbXBvbmVudCxcbiAgICBOYXZpZ2F0b3JTZXJpZXNFeHRyZW1lc0NvbXBvbmVudCxcbiAgICBOYXZpZ2F0b3JTZXJpZXNIaWdobGlnaHRDb21wb25lbnQsXG4gICAgTmF2aWdhdG9yU2VyaWVzTGFiZWxzQ29tcG9uZW50LFxuICAgIE5hdmlnYXRvclNlcmllc0xhYmVsc0Zyb21Db21wb25lbnQsXG4gICAgTmF2aWdhdG9yU2VyaWVzTGFiZWxzVG9Db21wb25lbnQsXG4gICAgTmF2aWdhdG9yU2VyaWVzTWFya2Vyc0NvbXBvbmVudCxcbiAgICBOYXZpZ2F0b3JTZXJpZXNOb3Rlc0NvbXBvbmVudCxcbiAgICBOYXZpZ2F0b3JTZXJpZXNOb3Rlc0ljb25Db21wb25lbnQsXG4gICAgTmF2aWdhdG9yU2VyaWVzTm90ZXNMYWJlbENvbXBvbmVudCxcbiAgICBOYXZpZ2F0b3JTZXJpZXNPdXRsaWVyc0NvbXBvbmVudCxcbiAgICBOYXZpZ2F0b3JTZXJpZXNUb29sdGlwQ29tcG9uZW50XG5dO1xuXG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby1hY2Nlc3MtbWlzc2luZy1tZW1iZXIgKi9cbi8qKlxuICogVGhlIHJvb3QgQ2hhcnQgY29tcG9uZW50LlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c1xuICogaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKlxuICogX0BDb21wb25lbnQoe1xuICogICBzZWxlY3RvcjogJ215LWFwcCcsXG4gKiAgIHRlbXBsYXRlOiBgXG4gKiAgICAgPGtlbmRvLXNwYXJrbGluZSBbZGF0YV09XCJkYXRhXCIgdHlwZT1cImNvbHVtblwiPlxuICogICAgIDwva2VuZG8tc3BhcmtsaW5lPlxuICogICBgXG4gKiB9KVxuICogY2xhc3MgQXBwQ29tcG9uZW50IHtcbiAqICAgcHVibGljIGRhdGE6IGFueVtdID0gW1xuICogICAgIDkzNiwgOTY4LCAxMDI1LCA5OTksIDk5OCwgMTAxNCwgMTAxNywgMTAxMCwgMTAxMCwgMTAwNyxcbiAqICAgICAxMDA0LCA5ODgsIDk5MCwgOTg4LCA5ODcsIDk5NSwgOTQ2LCA5NTQsIDk5MSwgOTg0LFxuICogICAgIDk3NCwgOTU2LCA5ODYsIDkzNiwgOTU1LCAxMDIxLCAxMDEzLCAxMDA1LCA5NTgsIDk1MyxcbiAqICAgICA5NTIsIDk0MCwgOTM3LCA5ODAsIDk2NiwgOTY1LCA5MjgsIDkxNiwgOTEwLCA5ODBcbiAqICAgXTtcbiAqIH1cbiAqXG4gKiBgYGBcbiAqL1xubGV0IFNwYXJrbGluZUNvbXBvbmVudCA9IGNsYXNzIFNwYXJrbGluZUNvbXBvbmVudCBleHRlbmRzIENoYXJ0Q29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25maWd1cmF0aW9uU2VydmljZSwgdGhlbWVTZXJ2aWNlLCBlbGVtZW50LCBpbnRsLCBsb2NhbGl6YXRpb25TZXJ2aWNlLCBuZ1pvbmUsIGluc3RhbmNlRXZlbnRTZXJ2aWNlLCBjaGFuZ2VEZXRlY3RvciwgcmVuZGVyZXIpIHtcbiAgICAgICAgc3VwZXIoY29uZmlndXJhdGlvblNlcnZpY2UsIHRoZW1lU2VydmljZSwgZWxlbWVudCwgaW50bCwgbG9jYWxpemF0aW9uU2VydmljZSwgbmdab25lLCBpbnN0YW5jZUV2ZW50U2VydmljZSwgY2hhbmdlRGV0ZWN0b3IsIHJlbmRlcmVyKTtcbiAgICAgICAgdGhpcy5jb25maWd1cmF0aW9uU2VydmljZSA9IGNvbmZpZ3VyYXRpb25TZXJ2aWNlO1xuICAgICAgICB0aGlzLnRoZW1lU2VydmljZSA9IHRoZW1lU2VydmljZTtcbiAgICAgICAgdGhpcy5lbGVtZW50ID0gZWxlbWVudDtcbiAgICAgICAgdGhpcy5pbnRsID0gaW50bDtcbiAgICAgICAgdGhpcy5sb2NhbGl6YXRpb25TZXJ2aWNlID0gbG9jYWxpemF0aW9uU2VydmljZTtcbiAgICAgICAgdGhpcy5uZ1pvbmUgPSBuZ1pvbmU7XG4gICAgICAgIHRoaXMuaW5zdGFuY2VFdmVudFNlcnZpY2UgPSBpbnN0YW5jZUV2ZW50U2VydmljZTtcbiAgICAgICAgdGhpcy5jaGFuZ2VEZXRlY3RvciA9IGNoYW5nZURldGVjdG9yO1xuICAgICAgICB0aGlzLnJlbmRlcmVyID0gcmVuZGVyZXI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaGlkZGVuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLnRvb2x0aXBXcmFwcGVyQ2xhc3MgPSAnay1zcGFya2xpbmUtdG9vbHRpcC13cmFwcGVyJztcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBoaWRkZW5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMudG9vbHRpcENvbnRlbnRDbGFzc2VzID0ge1xuICAgICAgICAgICAgJ2stc3BhcmtsaW5lLXRvb2x0aXAnOiB0cnVlXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuaG9zdENsYXNzZXMgPSBbJ2stc3BhcmtsaW5lJywgJ2std2lkZ2V0J107XG4gICAgICAgIHZhbGlkYXRlUGFja2FnZShwYWNrYWdlTWV0YWRhdGEpO1xuICAgIH1cbiAgICBjcmVhdGVJbnN0YW5jZShlbGVtZW50LCBvYnNlcnZlcikge1xuICAgICAgICB0aGlzLmluc3RhbmNlID0gbmV3IFNwYXJrbGluZShlbGVtZW50LCBTcGFya2xpbmUubm9ybWFsaXplT3B0aW9ucyh0aGlzLm9wdGlvbnMpLCB0aGlzLnRoZW1lLCB7XG4gICAgICAgICAgICBpbnRsU2VydmljZTogdGhpcy5pbnRsLFxuICAgICAgICAgICAgb2JzZXJ2ZXI6IG9ic2VydmVyLFxuICAgICAgICAgICAgcnRsOiB0aGlzLnJ0bCxcbiAgICAgICAgICAgIHNlbmRlcjogdGhpc1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgdXBkYXRlT3B0aW9ucygpIHtcbiAgICAgICAgdGhpcy5pbnN0YW5jZS5zZXRPcHRpb25zKFNwYXJrbGluZS5ub3JtYWxpemVPcHRpb25zKHRoaXMub3B0aW9ucykpO1xuICAgIH1cbn07XG5fX2RlY29yYXRlKFtcbiAgICBJbnB1dCgpLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246dHlwZVwiLCBTdHJpbmcpXG5dLCBTcGFya2xpbmVDb21wb25lbnQucHJvdG90eXBlLCBcInR5cGVcIiwgdm9pZCAwKTtcbl9fZGVjb3JhdGUoW1xuICAgIElucHV0KCksXG4gICAgX19tZXRhZGF0YShcImRlc2lnbjp0eXBlXCIsIEFycmF5KVxuXSwgU3BhcmtsaW5lQ29tcG9uZW50LnByb3RvdHlwZSwgXCJkYXRhXCIsIHZvaWQgMCk7XG5TcGFya2xpbmVDb21wb25lbnQgPSBfX2RlY29yYXRlKFtcbiAgICBDb21wb25lbnQoe1xuICAgICAgICBjaGFuZ2VEZXRlY3Rpb246IENoYW5nZURldGVjdGlvblN0cmF0ZWd5Lk9uUHVzaCxcbiAgICAgICAgZXhwb3J0QXM6ICdrZW5kb1NwYXJrbGluZScsXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgICAgICAgICBUb29sdGlwVGVtcGxhdGVTZXJ2aWNlLFxuICAgICAgICAgICAgSW5zdGFuY2VFdmVudFNlcnZpY2UsXG4gICAgICAgICAgICBMb2NhbGl6YXRpb25TZXJ2aWNlLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHByb3ZpZGU6IEwxME5fUFJFRklYLFxuICAgICAgICAgICAgICAgIHVzZVZhbHVlOiAna2VuZG8uY2hhcnQnXG4gICAgICAgICAgICB9XG4gICAgICAgIF0sXG4gICAgICAgIHNlbGVjdG9yOiAna2VuZG8tc3BhcmtsaW5lJyxcbiAgICAgICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPHNwYW4gI3N1cmZhY2UgY2xhc3M9XCJrLWNoYXJ0LXN1cmZhY2VcIj48L3NwYW4+XG4gICAgICAgIDxrZW5kby1jaGFydC1jcm9zc2hhaXItdG9vbHRpcHMtY29udGFpbmVyIFtwb3B1cFNldHRpbmdzXT1cInBvcHVwU2V0dGluZ3NcIj5cbiAgICAgICAgPC9rZW5kby1jaGFydC1jcm9zc2hhaXItdG9vbHRpcHMtY29udGFpbmVyPlxuICAgICAgICA8a2VuZG8tY2hhcnQtdG9vbHRpcC1wb3B1cCBbYW5pbWF0ZV09XCJmYWxzZVwiIFt3cmFwcGVyQ2xhc3NdPVwidG9vbHRpcFdyYXBwZXJDbGFzc1wiXG4gICAgICAgICAgICBbY2xhc3NOYW1lc109XCJ0b29sdGlwQ29udGVudENsYXNzZXNcIiAobGVhdmUpPVwidG9vbHRpcE1vdXNlbGVhdmUoJGV2ZW50KVwiIFtwb3B1cFNldHRpbmdzXT1cInBvcHVwU2V0dGluZ3NcIj5cbiAgICAgICAgPC9rZW5kby1jaGFydC10b29sdGlwLXBvcHVwPlxuICAgICAgICA8a2VuZG8tcmVzaXplLXNlbnNvciAocmVzaXplKT1cIm9uUmVzaXplKCRldmVudClcIj48L2tlbmRvLXJlc2l6ZS1zZW5zb3I+XG4gICAgYFxuICAgIH0pLFxuICAgIF9fbWV0YWRhdGEoXCJkZXNpZ246cGFyYW10eXBlc1wiLCBbQ29uZmlndXJhdGlvblNlcnZpY2UsXG4gICAgICAgIFRoZW1lU2VydmljZSxcbiAgICAgICAgRWxlbWVudFJlZixcbiAgICAgICAgSW50bFNlcnZpY2UsXG4gICAgICAgIExvY2FsaXphdGlvblNlcnZpY2UsXG4gICAgICAgIE5nWm9uZSxcbiAgICAgICAgSW5zdGFuY2VFdmVudFNlcnZpY2UsXG4gICAgICAgIENoYW5nZURldGVjdG9yUmVmLFxuICAgICAgICBSZW5kZXJlcjJdKVxuXSwgU3BhcmtsaW5lQ29tcG9uZW50KTtcblxuLyoqXG4gKiBAaGlkZGVuXG4gKi9cbmNvbnN0IFNQQVJLTElORV9ESVJFQ1RJVkVTID0gW1xuICAgIFNwYXJrbGluZUNvbXBvbmVudFxuXTtcblxuLyoqXG4gKiBBIFttb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlYXBpJ10gfX0pIHRoYXQgaW5jbHVkZXMgdGhlIENoYXJ0IGNvbXBvbmVudCBhbmQgZGlyZWN0aXZlcy5cbiAqXG4gKiBJbXBvcnRzIHRoZSBDaGFydE1vZHVsZSBpbnRvIHlvdXIgYXBwbGljYXRpb25cbiAqIFtyb290IG1vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybC5hbmd1bGFyWyduZ21vZHVsZXMnXSB9fSNhbmd1bGFyLW1vZHVsYXJpdHkpIG9yIGFueSBvdGhlciBzdWItbW9kdWxlXG4gKiB0aGF0IHdpbGwgdXNlIHRoZSBDaGFydCBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLW5vLXJ1blxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7IEJyb3dzZXJNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbiAqIGltcG9ydCB7IENoYXJ0TW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItY2hhcnRzJztcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogX0BOZ01vZHVsZSh7XG4gKiAgICAgYm9vdHN0cmFwOiAgICBbQXBwQ29tcG9uZW50XSxcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLFxuICogICAgIGltcG9ydHM6ICAgICAgW0Jyb3dzZXJNb2R1bGUsIENoYXJ0TW9kdWxlXVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge1xuICogfVxuICogYGBgXG4gKi9cbmxldCBDaGFydE1vZHVsZSA9IGNsYXNzIENoYXJ0TW9kdWxlIHtcbn07XG5DaGFydE1vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZGVjbGFyYXRpb25zOiBbQ0hBUlRfRElSRUNUSVZFU10sXG4gICAgICAgIGV4cG9ydHM6IFtDSEFSVF9ESVJFQ1RJVkVTXSxcbiAgICAgICAgaW1wb3J0czogW0NvbW1vbk1vZHVsZSwgUG9wdXBNb2R1bGUsIFJlc2l6ZVNlbnNvck1vZHVsZV0sXG4gICAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICAgICAgVGhlbWVTZXJ2aWNlXG4gICAgICAgIF1cbiAgICB9KVxuXSwgQ2hhcnRNb2R1bGUpO1xuXG4vKipcbiAqIEEgW21vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSkgdGhhdCBpbmNsdWRlcyB0aGUgU3RvY2tDaGFydCBjb21wb25lbnQgYW5kIGRpcmVjdGl2ZXMuXG4gKlxuICogSW1wb3J0cyB0aGUgU3RvY2tDaGFydE1vZHVsZSBpbnRvIHlvdXIgYXBwbGljYXRpb25cbiAqIFtyb290IG1vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVzJ10gfX0jYW5ndWxhci1tb2R1bGFyaXR5KSBvciBhbnkgb3RoZXIgc3ViLW1vZHVsZVxuICogdGhhdCB3aWxsIHVzZSB0aGUgU3RvY2tDaGFydCBjb21wb25lbnQuXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzLW5vLXJ1blxuICogaW1wb3J0IHsgTmdNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbiAqIGltcG9ydCB7IEJyb3dzZXJNb2R1bGUgfSBmcm9tICdAYW5ndWxhci9wbGF0Zm9ybS1icm93c2VyJztcbiAqIGltcG9ydCB7IFN0b2NrQ2hhcnRNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1jaGFydHMnO1xuICogaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9hcHAuY29tcG9uZW50JztcbiAqXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdLFxuICogICAgIGRlY2xhcmF0aW9uczogW0FwcENvbXBvbmVudF0sXG4gKiAgICAgaW1wb3J0czogICAgICBbQnJvd3Nlck1vZHVsZSwgU3RvY2tDaGFydE1vZHVsZV1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHtcbiAqIH1cbiAqIGBgYFxuICovXG5sZXQgU3RvY2tDaGFydE1vZHVsZSA9IGNsYXNzIFN0b2NrQ2hhcnRNb2R1bGUge1xufTtcblN0b2NrQ2hhcnRNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW1NUT0NLX0NIQVJUX0RJUkVDVElWRVNdLFxuICAgICAgICBleHBvcnRzOiBbU1RPQ0tfQ0hBUlRfRElSRUNUSVZFUywgQ2hhcnRNb2R1bGVdLFxuICAgICAgICBpbXBvcnRzOiBbQ2hhcnRNb2R1bGUsIENvbW1vbk1vZHVsZSwgUG9wdXBNb2R1bGUsIFJlc2l6ZVNlbnNvck1vZHVsZV1cbiAgICB9KVxuXSwgU3RvY2tDaGFydE1vZHVsZSk7XG5cbi8qKlxuICogQSBbbW9kdWxlXSh7eyBzaXRlLmRhdGEudXJscy5hbmd1bGFyWyduZ21vZHVsZWFwaSddIH19KSB0aGF0IGluY2x1ZGVzIHRoZSBTcGFya2xpbmUgY29tcG9uZW50IGFuZCBkaXJlY3RpdmVzLlxuICpcbiAqIEltcG9ydHMgdGhlIFNwYXJrbGluZU1vZHVsZSBpbnRvIHlvdXIgYXBwbGljYXRpb25cbiAqIFtyb290IG1vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVzJ10gfX0jYW5ndWxhci1tb2R1bGFyaXR5KSBvciBhbnkgb3RoZXIgc3ViLW1vZHVsZVxuICogdGhhdCB3aWxsIHVzZSB0aGUgU3BhcmtsaW5lIGNvbXBvbmVudC5cbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHMtbm8tcnVuXG4gKiBpbXBvcnQgeyBOZ01vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuICogaW1wb3J0IHsgQnJvd3Nlck1vZHVsZSB9IGZyb20gJ0Bhbmd1bGFyL3BsYXRmb3JtLWJyb3dzZXInO1xuICogaW1wb3J0IHsgU3BhcmtsaW5lTW9kdWxlIH0gZnJvbSAnQHByb2dyZXNzL2tlbmRvLWFuZ3VsYXItY2hhcnRzJztcbiAqIGltcG9ydCB7IEFwcENvbXBvbmVudCB9IGZyb20gJy4vYXBwLmNvbXBvbmVudCc7XG4gKlxuICogX0BOZ01vZHVsZSh7XG4gKiAgICAgYm9vdHN0cmFwOiAgICBbQXBwQ29tcG9uZW50XSxcbiAqICAgICBkZWNsYXJhdGlvbnM6IFtBcHBDb21wb25lbnRdLFxuICogICAgIGltcG9ydHM6ICAgICAgW0Jyb3dzZXJNb2R1bGUsIFNwYXJrbGluZU1vZHVsZV1cbiAqIH0pXG4gKiBleHBvcnQgY2xhc3MgQXBwTW9kdWxlIHtcbiAqIH1cbiAqIGBgYFxuICovXG5sZXQgU3BhcmtsaW5lTW9kdWxlID0gY2xhc3MgU3BhcmtsaW5lTW9kdWxlIHtcbn07XG5TcGFya2xpbmVNb2R1bGUgPSBfX2RlY29yYXRlKFtcbiAgICBOZ01vZHVsZSh7XG4gICAgICAgIGRlY2xhcmF0aW9uczogW1NQQVJLTElORV9ESVJFQ1RJVkVTXSxcbiAgICAgICAgZXhwb3J0czogW1NQQVJLTElORV9ESVJFQ1RJVkVTLCBDaGFydE1vZHVsZV0sXG4gICAgICAgIGltcG9ydHM6IFtDaGFydE1vZHVsZSwgQ29tbW9uTW9kdWxlLCBQb3B1cE1vZHVsZSwgUmVzaXplU2Vuc29yTW9kdWxlXVxuICAgIH0pXG5dLCBTcGFya2xpbmVNb2R1bGUpO1xuXG4vKipcbiAqIEEgW21vZHVsZV0oe3sgc2l0ZS5kYXRhLnVybHMuYW5ndWxhclsnbmdtb2R1bGVhcGknXSB9fSkgdGhhdCBpbmNsdWRlcyBhbGwgQ2hhcnQgY29tcG9uZW50cyBhbmQgZGlyZWN0aXZlcy5cbiAqXG4gKiBJbXBvcnRzIHRoZSBDaGFydHNNb2R1bGUgaW50byB5b3VyIGFwcGxpY2F0aW9uXG4gKiBbcm9vdCBtb2R1bGVdKHt7IHNpdGUuZGF0YS51cmxzLmFuZ3VsYXJbJ25nbW9kdWxlcyddIH19I2FuZ3VsYXItbW9kdWxhcml0eSkgb3IgYW55IG90aGVyIHN1Yi1tb2R1bGVcbiAqIHRoYXQgd2lsbCB1c2UgdGhlIENoYXJ0cyBjb21wb25lbnRzLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0cy1uby1ydW5cbiAqIGltcG9ydCB7IE5nTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG4gKiBpbXBvcnQgeyBCcm93c2VyTW9kdWxlIH0gZnJvbSAnQGFuZ3VsYXIvcGxhdGZvcm0tYnJvd3Nlcic7XG4gKiBpbXBvcnQgeyBDaGFydHNNb2R1bGUgfSBmcm9tICdAcHJvZ3Jlc3Mva2VuZG8tYW5ndWxhci1jaGFydHMnO1xuICogaW1wb3J0IHsgQXBwQ29tcG9uZW50IH0gZnJvbSAnLi9hcHAuY29tcG9uZW50JztcbiAqXG4gKiBfQE5nTW9kdWxlKHtcbiAqICAgICBib290c3RyYXA6ICAgIFtBcHBDb21wb25lbnRdLFxuICogICAgIGRlY2xhcmF0aW9uczogW0FwcENvbXBvbmVudF0sXG4gKiAgICAgaW1wb3J0czogICAgICBbQnJvd3Nlck1vZHVsZSwgQ2hhcnRzTW9kdWxlXVxuICogfSlcbiAqIGV4cG9ydCBjbGFzcyBBcHBNb2R1bGUge1xuICogfVxuICogYGBgXG4gKi9cbmxldCBDaGFydHNNb2R1bGUgPSBjbGFzcyBDaGFydHNNb2R1bGUge1xufTtcbkNoYXJ0c01vZHVsZSA9IF9fZGVjb3JhdGUoW1xuICAgIE5nTW9kdWxlKHtcbiAgICAgICAgZXhwb3J0czogW0NoYXJ0TW9kdWxlLCBTcGFya2xpbmVNb2R1bGUsIFN0b2NrQ2hhcnRNb2R1bGVdXG4gICAgfSlcbl0sIENoYXJ0c01vZHVsZSk7XG5cbi8qKlxuICogR2VuZXJhdGVkIGJ1bmRsZSBpbmRleC4gRG8gbm90IGVkaXQuXG4gKi9cblxuZXhwb3J0IHsgQ2hhcnRDb21wb25lbnRHZW5lcmF0ZWQsIEF4aXNEZWZhdWx0c0NvbXBvbmVudEdlbmVyYXRlZCwgQXhpc0RlZmF1bHRzQ3Jvc3NoYWlyQ29tcG9uZW50R2VuZXJhdGVkLCBBeGlzRGVmYXVsdHNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLCBBeGlzRGVmYXVsdHNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQsIEF4aXNEZWZhdWx0c1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50R2VuZXJhdGVkLCBDYXRlZ29yeUF4aXNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQsIENhdGVnb3J5QXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQsIENhdGVnb3J5QXhpc05vdGVzQ29tcG9uZW50R2VuZXJhdGVkLCBDYXRlZ29yeUF4aXNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQsIENhdGVnb3J5QXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQsIENhdGVnb3J5QXhpc1NlbGVjdENvbXBvbmVudEdlbmVyYXRlZCwgQ2F0ZWdvcnlBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQsIENhdGVnb3J5QXhpc0NvbXBvbmVudEdlbmVyYXRlZCwgQ2hhcnRBcmVhQ29tcG9uZW50R2VuZXJhdGVkLCBEb251dENlbnRlclRlbXBsYXRlRGlyZWN0aXZlLCBMZWdlbmRDb21wb25lbnRHZW5lcmF0ZWQsIExlZ2VuZEluYWN0aXZlSXRlbXNDb21wb25lbnRHZW5lcmF0ZWQsIExlZ2VuZEl0ZW1Db21wb25lbnRHZW5lcmF0ZWQsIFBhbmVDb21wb25lbnRHZW5lcmF0ZWQsIFBhbmVzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQsIFBhbmVzQ29tcG9uZW50R2VuZXJhdGVkLCBQbG90QXJlYUNvbXBvbmVudEdlbmVyYXRlZCwgU2VyaWVzRGVmYXVsdHNDb21wb25lbnRHZW5lcmF0ZWQsIFNlcmllc0RlZmF1bHRzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLCBTZXJpZXNEZWZhdWx0c0xhYmVsc0Zyb21Db21wb25lbnRHZW5lcmF0ZWQsIFNlcmllc0RlZmF1bHRzTGFiZWxzVG9Db21wb25lbnRHZW5lcmF0ZWQsIFNlcmllc0RlZmF1bHRzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQsIFNlcmllc0RlZmF1bHRzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLCBTZXJpZXNEZWZhdWx0c05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQsIFNlcmllc0RlZmF1bHRzVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZCwgU2VyaWVzSXRlbUNvbXBvbmVudEdlbmVyYXRlZCwgU2VyaWVzRXJyb3JCYXJzQ29tcG9uZW50R2VuZXJhdGVkLCBTZXJpZXNFeHRyZW1lc0NvbXBvbmVudEdlbmVyYXRlZCwgU2VyaWVzSGlnaGxpZ2h0Q29tcG9uZW50R2VuZXJhdGVkLCBTZXJpZXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQsIFNlcmllc0xhYmVsc0Zyb21Db21wb25lbnRHZW5lcmF0ZWQsIFNlcmllc0xhYmVsc1RvQ29tcG9uZW50R2VuZXJhdGVkLCBTZXJpZXNNYXJrZXJzQ29tcG9uZW50R2VuZXJhdGVkLCBTZXJpZXNOb3Rlc0NvbXBvbmVudEdlbmVyYXRlZCwgU2VyaWVzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLCBTZXJpZXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLCBTZXJpZXNPdXRsaWVyc0NvbXBvbmVudEdlbmVyYXRlZCwgU2VyaWVzVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZCwgU2VyaWVzQ29tcG9uZW50R2VuZXJhdGVkLCBUaXRsZUNvbXBvbmVudEdlbmVyYXRlZCwgVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZCwgQmFzZVRvb2x0aXAsIGJvZHlGYWN0b3J5LCBDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50LCBTZXJpZXNUb29sdGlwVGVtcGxhdGVEaXJlY3RpdmUsIFNoYXJlZFRvb2x0aXBUZW1wbGF0ZURpcmVjdGl2ZSwgVmFsdWVBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZCwgVmFsdWVBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50R2VuZXJhdGVkLCBWYWx1ZUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50R2VuZXJhdGVkLCBWYWx1ZUF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQsIFZhbHVlQXhpc05vdGVzQ29tcG9uZW50R2VuZXJhdGVkLCBWYWx1ZUF4aXNOb3Rlc0ljb25Db21wb25lbnRHZW5lcmF0ZWQsIFZhbHVlQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQsIFZhbHVlQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLCBWYWx1ZUF4aXNDb21wb25lbnRHZW5lcmF0ZWQsIFhBeGlzSXRlbUNvbXBvbmVudEdlbmVyYXRlZCwgWEF4aXNDcm9zc2hhaXJDb21wb25lbnRHZW5lcmF0ZWQsIFhBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudEdlbmVyYXRlZCwgWEF4aXNMYWJlbHNDb21wb25lbnRHZW5lcmF0ZWQsIFhBeGlzTm90ZXNDb21wb25lbnRHZW5lcmF0ZWQsIFhBeGlzTm90ZXNJY29uQ29tcG9uZW50R2VuZXJhdGVkLCBYQXhpc05vdGVzTGFiZWxDb21wb25lbnRHZW5lcmF0ZWQsIFhBeGlzVGl0bGVDb21wb25lbnRHZW5lcmF0ZWQsIFhBeGlzQ29tcG9uZW50R2VuZXJhdGVkLCBZQXhpc0l0ZW1Db21wb25lbnRHZW5lcmF0ZWQsIFlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50R2VuZXJhdGVkLCBZQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnRHZW5lcmF0ZWQsIFlBeGlzTGFiZWxzQ29tcG9uZW50R2VuZXJhdGVkLCBZQXhpc05vdGVzQ29tcG9uZW50R2VuZXJhdGVkLCBZQXhpc05vdGVzSWNvbkNvbXBvbmVudEdlbmVyYXRlZCwgWUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50R2VuZXJhdGVkLCBZQXhpc1RpdGxlQ29tcG9uZW50R2VuZXJhdGVkLCBZQXhpc0NvbXBvbmVudEdlbmVyYXRlZCwgWm9vbWFibGVDb21wb25lbnRHZW5lcmF0ZWQsIENvbGxlY3Rpb25JdGVtQ29tcG9uZW50LCBDb2xsZWN0aW9uQ29tcG9uZW50LCBDb2xsZWN0aW9uU2VydmljZSwgQ29uZmlndXJhdGlvblNlcnZpY2UsIFBSRUZJWCwgUHJlZml4Q29uZmlndXJhdGlvblNlcnZpY2UsIFJvb3RDb25maWd1cmF0aW9uU2VydmljZSwgU2V0dGluZ3NDb21wb25lbnQsIFRoZW1lU2VydmljZSwgVG9vbHRpcFRlbXBsYXRlU2VydmljZSwgQmFzZUV2ZW50LCBJbnN0YW5jZUV2ZW50U2VydmljZSwgTGVnZW5kRXZlbnQsIE5vdGVFdmVudCwgUHJldmVudGFibGVFdmVudCwgU2VyaWVzRXZlbnQsIFN0b2NrSW5zdGFuY2VFdmVudFNlcnZpY2UsIE5hdmlnYXRvckNvbXBvbmVudCwgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzQ29tcG9uZW50LCBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNDcm9zc2hhaXJDb21wb25lbnQsIE5hdmlnYXRvckNhdGVnb3J5QXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnQsIE5hdmlnYXRvckNhdGVnb3J5QXhpc0xhYmVsc0NvbXBvbmVudCwgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzTm90ZXNDb21wb25lbnQsIE5hdmlnYXRvckNhdGVnb3J5QXhpc05vdGVzSWNvbkNvbXBvbmVudCwgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzTm90ZXNMYWJlbENvbXBvbmVudCwgTmF2aWdhdG9yQ2F0ZWdvcnlBeGlzU2VsZWN0Q29tcG9uZW50LCBOYXZpZ2F0b3JDYXRlZ29yeUF4aXNUaXRsZUNvbXBvbmVudCwgTmF2aWdhdG9ySGludENvbXBvbmVudCwgTmF2aWdhdG9yUGFuZUNvbXBvbmVudCwgTmF2aWdhdG9yUGFuZVRpdGxlQ29tcG9uZW50LCBOYXZpZ2F0b3JTZWxlY3RDb21wb25lbnQsIE5hdmlnYXRvclNlcmllc0l0ZW1Db21wb25lbnQsIE5hdmlnYXRvclNlcmllc0Vycm9yQmFyc0NvbXBvbmVudCwgTmF2aWdhdG9yU2VyaWVzRXh0cmVtZXNDb21wb25lbnQsIE5hdmlnYXRvclNlcmllc0hpZ2hsaWdodENvbXBvbmVudCwgTmF2aWdhdG9yU2VyaWVzTGFiZWxzQ29tcG9uZW50LCBOYXZpZ2F0b3JTZXJpZXNMYWJlbHNGcm9tQ29tcG9uZW50LCBOYXZpZ2F0b3JTZXJpZXNMYWJlbHNUb0NvbXBvbmVudCwgTmF2aWdhdG9yU2VyaWVzTWFya2Vyc0NvbXBvbmVudCwgTmF2aWdhdG9yU2VyaWVzTm90ZXNDb21wb25lbnQsIE5hdmlnYXRvclNlcmllc05vdGVzSWNvbkNvbXBvbmVudCwgTmF2aWdhdG9yU2VyaWVzTm90ZXNMYWJlbENvbXBvbmVudCwgTmF2aWdhdG9yU2VyaWVzT3V0bGllcnNDb21wb25lbnQsIE5hdmlnYXRvclNlcmllc1Rvb2x0aXBDb21wb25lbnQsIE5hdmlnYXRvclNlcmllc0NvbXBvbmVudCwgQ2hhcnRNb2R1bGUsIFN0b2NrQ2hhcnRNb2R1bGUsIFNwYXJrbGluZU1vZHVsZSwgQ2hhcnRzTW9kdWxlLCBUb29sdGlwUG9wdXBDb21wb25lbnQsIENyb3NzaGFpclRvb2x0aXBzQ29udGFpbmVyQ29tcG9uZW50LCBDaGFydENvbXBvbmVudCwgQXhpc0RlZmF1bHRzQ29tcG9uZW50LCBBeGlzRGVmYXVsdHNDcm9zc2hhaXJDb21wb25lbnQsIEF4aXNEZWZhdWx0c0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnQsIEF4aXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudCwgQXhpc0RlZmF1bHRzVGl0bGVDb21wb25lbnQsIENhdGVnb3J5QXhpc0NvbXBvbmVudCwgQ2F0ZWdvcnlBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50LCBDYXRlZ29yeUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50LCBDYXRlZ29yeUF4aXNJdGVtQ29tcG9uZW50LCBDYXRlZ29yeUF4aXNMYWJlbHNDb21wb25lbnQsIENhdGVnb3J5QXhpc1JhbmdlTGFiZWxzQ29tcG9uZW50LCBDYXRlZ29yeUF4aXNOb3Rlc0NvbXBvbmVudCwgQ2F0ZWdvcnlBeGlzTm90ZXNJY29uQ29tcG9uZW50LCBDYXRlZ29yeUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50LCBDYXRlZ29yeUF4aXNTZWxlY3RDb21wb25lbnQsIENhdGVnb3J5QXhpc1RpdGxlQ29tcG9uZW50LCBDaGFydEFyZWFDb21wb25lbnQsIExlZ2VuZENvbXBvbmVudCwgTGVnZW5kSW5hY3RpdmVJdGVtc0NvbXBvbmVudCwgTGVnZW5kSXRlbUNvbXBvbmVudCwgUGFuZUNvbXBvbmVudCwgUGFuZURlZmF1bHRzQ29tcG9uZW50LCBQYW5lRGVmYXVsdHNUaXRsZUNvbXBvbmVudCwgUGFuZXNDb21wb25lbnQsIFBhbmVzVGl0bGVDb21wb25lbnQsIFBsb3RBcmVhQ29tcG9uZW50LCBTZXJpZXNDb21wb25lbnQsIFNlcmllc0RlZmF1bHRzQ29tcG9uZW50LCBTZXJpZXNEZWZhdWx0c0xhYmVsc0NvbXBvbmVudCwgU2VyaWVzRGVmYXVsdHNMYWJlbHNGcm9tQ29tcG9uZW50LCBTZXJpZXNEZWZhdWx0c0xhYmVsc1RvQ29tcG9uZW50LCBTZXJpZXNEZWZhdWx0c05vdGVzQ29tcG9uZW50LCBTZXJpZXNEZWZhdWx0c05vdGVzSWNvbkNvbXBvbmVudCwgU2VyaWVzRGVmYXVsdHNOb3Rlc0xhYmVsQ29tcG9uZW50LCBTZXJpZXNEZWZhdWx0c1Rvb2x0aXBDb21wb25lbnQsIFNlcmllc0Vycm9yQmFyc0NvbXBvbmVudCwgU2VyaWVzRXh0cmVtZXNDb21wb25lbnQsIFNlcmllc0hpZ2hsaWdodENvbXBvbmVudCwgU2VyaWVzSXRlbUNvbXBvbmVudCwgU2VyaWVzTGFiZWxzQ29tcG9uZW50LCBTZXJpZXNMYWJlbHNGcm9tQ29tcG9uZW50LCBTZXJpZXNMYWJlbHNUb0NvbXBvbmVudCwgU2VyaWVzTWFya2Vyc0NvbXBvbmVudCwgU2VyaWVzTm90ZXNDb21wb25lbnQsIFNlcmllc05vdGVzSWNvbkNvbXBvbmVudCwgU2VyaWVzTm90ZXNMYWJlbENvbXBvbmVudCwgU2VyaWVzT3V0bGllcnNDb21wb25lbnQsIFNlcmllc1Rvb2x0aXBDb21wb25lbnQsIFRpdGxlQ29tcG9uZW50LCBUb29sdGlwQ29tcG9uZW50LCBWYWx1ZUF4aXNDb21wb25lbnQsIFZhbHVlQXhpc0Nyb3NzaGFpckNvbXBvbmVudCwgVmFsdWVBeGlzQ3Jvc3NoYWlyVG9vbHRpcENvbXBvbmVudCwgVmFsdWVBeGlzSXRlbUNvbXBvbmVudCwgVmFsdWVBeGlzTGFiZWxzQ29tcG9uZW50LCBWYWx1ZUF4aXNOb3Rlc0NvbXBvbmVudCwgVmFsdWVBeGlzTm90ZXNJY29uQ29tcG9uZW50LCBWYWx1ZUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50LCBWYWx1ZUF4aXNUaXRsZUNvbXBvbmVudCwgWEF4aXNDb21wb25lbnQsIFhBeGlzQ3Jvc3NoYWlyQ29tcG9uZW50LCBYQXhpc0Nyb3NzaGFpclRvb2x0aXBDb21wb25lbnQsIFhBeGlzSXRlbUNvbXBvbmVudCwgWEF4aXNMYWJlbHNDb21wb25lbnQsIFhBeGlzTm90ZXNDb21wb25lbnQsIFhBeGlzTm90ZXNJY29uQ29tcG9uZW50LCBYQXhpc05vdGVzTGFiZWxDb21wb25lbnQsIFhBeGlzVGl0bGVDb21wb25lbnQsIFlBeGlzQ29tcG9uZW50LCBZQXhpc0Nyb3NzaGFpckNvbXBvbmVudCwgWUF4aXNDcm9zc2hhaXJUb29sdGlwQ29tcG9uZW50LCBZQXhpc0l0ZW1Db21wb25lbnQsIFlBeGlzTGFiZWxzQ29tcG9uZW50LCBZQXhpc05vdGVzQ29tcG9uZW50LCBZQXhpc05vdGVzSWNvbkNvbXBvbmVudCwgWUF4aXNOb3Rlc0xhYmVsQ29tcG9uZW50LCBZQXhpc1RpdGxlQ29tcG9uZW50LCBab29tYWJsZUNvbXBvbmVudCwgQ0hBUlRfRElSRUNUSVZFUywgQXhpc0xhYmVsQ2xpY2tFdmVudCwgRHJhZ0VuZEV2ZW50LCBEcmFnRXZlbnQsIERyYWdTdGFydEV2ZW50LCBMZWdlbmRJdGVtQ2xpY2tFdmVudCwgTGVnZW5kSXRlbUhvdmVyRXZlbnQsIE5vdGVDbGlja0V2ZW50LCBOb3RlSG92ZXJFdmVudCwgUGFuZVJlbmRlckV2ZW50LCBQbG90QXJlYUNsaWNrRXZlbnQsIFBsb3RBcmVhSG92ZXJFdmVudCwgUmVuZGVyRXZlbnQsIFNlbGVjdEVuZEV2ZW50LCBTZWxlY3RFdmVudCwgU2VsZWN0U3RhcnRFdmVudCwgU2VyaWVzQ2xpY2tFdmVudCwgU2VyaWVzSG92ZXJFdmVudCwgWm9vbUVuZEV2ZW50LCBab29tRXZlbnQsIFpvb21TdGFydEV2ZW50LCBXZWVrU3RhcnREYXksIE5hdmlnYXRvckZpbHRlckV2ZW50LCBTdG9ja0NoYXJ0Q29tcG9uZW50LCBTVE9DS19DSEFSVF9ESVJFQ1RJVkVTLCBTcGFya2xpbmVDb21wb25lbnQsIFNQQVJLTElORV9ESVJFQ1RJVkVTIH07XG4iXX0=